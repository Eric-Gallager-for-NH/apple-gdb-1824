% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF dwarf2read.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File dwarf2read.c}{File dwarf2read.c}
\section{File dwarf2read.c}
\label{file_dwarf2read.c}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <uuid/uuid.h>} &\\
\hspace*{0.2in}{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/obstack.h"} &\cxreffile{../include/obstack.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.8in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{1.0in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{1.0in}{\stt \#include <regex.h>} &\\
\hspace*{0.8in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.8in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.8in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{1.0in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/elf/dwarf2.h"} &\cxreffile{../include/elf/dwarf2.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "buildsym.h"} &\cxreffile{buildsym.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/demangle.h"} &\cxreffile{../include/demangle.h}\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/filenames.h"} &\cxreffile{../include/filenames.h}\\
\hspace*{0.2in}{\stt \#include "../include/hashtab.h"} &\cxreffile{../include/hashtab.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "macrotab.h"} &\cxreffile{macrotab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "complaints.h"} &\cxreffile{complaints.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "bcache.h"} &\cxreffile{bcache.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "dwarf2expr.h"} &\cxreffile{dwarf2expr.h}\\
\hspace*{0.2in}{\stt \#include "dwarf2loc.h"} &\cxreffile{dwarf2loc.h}\\
\hspace*{0.4in}{\stt \#include "dwarf2read.h"} &\cxreffile{dwarf2read.h}\\
\hspace*{0.6in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "dwarf2loc.h"} &\cxreffile{dwarf2loc.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cp-support.h"} &\cxreffile{cp-support.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/hashtab.h"} &\cxreffile{../include/hashtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <fcntl.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <sys/types.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "db-access-functions.h"} &\cxreffile{db-access-functions.h}\\
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\hspace*{0.2in}{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "block.h"} &\cxreffile{block.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcore.h"} &\cxreffile{gdbcore.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "dwarf2read.h"} &\cxreffile{dwarf2read.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <ctype.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objc-lang.h"} &\cxreffile{objc-lang.h}\\
\hspace*{0.2in}{\stt \#include <Availability.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <libgen.h>} &\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define \_ACTUAL\_COMP\_UNIT\_HEADER\_SIZE 11}

\medskip
{\stt \#define \_ACTUAL\_PUBNAMES\_HEADER\_SIZE 13}

\medskip
{\stt \#define \_ACTUAL\_PUBTYPES\_HEADER\_SIZE 13}

\medskip
{\stt \#define \_ACTUAL\_ARANGES\_HEADER\_SIZE 12}

\medskip
{\stt \#define INFO\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_info"}

\medskip
{\stt \#define ABBREV\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_abbrev"}

\medskip
{\stt \#define LINE\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_line"}

\medskip
{\stt \#define PUBNAMES\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_pubnames"}

\medskip
{\stt \#define PUBTYPES\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_pubtypes"}

\medskip
{\stt \#define INLINED\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_inlined"}

\medskip
{\stt \#define ARANGES\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_aranges"}

\medskip
{\stt \#define LOC\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_loc"}

\medskip
{\stt \#define MACINFO\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_macinfo"}

\medskip
{\stt \#define STR\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_str"}

\medskip
{\stt \#define FRAME\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_frame"}

\medskip
{\stt \#define RANGES\_SECTION "LC\_SEGMENT.\_\_DWARF.\_\_debug\_ranges"}

\medskip
{\stt \#define EH\_FRAME\_SECTION "LC\_SEGMENT.\_\_TEXT.\_\_eh\_frame"}

\medskip
{\stt \#define MACINFO\_SECTION "debug\_macinfo\_do\_not\_use"}

\medskip
{\stt \#define ABBREV\_HASH\_SIZE 121}

\medskip
{\stt \#define REF\_HASH\_SIZE 1021}

\medskip
{\stt \#define DW\_STRING( attr )}

\medskip
{\stt \#define DW\_UNSND( attr )}

\medskip
{\stt \#define DW\_BLOCK( attr )}

\medskip
{\stt \#define DW\_SND( attr )}

\medskip
{\stt \#define DW\_ADDR( attr )}

\medskip
{\stt \#define ATTR\_ALLOC\_CHUNK 4}

\medskip
{\stt \#define DW\_FIELD\_ALLOC\_CHUNK 4}

\medskip
{\stt \#define TARGET\_ADDRESS\_BYTES}

\medskip
{\stt \#define MAX\_SEP\_LEN 2}

\medskip
{\stt \#define LOCDESC\_STACKSIZE 64}

\medskip
{\stt \#define MAX\_OPEN\_DBS 100}

\medskip
{\stt \#define SELECT\_DIE\_STR "SELECT long\_canonical FROM debug\_info WHERE die\_id == ?"}

\medskip
{\stt \#define FIND\_STRING\_STR "SELECT string FROM debug\_str WHERE string\_id == ?"}


\subsection{Type definitions}


\subsubsection{Typedef \_COMP\_UNIT\_HEADER}
\label{type__COMP_UNIT_HEADER_dwarf2read.c}

{\stt typedef struct comp\_unit\_header \_COMP\_UNIT\_HEADER}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct comp\_unit\_header} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int length;} &\\
\hspace*{0.2in}{\stt unsigned short version;} &\\
\hspace*{0.2in}{\stt unsigned int abbrev\_offset;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned char addr\_size;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef \_PUBNAMES\_HEADER}
\label{type__PUBNAMES_HEADER_dwarf2read.c}

{\stt typedef struct pubnames\_header \_PUBNAMES\_HEADER}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct pubnames\_header} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int length;} &\\
\hspace*{0.2in}{\stt unsigned char version;} &\\
\hspace*{0.2in}{\stt unsigned int info\_offset;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int info\_size;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef \_PUBTYPES\_HEADER}
\label{type__PUBTYPES_HEADER_dwarf2read.c}

{\stt typedef struct pubtypes\_header \_PUBTYPES\_HEADER}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct pubtypes\_header} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int length;} &\\
\hspace*{0.2in}{\stt unsigned char version;} &\\
\hspace*{0.2in}{\stt unsigned int info\_offset;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int info\_size;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef \_ARANGES\_HEADER}
\label{type__ARANGES_HEADER_dwarf2read.c}

{\stt typedef struct aranges\_header \_ARANGES\_HEADER}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct aranges\_header} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int length;} &\\
\hspace*{0.2in}{\stt unsigned short version;} &\\
\hspace*{0.2in}{\stt unsigned int info\_offset;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned char addr\_size;} &\\
\hspace*{0.2in}{\stt unsigned char seg\_size;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef \_STATEMENT\_PROLOGUE}
\label{type__STATEMENT_PROLOGUE_dwarf2read.c}

{\stt typedef struct statement\_prologue \_STATEMENT\_PROLOGUE}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct statement\_prologue} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int total\_length;} &\\
\hspace*{0.2in}{\stt unsigned short version;} &\\
\hspace*{0.2in}{\stt unsigned int prologue\_length;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned char minimum\_instruction\_length;} &\\
\hspace*{0.2in}{\stt unsigned char default\_is\_stmt;} &\\
\hspace*{0.2in}{\stt char line\_base;} &\\
\hspace*{0.2in}{\stt unsigned char line\_range;} &\\
\hspace*{0.2in}{\stt unsigned char opcode\_base;} &\\
\hspace*{0.2in}{\stt unsigned char* standard\_opcode\_lengths;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct dwarf2\_per\_objfile}
\label{type_struct_dwarf2_per_objfile_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct dwarf2\_per\_objfile} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int info\_size;} &\\
\hspace*{0.2in}{\stt unsigned int abbrev\_size;} &\\
\hspace*{0.2in}{\stt unsigned int line\_size;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int pubnames\_size;} &\\
\hspace*{0.2in}{\stt unsigned int pubtypes\_size;} &\\
\hspace*{0.2in}{\stt unsigned int aranges\_size;} &\\
\hspace*{0.2in}{\stt unsigned int loc\_size;} &\\
\hspace*{0.2in}{\stt unsigned int macinfo\_size;} &\\
\hspace*{0.2in}{\stt unsigned int str\_size;} &\\
\hspace*{0.2in}{\stt unsigned int ranges\_size;} &\\
\hspace*{0.2in}{\stt unsigned int frame\_size;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int eh\_frame\_size;} &\\
\hspace*{0.2in}{\stt unsigned int inlined\_size;} &\\
\hspace*{0.2in}{\stt char* info\_buffer;} &\\
\hspace*{0.2in}{\stt char* abbrev\_buffer;} &\\
\hspace*{0.2in}{\stt char* line\_buffer;} &\\
\hspace*{0.2in}{\stt char* str\_buffer;} &\\
\hspace*{0.2in}{\stt char* macinfo\_buffer;} &\\
\hspace*{0.2in}{\stt char* ranges\_buffer;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt char* loc\_buffer;} &\\
\hspace*{0.2in}{\stt char* inlined\_buffer;} &\\
\hspace*{0.2in}{\stt bfd\_window info\_window;} &\\
\hspace*{0.2in}{\stt bfd\_window abbrev\_window;} &\\
\hspace*{0.2in}{\stt bfd\_window line\_window;} &\\
\hspace*{0.2in}{\stt bfd\_window str\_window;} &\\
\hspace*{0.2in}{\stt bfd\_window macinfo\_window;} &\\
\hspace*{0.2in}{\stt bfd\_window ranges\_window;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt bfd\_window loc\_window;} &\\
\hspace*{0.2in}{\stt struct dwarf2\_per\_cu\_data** all\_comp\_units;} &\\
\hspace*{0.2in}{\stt int n\_comp\_units;} &\\
\hspace*{0.2in}{\stt struct dwarf2\_per\_cu\_data* read\_in\_chain;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct rb\_repository\_data}
\label{type_struct_rb_repository_data_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct rb\_repository\_data} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct type* type\_data;} &\\
\hspace*{0.2in}{\stt struct die\_info* die\_data;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct comp\_unit\_head}
\label{type_struct_comp_unit_head_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct comp\_unit\_head} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned long length;} &\\
\hspace*{0.2in}{\stt short version;} &\\
\hspace*{0.2in}{\stt unsigned int abbrev\_offset;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned char addr\_size;} &\\
\hspace*{0.2in}{\stt unsigned char signed\_addr\_p;} &\\
\hspace*{0.2in}{\stt unsigned int offset\_size;} &\\
\hspace*{0.2in}{\stt unsigned int initial\_length\_size;} &\\
\hspace*{0.2in}{\stt unsigned int offset;} &\\
\hspace*{0.2in}{\stt char* cu\_head\_ptr;} &\\
\hspace*{0.2in}{\stt char* first\_die\_ptr;} &\\
\hspace*{0.2in}{\stt struct comp\_unit\_head* next;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt CORE\_ADDR base\_address\_untranslated;} &\\
\hspace*{0.2in}{\stt int base\_known;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct dwarf2\_cu}
\label{type_struct_dwarf2_cu_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct dwarf2\_cu} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct objfile* objfile;} &\\
\hspace*{0.2in}{\stt struct comp\_unit\_head header;} &\\
\hspace*{0.2in}{\stt struct function\_range* first\_fn;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct function\_range* last\_fn;} &\\
\hspace*{0.2in}{\stt struct function\_range* cached\_fn;} &\\
\hspace*{0.2in}{\stt enum language language;} &\\
\hspace*{0.2in}{\stt const struct language\_defn* language\_defn;} &\\
\hspace*{0.2in}{\stt const char* producer;} &\\
\hspace*{0.2in}{\stt char* comp\_dir;} &\\
\hspace*{0.2in}{\stt struct pending** list\_in\_scope;} &\\
\hspace*{0.2in}{\stt struct type* ftypes[29];} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct abbrev\_info** dwarf2\_abbrevs;} &\\
\hspace*{0.2in}{\stt struct obstack abbrev\_obstack;} &\\
\hspace*{0.2in}{\stt htab\_t partial\_dies;} &\\
\hspace*{0.2in}{\stt struct obstack comp\_unit\_obstack;} &\\
\hspace*{0.2in}{\stt struct dwarf2\_per\_cu\_data* read\_in\_chain;} &\\
\hspace*{0.2in}{\stt struct dwarf2\_per\_cu\_data* per\_cu;} &\\
\hspace*{0.2in}{\stt int last\_used;} &\\
\hspace*{0.2in}{\stt struct die\_info* die\_ref\_table[1021];} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct die\_info* dies;} &\\
\hspace*{0.2in}{\stt htab\_t dependencies;} &\\
\hspace*{0.2in}{\stt unsigned int mark:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_form\_ref\_addr:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_namespace\_info:1;} &\\
\hspace*{0.2in}{\stt unsigned int cu\_is\_optimized:1;} &\\
\hspace*{0.2in}{\stt sqlite3* repository;} &\\
\hspace*{0.2in}{\stt char* repository\_name;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct oso\_to\_final\_addr\_map* addr\_map;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct dwarf2\_per\_cu\_data}
\label{type_struct_dwarf2_per_cu_data_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct dwarf2\_per\_cu\_data} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned long offset;} &\\
\hspace*{0.2in}{\stt unsigned long length:31;} &\\
\hspace*{0.2in}{\stt unsigned long queued:1;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct dwarf2\_cu* cu;} &\\
\hspace*{0.2in}{\stt htab\_t type\_hash;} &\\
\hspace*{0.2in}{\stt struct partial\_symtab* psymtab;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct file\_entry}
\label{type_struct_file_entry_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct file\_entry} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* name;} &\\
\hspace*{0.2in}{\stt unsigned int dir\_index;} &\\
\hspace*{0.2in}{\stt unsigned int mod\_time;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int length;} &\\
\hspace*{0.2in}{\stt int included\_p;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct line\_header}
\label{type_struct_line_header_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct line\_header} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int total\_length;} &\\
\hspace*{0.2in}{\stt unsigned short version;} &\\
\hspace*{0.2in}{\stt unsigned int header\_length;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned char minimum\_instruction\_length;} &\\
\hspace*{0.2in}{\stt unsigned char default\_is\_stmt;} &\\
\hspace*{0.2in}{\stt int line\_base;} &\\
\hspace*{0.2in}{\stt unsigned char line\_range;} &\\
\hspace*{0.2in}{\stt unsigned char opcode\_base;} &\\
\hspace*{0.2in}{\stt unsigned char* standard\_opcode\_lengths;} &\\
\hspace*{0.2in}{\stt unsigned int num\_include\_dirs;} &\\
\hspace*{0.2in}{\stt unsigned int include\_dirs\_size;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt char** include\_dirs;} &\\
\hspace*{0.2in}{\stt unsigned int num\_file\_names;} &\\
\hspace*{0.2in}{\stt unsigned int file\_names\_size;} &\\
\hspace*{0.2in}{\stt struct file\_entry* file\_names;} &\\
\hspace*{0.2in}{\stt char* statement\_program\_start;} &\\
\hspace*{0.2in}{\stt char* statement\_program\_end;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct partial\_die\_info}
\label{type_struct_partial_die_info_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct partial\_die\_info} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int offset;} &\\
\hspace*{0.2in}{\stt enum dwarf\_tag tag:16;} &\\
\hspace*{0.2in}{\stt unsigned int language:8;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int has\_children:1;} &\\
\hspace*{0.2in}{\stt unsigned int is\_external:1;} &\\
\hspace*{0.2in}{\stt unsigned int is\_declaration:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_type:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_specification:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_stmt\_list:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_pc\_info:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_repo\_specification:1;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int has\_repository:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_repository\_type:1;} &\\
\hspace*{0.2in}{\stt unsigned int scope\_set:1;} &\\
\hspace*{0.2in}{\stt const char* name;} &\\
\hspace*{0.2in}{\stt char* dirname;} &\\
\hspace*{0.2in}{\stt const char* scope;} &\\
\hspace*{0.2in}{\stt struct dwarf\_block* locdesc;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR lowpc;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt CORE\_ADDR highpc;} &\\
\hspace*{0.2in}{\stt char* sibling;} &\\
\hspace*{0.2in}{\stt unsigned int spec\_offset;} &\\
\hspace*{0.2in}{\stt unsigned int repo\_spec\_id;} &\\
\hspace*{0.2in}{\stt char* repo\_name;} &\\
\hspace*{0.2in}{\stt unsigned int line\_offset;} &\\
\hspace*{0.2in}{\stt struct partial\_die\_info* die\_parent;} &\\
\hspace*{0.2in}{\stt struct partial\_die\_info* die\_child;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct partial\_die\_info* die\_sibling;} &\\
\hspace*{0.2in}{\stt const char* equiv\_name;} &\\
\hspace*{0.2in}{\stt short int isa\_value;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct abbrev\_info}
\label{type_struct_abbrev_info_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct abbrev\_info} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int number;} &\\
\hspace*{0.2in}{\stt enum dwarf\_tag tag;} &\\
\hspace*{0.2in}{\stt unsigned short has\_children;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned short num\_attrs;} &\\
\hspace*{0.2in}{\stt struct attr\_abbrev* attrs;} &\\
\hspace*{0.2in}{\stt struct abbrev\_info* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct attr\_abbrev}
\label{type_struct_attr_abbrev_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct attr\_abbrev} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum dwarf\_attribute name;} &\\
\hspace*{0.2in}{\stt enum dwarf\_form form;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct die\_info}
\label{type_struct_die_info_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct die\_info} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum dwarf\_tag tag;} &\\
\hspace*{0.2in}{\stt unsigned int abbrev;} &\\
\hspace*{0.2in}{\stt unsigned int offset;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int repository\_id;} &\\
\hspace*{0.2in}{\stt unsigned int num\_attrs;} &\\
\hspace*{0.2in}{\stt struct attribute* attrs;} &\\
\hspace*{0.2in}{\stt struct die\_info* next\_ref;} &\\
\hspace*{0.2in}{\stt struct die\_info* child;} &\\
\hspace*{0.2in}{\stt struct die\_info* sibling;} &\\
\hspace*{0.2in}{\stt struct die\_info* parent;} &\\
\hspace*{0.2in}{\stt struct type* type;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct attribute}
\label{type_struct_attribute_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct attribute} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum dwarf\_attribute name;} &\\
\hspace*{0.2in}{\stt enum dwarf\_form form;} &\\
\hspace*{0.2in}{\stt union} &\\
\hspace*{0.3in}{\stt \{} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.4in}{\stt char* str;} &\\
\hspace*{0.4in}{\stt struct dwarf\_block* blk;} &\\
\hspace*{0.4in}{\stt unsigned long unsnd;} &\\
\hspace*{0.4in}{\stt long int snd;} &\\
\hspace*{0.4in}{\stt CORE\_ADDR addr;} &\\
\hspace*{0.3in}{\stt \}} &\\
\hspace*{0.3in}{\stt u;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct function\_range}
\label{type_struct_function_range_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct function\_range} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt const char* name;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR lowpc;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR highpc;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int seen\_line;} &\\
\hspace*{0.2in}{\stt struct function\_range* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct dwarf\_block}
\label{type_struct_dwarf_block_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct dwarf\_block} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int size;} &\\
\hspace*{0.2in}{\stt char* data;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct nextfield}
\label{type_struct_nextfield_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct nextfield} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct nextfield* next;} &\\
\hspace*{0.2in}{\stt int accessibility;} &\\
\hspace*{0.2in}{\stt int virtuality;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct field field;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct nextfnfield}
\label{type_struct_nextfnfield_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct nextfnfield} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct nextfnfield* next;} &\\
\hspace*{0.2in}{\stt struct fn\_field fnfield;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct fnfieldlist}
\label{type_struct_fnfieldlist_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct fnfieldlist} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* name;} &\\
\hspace*{0.2in}{\stt int length;} &\\
\hspace*{0.2in}{\stt struct nextfnfield* head;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct field\_info}
\label{type_struct_field_info_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct field\_info} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct nextfield* fields;} &\\
\hspace*{0.2in}{\stt int nfields;} &\\
\hspace*{0.2in}{\stt int nbaseclasses;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int non\_public\_fields;} &\\
\hspace*{0.2in}{\stt struct nextfnfield* fnfields;} &\\
\hspace*{0.2in}{\stt struct fnfieldlist* fnfieldlists;} &\\
\hspace*{0.2in}{\stt int nfnfields;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct dwarf2\_queue\_item}
\label{type_struct_dwarf2_queue_item_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct dwarf2\_queue\_item} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct dwarf2\_per\_cu\_data* per\_cu;} &\\
\hspace*{0.2in}{\stt struct dwarf2\_queue\_item* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum db\_status}
\label{type_enum_db_status_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum db\_status} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt DB\_UNKNOWN;} &\\
\hspace*{0.2in}{\stt DB\_OPEN;} &\\
\hspace*{0.2in}{\stt DB\_ABBREVS\_LOADED;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt DB\_CLOSED;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct objfile\_list\_node}
\label{type_struct_objfile_list_node_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct objfile\_list\_node} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct objfile* ofile;} &\\
\hspace*{0.2in}{\stt struct objfile\_list\_node* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct database\_info}
\label{type_struct_database_info_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct database\_info} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* fullname;} &\\
\hspace*{0.2in}{\stt struct abbrev\_info* abbrev\_table;} &\\
\hspace*{0.2in}{\stt enum db\_status current\_status;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct rb\_tree\_node* db\_types;} &\\
\hspace*{0.2in}{\stt struct objfile\_list\_node* num\_uses;} &\\
\hspace*{0.2in}{\stt struct dwarf2\_cu* dummy\_cu;} &\\
\hspace*{0.2in}{\stt struct objfile* dummy\_objfile;} &\\
\hspace*{0.2in}{\stt sqlite3* db;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct final\_addr\_key}
\label{type_struct_final_addr_key_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct final\_addr\_key} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt CORE\_ADDR final\_addr;} &\\
\hspace*{0.2in}{\stt struct oso\_to\_final\_addr\_map* map;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct dwarf2\_offset\_and\_type}
\label{type_struct_dwarf2_offset_and_type_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct dwarf2\_offset\_and\_type} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt unsigned int offset;} &\\
\hspace*{0.2in}{\stt struct type* type;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct attr\_pair}
\label{type_struct_attr_pair_dwarf2read.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct attr\_pair} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt int attribute;} &\\
\hspace*{0.2in}{\stt int form;} &\\
\hspace*{0.2in}{\stt struct attr\_pair* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable psym\_equivalences}
\label{var_psym_equivalences_dwarf2read.c}

{\stt int psym\_equivalences}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-exp.c & \ & \cxreffile{ada-exp.c}\\
\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & ada-typeprint.c & \ & \cxreffile{ada-typeprint.c}\\
\ & ada-valprint.c & \ & \cxreffile{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & ax-gdb.c & \ & \cxreffile{ax-gdb.c}\\
\ & ax-general.c & \ & \cxreffile{ax-general.c}\\
\ & bcache.c & \ & \cxreffile{bcache.c}\\
\ & bfd-target.c & \ & \cxreffile{bfd-target.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & buildsym.c & \ & \cxreffile{buildsym.c}\\
\ & c-exp.c & \ & \cxreffile{c-exp.c}\\
\ & c-lang.c & \ & \cxreffile{c-lang.c}\\
\ & c-typeprint.c & \ & \cxreffile{c-typeprint.c}\\
\ & c-valprint.c & \ & \cxreffile{c-valprint.c}\\
\ & charset.c & \ & \cxreffile{charset.c}\\
\ & cli-out.c & \ & \cxreffile{cli-out.c}\\
\ & coff-pe-read.c & \ & \cxreffile{coff-pe-read.c}\\
\cxreftabbreak{cxreftabiii}
\ & coffread.c & \ & \cxreffile{coffread.c}\\
\ & complaints.c & \ & \cxreffile{complaints.c}\\
\ & completer.c & \ & \cxreffile{completer.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & cp-abi.c & \ & \cxreffile{cp-abi.c}\\
\ & cp-namespace.c & \ & \cxreffile{cp-namespace.c}\\
\ & cp-support.c & \ & \cxreffile{cp-support.c}\\
\ & cp-valprint.c & \ & \cxreffile{cp-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & demangle.c & \ & \cxreffile{demangle.c}\\
\ & dictionary.c & \ & \cxreffile{dictionary.c}\\
\ & disasm.c & \ & \cxreffile{disasm.c}\\
\ & doublest.c & \ & \cxreffile{doublest.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2-frame.c & \ & \cxreffile{dwarf2-frame.c}\\
\ & dwarf2expr.c & \ & \cxreffile{dwarf2expr.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
\ & dwarfread.c & \ & \cxreffile{dwarfread.c}\\
\ & elfread.c & \ & \cxreffile{elfread.c}\\
\ & environ.c & \ & \cxreffile{environ.c}\\
\ & eval.c & \ & \cxreffile{eval.c}\\
\ & event-loop.c & \ & \cxreffile{event-loop.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\cxreftabbreak{cxreftabiii}
\ & expprint.c & \ & \cxreffile{expprint.c}\\
\ & f-exp.c & \ & \cxreffile{f-exp.c}\\
\ & f-lang.c & \ & \cxreffile{f-lang.c}\\
\ & f-typeprint.c & \ & \cxreffile{f-typeprint.c}\\
\ & f-valprint.c & \ & \cxreffile{f-valprint.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame-base.c & \ & \cxreffile{frame-base.c}\\
\ & frame-unwind.c & \ & \cxreffile{frame-unwind.c}\\
\cxreftabbreak{cxreftabiii}
\ & frame.c & \ & \cxreffile{frame.c}\\
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & gdbtypes.c & \ & \cxreffile{gdbtypes.c}\\
\ & gnu-v2-abi.c & \ & \cxreffile{gnu-v2-abi.c}\\
\ & gnu-v3-abi.c & \ & \cxreffile{gnu-v3-abi.c}\\
\ & hpacc-abi.c & \ & \cxreffile{hpacc-abi.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\cxreftabbreak{cxreftabiii}
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & interps.c & \ & \cxreffile{interps.c}\\
\ & jv-exp.c & \ & \cxreffile{jv-exp.c}\\
\ & jv-lang.c & \ & \cxreffile{jv-lang.c}\\
\ & jv-typeprint.c & \ & \cxreffile{jv-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & jv-valprint.c & \ & \cxreffile{jv-valprint.c}\\
\ & kod-cisco.c & \ & \cxreffile{kod-cisco.c}\\
\ & kod.c & \ & \cxreffile{kod.c}\\
\ & language.c & \ & \cxreffile{language.c}\\
\ & linespec.c & \ & \cxreffile{linespec.c}\\
\ & m2-exp.c & \ & \cxreffile{m2-exp.c}\\
\ & m2-lang.c & \ & \cxreffile{m2-lang.c}\\
\ & m2-typeprint.c & \ & \cxreffile{m2-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & m2-valprint.c & \ & \cxreffile{m2-valprint.c}\\
\ & macrocmd.c & \ & \cxreffile{macrocmd.c}\\
\ & macroexp.c & \ & \cxreffile{macroexp.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\ & macrotab.c & \ & \cxreffile{macrotab.c}\\
\ & main.c & \ & \cxreffile{main.c}\\
\ & maint.c & \ & \cxreffile{maint.c}\\
\ & mdebugread.c & \ & \cxreffile{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & memattr.c & \ & \cxreffile{memattr.c}\\
\ & minsyms.c & \ & \cxreffile{minsyms.c}\\
\ & mipsread.c & \ & \cxreffile{mipsread.c}\\
\ & nlmread.c & \ & \cxreffile{nlmread.c}\\
\ & objc-exp.c & \ & \cxreffile{objc-exp.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & observer.c & \ & \cxreffile{observer.c}\\
\ & osabi.c & \ & \cxreffile{osabi.c}\\
\ & p-exp.c & \ & \cxreffile{p-exp.c}\\
\ & p-lang.c & \ & \cxreffile{p-lang.c}\\
\ & p-typeprint.c & \ & \cxreffile{p-typeprint.c}\\
\ & p-valprint.c & \ & \cxreffile{p-valprint.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & printcmd.c & \ & \cxreffile{printcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & reggroups.c & \ & \cxreffile{reggroups.c}\\
\ & remote-fileio.c & \ & \cxreffile{remote-fileio.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & scm-exp.c & \ & \cxreffile{scm-exp.c}\\
\ & scm-lang.c & \ & \cxreffile{scm-lang.c}\\
\ & scm-valprint.c & \ & \cxreffile{scm-valprint.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & ser-base.c & \ & \cxreffile{ser-base.c}\\
\ & ser-unix.c & \ & \cxreffile{ser-unix.c}\\
\ & serial.c & \ & \cxreffile{serial.c}\\
\ & solib-null.c & \ & \cxreffile{solib-null.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & source.c & \ & \cxreffile{source.c}\\
\ & stabsread.c & \ & \cxreffile{stabsread.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\cxreftabbreak{cxreftabiii}
\ & std-regs.c & \ & \cxreffile{std-regs.c}\\
\ & symfile-mem.c & \ & \cxreffile{symfile-mem.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symmisc.c & \ & \cxreffile{symmisc.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & trad-frame.c & \ & \cxreffile{trad-frame.c}\\
\ & tramp-frame.c & \ & \cxreffile{tramp-frame.c}\\
\ & typeprint.c & \ & \cxreffile{typeprint.c}\\
\ & ui-file.c & \ & \cxreffile{ui-file.c}\\
\ & ui-out.c & \ & \cxreffile{ui-out.c}\\
\ & user-regs.c & \ & \cxreffile{user-regs.c}\\
\cxreftabbreak{cxreftabiii}
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valarith.c & \ & \cxreffile{valarith.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
\ & valprint.c & \ & \cxreffile{valprint.c}\\
\ & value.c & \ & \cxreffile{value.c}\\
\ & varobj.c & \ & \cxreffile{varobj.c}\\
\ & wrapper.c & \ & \cxreffile{wrapper.c}\\
Used in:\ & iter\_name\_first\_hashed() & dictionary.c & \cxreffunc{iter_name_first_hashed}{dictionary.c}\\
\ & iter\_name\_next\_hashed() & dictionary.c & \cxreffunc{iter_name_next_hashed}{dictionary.c}\\
\ & iter\_name\_next\_linear() & dictionary.c & \cxreffunc{iter_name_next_linear}{dictionary.c}\\
\ & lookup\_equiv\_partial\_symbol() & symtab.c & \cxreffunc{lookup_equiv_partial_symbol}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Variable dwarf2\_allow\_inlined\_stepping}
\label{var_dwarf2_allow_inlined_stepping_dwarf2read.c}

{\stt int dwarf2\_allow\_inlined\_stepping}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-exp.c & \ & \cxreffile{ada-exp.c}\\
\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & buildsym.c & \ & \cxreffile{buildsym.c}\\
\ & c-exp.c & \ & \cxreffile{c-exp.c}\\
\ & coff-pe-read.c & \ & \cxreffile{coff-pe-read.c}\\
\ & coffread.c & \ & \cxreffile{coffread.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & cp-namespace.c & \ & \cxreffile{cp-namespace.c}\\
\ & cp-support.c & \ & \cxreffile{cp-support.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\cxreftabbreak{cxreftabiii}
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2-frame.c & \ & \cxreffile{dwarf2-frame.c}\\
\ & dwarf2expr.c & \ & \cxreffile{dwarf2expr.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
\ & dwarfread.c & \ & \cxreffile{dwarfread.c}\\
\ & elfread.c & \ & \cxreffile{elfread.c}\\
\ & f-exp.c & \ & \cxreffile{f-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & frame-unwind.c & \ & \cxreffile{frame-unwind.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\ & gdbtypes.c & \ & \cxreffile{gdbtypes.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & jv-exp.c & \ & \cxreffile{jv-exp.c}\\
\ & jv-lang.c & \ & \cxreffile{jv-lang.c}\\
\ & linespec.c & \ & \cxreffile{linespec.c}\\
\ & m2-exp.c & \ & \cxreffile{m2-exp.c}\\
\ & macrotab.c & \ & \cxreffile{macrotab.c}\\
\ & maint.c & \ & \cxreffile{maint.c}\\
\ & mdebugread.c & \ & \cxreffile{mdebugread.c}\\
\ & minsyms.c & \ & \cxreffile{minsyms.c}\\
\ & mipsread.c & \ & \cxreffile{mipsread.c}\\
\ & nlmread.c & \ & \cxreffile{nlmread.c}\\
\ & objc-exp.c & \ & \cxreffile{objc-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & p-exp.c & \ & \cxreffile{p-exp.c}\\
\ & printcmd.c & \ & \cxreffile{printcmd.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & source.c & \ & \cxreffile{source.c}\\
\ & stabsread.c & \ & \cxreffile{stabsread.c}\\
\cxreftabbreak{cxreftabiii}
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile-mem.c & \ & \cxreffile{symfile-mem.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symmisc.c & \ & \cxreffile{symmisc.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & tramp-frame.c & \ & \cxreffile{tramp-frame.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
\ & varobj.c & \ & \cxreffile{varobj.c}\\
Used in:\ & \_initialize\_dwarf2\_read() & dwarf2read.c & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\ & inlined\_function\_update\_call\_stack() & inlining.c & \cxreffunc{inlined_function_update_call_stack}{inlining.c}\\
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & rest\_of\_line\_contains\_inlined\_subroutine() & inlining.c & \cxreffunc{rest_of_line_contains_inlined_subroutine}{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & step\_1() & infcmd.c & \cxreffunc{step_1}{infcmd.c}\\
\ & update\_tmp\_frame\_stack() & inlining.c & \cxreffunc{update_tmp_frame_stack}{inlining.c}\\
\ & verify\_stack() & inlining.c & \cxreffunc{verify_stack}{inlining.c}\\
\end{cxreftabiii}


\subsubsection{Variable dwarf2\_debug\_inlined\_stepping}
\label{var_dwarf2_debug_inlined_stepping_dwarf2read.c}

{\stt int dwarf2\_debug\_inlined\_stepping}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-exp.c & \ & \cxreffile{ada-exp.c}\\
\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & buildsym.c & \ & \cxreffile{buildsym.c}\\
\ & c-exp.c & \ & \cxreffile{c-exp.c}\\
\ & coff-pe-read.c & \ & \cxreffile{coff-pe-read.c}\\
\ & coffread.c & \ & \cxreffile{coffread.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & cp-namespace.c & \ & \cxreffile{cp-namespace.c}\\
\ & cp-support.c & \ & \cxreffile{cp-support.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\cxreftabbreak{cxreftabiii}
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2-frame.c & \ & \cxreffile{dwarf2-frame.c}\\
\ & dwarf2expr.c & \ & \cxreffile{dwarf2expr.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
\ & dwarfread.c & \ & \cxreffile{dwarfread.c}\\
\ & elfread.c & \ & \cxreffile{elfread.c}\\
\ & f-exp.c & \ & \cxreffile{f-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & frame-unwind.c & \ & \cxreffile{frame-unwind.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\ & gdbtypes.c & \ & \cxreffile{gdbtypes.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & jv-exp.c & \ & \cxreffile{jv-exp.c}\\
\ & jv-lang.c & \ & \cxreffile{jv-lang.c}\\
\ & linespec.c & \ & \cxreffile{linespec.c}\\
\ & m2-exp.c & \ & \cxreffile{m2-exp.c}\\
\ & macrotab.c & \ & \cxreffile{macrotab.c}\\
\ & maint.c & \ & \cxreffile{maint.c}\\
\ & mdebugread.c & \ & \cxreffile{mdebugread.c}\\
\ & minsyms.c & \ & \cxreffile{minsyms.c}\\
\ & mipsread.c & \ & \cxreffile{mipsread.c}\\
\ & nlmread.c & \ & \cxreffile{nlmread.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc-exp.c & \ & \cxreffile{objc-exp.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & p-exp.c & \ & \cxreffile{p-exp.c}\\
\ & printcmd.c & \ & \cxreffile{printcmd.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & source.c & \ & \cxreffile{source.c}\\
\cxreftabbreak{cxreftabiii}
\ & stabsread.c & \ & \cxreffile{stabsread.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile-mem.c & \ & \cxreffile{symfile-mem.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symmisc.c & \ & \cxreffile{symmisc.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\cxreftabbreak{cxreftabiii}
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & tramp-frame.c & \ & \cxreffile{tramp-frame.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
\ & varobj.c & \ & \cxreffile{varobj.c}\\
Used in:\ & \_initialize\_dwarf2\_read() & dwarf2read.c & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\ & check\_inlined\_function\_calls() & dwarf2read.c & \cxreffunc{check_inlined_function_calls}{dwarf2read.c}\\
\ & rb\_tree\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_remove_node}{dwarf2read.c}\\
\ & record\_line() & buildsym.c & \cxreffunc{record_line}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\ & step\_1\_inlining() & infcmd.c & \cxreffunc{step_1_inlining}{infcmd.c}\\
\ & step\_once() & infcmd.c & \cxreffunc{step_once}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Variable dwarf\_frame\_section}
\label{var_dwarf_frame_section_dwarf2read.c}

{\stt asection* dwarf\_frame\_section}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarf2-frame.c & \ & \cxreffile{dwarf2-frame.c}\\
\ & dwarf2expr.c & \ & \cxreffile{dwarf2expr.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & dwarf2\_build\_frame\_info() & dwarf2-frame.c & \cxreffunc{dwarf2_build_frame_info}{dwarf2-frame.c}\\
\ & dwarf2\_has\_info\_1() & dwarf2read.c & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & dwarf2read.c & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Variable dwarf\_eh\_frame\_section}
\label{var_dwarf_eh_frame_section_dwarf2read.c}

{\stt asection* dwarf\_eh\_frame\_section}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarf2-frame.c & \ & \cxreffile{dwarf2-frame.c}\\
\ & dwarf2expr.c & \ & \cxreffile{dwarf2expr.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & dwarf2\_build\_frame\_info() & dwarf2-frame.c & \cxreffunc{dwarf2_build_frame_info}{dwarf2-frame.c}\\
\ & dwarf2\_has\_info\_1() & dwarf2read.c & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & dwarf2read.c & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Variable dwarf2\_inform\_debugging\_optimized\_code}
\label{var_dwarf2_inform_debugging_optimized_code_dwarf2read.c}

{\stt int dwarf2\_inform\_debugging\_optimized\_code}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & interps.c & \ & \cxreffile{interps.c}\\
\ & main.c & \ & \cxreffile{main.c}\\
\ & objc-exp.c & \ & \cxreffile{objc-exp.c}\\
\ & p-exp.c & \ & \cxreffile{p-exp.c}\\
\ & source.c & \ & \cxreffile{source.c}\\
\cxreftabbreak{cxreftabiii}
\ & top.c & \ & \cxreffile{top.c}\\
Used in:\ & \_initialize\_dwarf2\_read() & dwarf2read.c & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\ & adjust\_prompts\_for\_optimized\_code() & event-top.c & \cxreffunc{adjust_prompts_for_optimized_code}{event-top.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable inlined\_subroutine\_symbols}
\label{var_inlined_subroutine_symbols_dwarf2read.c}

{\stt struct pending* inlined\_subroutine\_symbols}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & fix\_inlined\_subroutine\_symbols() & dwarf2read.c & \cxreffunc{fix_inlined_subroutine_symbols}{dwarf2read.c}\\
\ & process\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{process_full_comp_unit}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Variable repositories}
\label{var_repositories_dwarf2read.c}

{\stt struct database\_info* repositories}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & close\_dwarf\_repositories() & dwarf2read.c & \cxreffunc{close_dwarf_repositories}{dwarf2read.c}\\
\ & find\_open\_repository() & dwarf2read.c & \cxreffunc{find_open_repository}{dwarf2read.c}\\
\ & initialize\_repositories() & dwarf2read.c & \cxreffunc{initialize_repositories}{dwarf2read.c}\\
\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Variable num\_open\_dbs}
\label{var_num_open_dbs_dwarf2read.c}

{\stt int num\_open\_dbs}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & close\_dwarf\_repositories() & dwarf2read.c & \cxreffunc{close_dwarf_repositories}{dwarf2read.c}\\
\ & find\_open\_repository() & dwarf2read.c & \cxreffunc{find_open_repository}{dwarf2read.c}\\
\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Variable db\_stmt1}
\label{var_db_stmt1_dwarf2read.c}

{\stt sqlite3\_stmt* db\_stmt1}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & db\_lookup\_type() & dwarf2read.c & \cxreffunc{db_lookup_type}{dwarf2read.c}\\
\ & finalize\_stmts() & dwarf2read.c & \cxreffunc{finalize_stmts}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Variable db\_stmt2}
\label{var_db_stmt2_dwarf2read.c}

{\stt sqlite3\_stmt* db\_stmt2}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & finalize\_stmts() & dwarf2read.c & \cxreffunc{finalize_stmts}{dwarf2read.c}\\
\ & get\_repository\_name() & dwarf2read.c & \cxreffunc{get_repository_name}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf dwarf2\_objfile\_data\_key}
\label{var_dwarf2_objfile_data_key_dwarf2read.c}

{\stt static const struct objfile\_data* dwarf2\_objfile\_data\_key}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_dwarf2\_read() & \ & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_kext\_psymtab\_to\_symtab() & \ & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_psymtab\_to\_symtab() & \ & \cxreffunc{dwarf2_psymtab_to_symtab}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf2\_per\_objfile}
\label{var_dwarf2_per_objfile_dwarf2read.c}

{\stt static struct dwarf2\_per\_objfile* dwarf2\_per\_objfile}

\smallskip
\begin{cxreftabiii}
Used in:\ & age\_cached\_comp\_units() & \ & \cxreffunc{age_cached_comp_units}{dwarf2read.c}\\
\ & create\_all\_comp\_units() & \ & \cxreffunc{create_all_comp_units}{dwarf2read.c}\\
\ & dwarf2\_build\_psymtabs\_hard() & \ & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & \ & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_find\_containing\_comp\_unit() & \ & \cxreffunc{dwarf2_find_containing_comp_unit}{dwarf2read.c}\\
\ & dwarf2\_get\_pc\_bounds() & \ & \cxreffunc{dwarf2_get_pc_bounds}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_kext\_psymtab\_to\_symtab() & \ & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\ & dwarf2\_psymtab\_to\_symtab() & \ & \cxreffunc{dwarf2_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_read\_abbrevs() & \ & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_symbol\_mark\_computed() & \ & \cxreffunc{dwarf2_symbol_mark_computed}{dwarf2read.c}\\
\ & dwarf\_decode\_line\_header() & \ & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\ & dwarf\_decode\_macros() & \ & \cxreffunc{dwarf_decode_macros}{dwarf2read.c}\\
\ & find\_debug\_info\_for\_pst() & \ & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\ & find\_partial\_die() & \ & \cxreffunc{find_partial_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & free\_cached\_comp\_units() & \ & \cxreffunc{free_cached_comp_units}{dwarf2read.c}\\
\ & free\_one\_cached\_comp\_unit() & \ & \cxreffunc{free_one_cached_comp_unit}{dwarf2read.c}\\
\ & load\_comp\_unit() & \ & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
\ & load\_full\_comp\_unit() & \ & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
\ & partial\_read\_comp\_unit\_head() & \ & \cxreffunc{partial_read_comp_unit_head}{dwarf2read.c}\\
\ & peek\_die\_abbrev() & \ & \cxreffunc{peek_die_abbrev}{dwarf2read.c}\\
\ & process\_queue() & \ & \cxreffunc{process_queue}{dwarf2read.c}\\
\ & read\_full\_die() & \ & \cxreffunc{read_full_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_indirect\_string() & \ & \cxreffunc{read_indirect_string}{dwarf2read.c}\\
\ & read\_partial\_die() & \ & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & \ & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
\ & skip\_one\_die() & \ & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_info\_section}
\label{var_dwarf_info_section_dwarf2read.c}

{\stt static asection* dwarf\_info\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_abbrev\_section}
\label{var_dwarf_abbrev_section_dwarf2read.c}

{\stt static asection* dwarf\_abbrev\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_line\_section}
\label{var_dwarf_line_section_dwarf2read.c}

{\stt static asection* dwarf\_line\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_pubnames\_section}
\label{var_dwarf_pubnames_section_dwarf2read.c}

{\stt static asection* dwarf\_pubnames\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_pubtypes\_section}
\label{var_dwarf_pubtypes_section_dwarf2read.c}

{\stt static asection* dwarf\_pubtypes\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_inlined\_section}
\label{var_dwarf_inlined_section_dwarf2read.c}

{\stt static asection* dwarf\_inlined\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_aranges\_section}
\label{var_dwarf_aranges_section_dwarf2read.c}

{\stt static asection* dwarf\_aranges\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_loc\_section}
\label{var_dwarf_loc_section_dwarf2read.c}

{\stt static asection* dwarf\_loc\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_macinfo\_section}
\label{var_dwarf_macinfo_section_dwarf2read.c}

{\stt static asection* dwarf\_macinfo\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_str\_section}
\label{var_dwarf_str_section_dwarf2read.c}

{\stt static asection* dwarf\_str\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf\_ranges\_section}
\label{var_dwarf_ranges_section_dwarf2read.c}

{\stt static asection* dwarf\_ranges\_section}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_copy\_dwarf\_from\_file() & \ & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & \ & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & dwarf2\_locate\_sections() & \ & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf decode\_locdesc\_common}
\label{var_decode_locdesc_common_dwarf2read.c}

{\stt static char* decode\_locdesc\_common}

\smallskip
\begin{cxreftabiii}
Used in:\ & decode\_locdesc() & \ & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & read\_common\_block() & \ & \cxreffunc{read_common_block}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf isreg}
\label{var_isreg_dwarf2read.c}

{\stt static int isreg}

\smallskip
\begin{cxreftabiii}
Used in:\ & decode\_locdesc() & \ & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf bits\_per\_byte}
\label{var_bits_per_byte_dwarf2read.c}

{\stt static int bits\_per\_byte}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_add\_field() & \ & \cxreffunc{dwarf2_add_field}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf2\_queue}
\label{var_dwarf2_queue_dwarf2read.c}

{\stt static struct dwarf2\_queue\_item* dwarf2\_queue}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_release\_queue() & \ & \cxreffunc{dwarf2_release_queue}{dwarf2read.c}\\
\ & process\_queue() & \ & \cxreffunc{process_queue}{dwarf2read.c}\\
\ & queue\_comp\_unit() & \ & \cxreffunc{queue_comp_unit}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf2\_queue\_tail}
\label{var_dwarf2_queue_tail_dwarf2read.c}

{\stt static struct dwarf2\_queue\_item* dwarf2\_queue\_tail}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf2\_release\_queue() & \ & \cxreffunc{dwarf2_release_queue}{dwarf2read.c}\\
\ & process\_queue() & \ & \cxreffunc{process_queue}{dwarf2read.c}\\
\ & queue\_comp\_unit() & \ & \cxreffunc{queue_comp_unit}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf dwarf2\_max\_cache\_age}
\label{var_dwarf2_max_cache_age_dwarf2read.c}

{\stt static int dwarf2\_max\_cache\_age}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_dwarf2\_read() & \ & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\ & age\_cached\_comp\_units() & \ & \cxreffunc{age_cached_comp_units}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf debug\_debugmap}
\label{var_debug_debugmap_dwarf2read.c}

{\stt static int debug\_debugmap}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_dwarf2\_read() & \ & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\ & convert\_oso\_map\_to\_final\_map() & \ & \cxreffunc{convert_oso_map_to_final_map}{dwarf2read.c}\\
\ & create\_kext\_addr\_map() & \ & \cxreffunc{create_kext_addr_map}{dwarf2read.c}\\
\ & dwarf2\_record\_line() & \ & \cxreffunc{dwarf2_record_line}{dwarf2read.c}\\
\ & translate\_common\_symbol\_debug\_map\_address() & \ & \cxreffunc{translate_common_symbol_debug_map_address}{dwarf2read.c}\\
\ & translate\_debug\_map\_address() & \ & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
\ & translate\_debug\_map\_address\_with\_tuple() & \ & \cxreffunc{translate_debug_map_address_with_tuple}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf byte\_swap\_p}
\label{var_byte_swap_p_dwarf2read.c}

{\stt static int byte\_swap\_p}

\smallskip
\begin{cxreftabiii}
Used in:\ & db\_read\_2\_bytes() & \ & \cxreffunc{db_read_2_bytes}{dwarf2read.c}\\
\ & db\_read\_4\_bytes() & \ & \cxreffunc{db_read_4_bytes}{dwarf2read.c}\\
\ & db\_read\_8\_bytes() & \ & \cxreffunc{db_read_8_bytes}{dwarf2read.c}\\
\ & dwarf2\_build\_psymtabs\_hard() & \ & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf set\_dwarf2\_cmdlist}
\label{var_set_dwarf2_cmdlist_dwarf2read.c}

{\stt static struct cmd\_list\_element* set\_dwarf2\_cmdlist}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_dwarf2\_read() & \ & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\ & set\_dwarf2\_cmd() & \ & \cxreffunc{set_dwarf2_cmd}{dwarf2read.c}\\
\end{cxreftabiii}

\medskip
{\bf show\_dwarf2\_cmdlist}
\label{var_show_dwarf2_cmdlist_dwarf2read.c}

{\stt static struct cmd\_list\_element* show\_dwarf2\_cmdlist}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_dwarf2\_read() & \ & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\ & show\_dwarf2\_cmd() & \ & \cxreffunc{show_dwarf2_cmd}{dwarf2read.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_dwarf2\_read()}
\label{func__initialize_dwarf2_read_dwarf2read.c}

{\stt void \_initialize\_dwarf2\_read ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & register\_objfile\_data() & objfiles.c & \cxreffunc{register_objfile_data}{objfiles.c}\\
\ & \cxreftabiiispan{ add\_prefix\_cmd(), add\_setshow\_boolean\_cmd(), add\_setshow\_zinteger\_cmd()} &\\
Refs Func:\ & set\_dwarf2\_cmd() & dwarf2read.c & \cxreffunc{set_dwarf2_cmd}{dwarf2read.c}\\
\ & show\_debug\_debugmap() & dwarf2read.c & \cxreffunc{show_debug_debugmap}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_dwarf2\_cmd() & dwarf2read.c & \cxreffunc{show_dwarf2_cmd}{dwarf2read.c}\\
\ & show\_dwarf2\_max\_cache\_age() & dwarf2read.c & \cxreffunc{show_dwarf2_max_cache_age}{dwarf2read.c}\\
Refs Var:\ & debug\_debugmap & dwarf2read.c & \cxrefvar{debug_debugmap}{dwarf2read.c}\\
\ & dwarf2\_allow\_inlined\_stepping & dwarf2read.c & \cxrefvar{dwarf2_allow_inlined_stepping}{dwarf2read.c}\\
\ & dwarf2\_debug\_inlined\_stepping & dwarf2read.c & \cxrefvar{dwarf2_debug_inlined_stepping}{dwarf2read.c}\\
\ & dwarf2\_inform\_debugging\_optimized\_code & dwarf2read.c & \cxrefvar{dwarf2_inform_debugging_optimized_code}{dwarf2read.c}\\
\ & dwarf2\_max\_cache\_age & dwarf2read.c & \cxrefvar{dwarf2_max_cache_age}{dwarf2read.c}\\
\ & dwarf2\_objfile\_data\_key & dwarf2read.c & \cxrefvar{dwarf2_objfile_data_key}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & maintenance\_set\_cmdlist & maint.c & \cxrefvar{maintenance_set_cmdlist}{maint.c}\\
\ & maintenance\_show\_cmdlist & maint.c & \cxrefvar{maintenance_show_cmdlist}{maint.c}\\
\ & set\_dwarf2\_cmdlist & dwarf2read.c & \cxrefvar{set_dwarf2_cmdlist}{dwarf2read.c}\\
\ & show\_dwarf2\_cmdlist & dwarf2read.c & \cxrefvar{show_dwarf2_cmdlist}{dwarf2read.c}\\
\ & \cxreftabiiispan{ setdebuglist, setlist, showdebuglist, showlist} &\\
\end{cxreftabiii}


\subsubsection{Global Function close\_dwarf\_repositories()}
\label{func_close_dwarf_repositories_dwarf2read.c}

{\stt int close\_dwarf\_repositories ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& db-access-functions.h & \ & \cxreffile{db-access-functions.h}\\
Calls:\ & decrement\_use\_count() & dwarf2read.c & \cxreffunc{decrement_use_count}{dwarf2read.c}\\
\ & finalize\_stmts() & dwarf2read.c & \cxreffunc{finalize_stmts}{dwarf2read.c}\\
\ & \cxreftabiiispan{ sqlite3\_close()} &\\
Called by:\ & free\_objfile\_internal() & objfiles.c & \cxreffunc{free_objfile_internal}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & \cxreftabiiispan{ obstack\_free()} &\\
Refs Var:\ & num\_open\_dbs & dwarf2read.c & \cxrefvar{num_open_dbs}{dwarf2read.c}\\
\ & repositories & dwarf2read.c & \cxrefvar{repositories}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Global Function dwarf2\_build\_psymtabs()}
\label{func_dwarf2_build_psymtabs_dwarf2read.c}

{\stt void dwarf2\_build\_psymtabs ( struct objfile* objfile, int mainline )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & dwarf2\_copy\_dwarf\_from\_file() & dwarf2read.c & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & init\_psymbol\_list() & symfile.c & \cxreffunc{init_psymbol_list}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & coff\_symfile\_read() & coffread.c & \cxreffunc{coff_symfile_read}{coffread.c}\\
\ & elf\_symfile\_read() & elfread.c & \cxreffunc{elf_symfile_read}{elfread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function dwarf2\_debug\_map\_psymtab\_to\_symtab()}
\label{func_dwarf2_debug_map_psymtab_to_symtab_dwarf2read.c}

{\stt void dwarf2\_debug\_map\_psymtab\_to\_symtab ( struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & clear\_containing\_archive\_cache() & dbxread.c & \cxreffunc{clear_containing_archive_cache}{dbxread.c}\\
\ & close\_bfd\_or\_archive() & dbxread.c & \cxreffunc{close_bfd_or_archive}{dbxread.c}\\
\ & convert\_oso\_map\_to\_final\_map() & dwarf2read.c & \cxreffunc{convert_oso_map_to_final_map}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_copy\_dwarf\_from\_file() & dwarf2read.c & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_has\_info\_1() & dwarf2read.c & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & fputs\_filtered() & utils.c & \cxreffunc{fputs_filtered}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
\ & open\_bfd\_from\_oso() & dbxread.c & \cxreffunc{open_bfd_from_oso}{dbxread.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{process_full_comp_unit}{dwarf2read.c}\\
\ & read\_initial\_length() & dwarf2read.c & \cxreffunc{read_initial_length}{dwarf2read.c}\\
\ & read\_oso\_nlists() & dbxread.c & \cxreffunc{read_oso_nlists}{dbxread.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & wrap\_here() & utils.c & \cxreffunc{wrap_here}{utils.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk(), bfd\_check\_format()} &\\
Called by:\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_kext\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
Used in:\ & read\_dbx\_symtab() & dbxread.c & \cxreffunc{read_dbx_symtab}{dbxread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\end{cxreftabiii}


\subsubsection{Global Function dwarf2\_has\_info()}
\label{func_dwarf2_has_info_dwarf2read.c}

{\stt int dwarf2\_has\_info ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & dwarf2\_has\_info\_1() & dwarf2read.c & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
Called by:\ & coff\_symfile\_read() & coffread.c & \cxreffunc{coff_symfile_read}{coffread.c}\\
\ & elf\_symfile\_read() & elfread.c & \cxreffunc{elf_symfile_read}{elfread.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function dwarf2\_kext\_psymtab\_to\_symtab()}
\label{func_dwarf2_kext_psymtab_to_symtab_dwarf2read.c}

{\stt void dwarf2\_kext\_psymtab\_to\_symtab ( struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & create\_kext\_addr\_map() & dwarf2read.c & \cxreffunc{create_kext_addr_map}{dwarf2read.c}\\
\ & dwarf2\_copy\_dwarf\_from\_file() & dwarf2read.c & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_has\_info\_1() & dwarf2read.c & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_debug\_info\_for\_pst() & dwarf2read.c & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\ & fputs\_filtered() & utils.c & \cxreffunc{fputs_filtered}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & get\_objfile\_data() & objfiles.c & \cxreffunc{get_objfile_data}{objfiles.c}\\
\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{process_full_comp_unit}{dwarf2read.c}\\
\ & read\_initial\_length() & dwarf2read.c & \cxreffunc{read_initial_length}{dwarf2read.c}\\
\ & read\_oso\_nlists() & dbxread.c & \cxreffunc{read_oso_nlists}{dbxread.c}\\
\ & symfile\_bfd\_open() & symfile.c & \cxreffunc{symfile_bfd_open}{symfile.c}\\
\ & wrap\_here() & utils.c & \cxreffunc{wrap_here}{utils.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk(), bfd\_close()} &\\
Used in:\ & replace\_psymbols\_with\_correct\_psymbols() & symfile.c & \cxreffunc{replace_psymbols_with_correct_psymbols}{symfile.c}\\
Refs Var:\ & dwarf2\_objfile\_data\_key & dwarf2read.c & \cxrefvar{dwarf2_objfile_data_key}{dwarf2read.c}\\
\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\end{cxreftabiii}


\subsubsection{Global Function dwarf2\_read\_section()}
\label{func_dwarf2_read_section_dwarf2read.c}

{\stt char* dwarf2\_read\_section ( struct objfile* objfile, bfd* abfd, asection* sectp )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.h & \ & \cxreffile{dwarf2read.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & symfile\_relocate\_debug\_section() & symfile.c & \cxreffunc{symfile_relocate_debug_section}{symfile.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk(), bfd\_bread(), bfd\_seek()} &\\
Called by:\ & dwarf2\_build\_frame\_info() & dwarf2-frame.c & \cxreffunc{dwarf2_build_frame_info}{dwarf2-frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_copy\_dwarf\_from\_file() & dwarf2read.c & \cxreffunc{dwarf2_copy_dwarf_from_file}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Global Function dwarf2\_scan\_inlined\_section\_for\_psymbols()}
\label{func_dwarf2_scan_inlined_section_for_psymbols_dwarf2read.c}

{\stt void dwarf2\_scan\_inlined\_section\_for\_psymbols ( struct partial\_symtab* pst, struct objfile* objfile, enum language psymtab\_language )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & close\_bfd\_or\_archive() & dbxread.c & \cxreffunc{close_bfd_or_archive}{dbxread.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_bit}{gdbarch.c}\\
\ & open\_bfd\_from\_oso() & dbxread.c & \cxreffunc{open_bfd_from_oso}{dbxread.c}\\
\ & perror\_with\_name() & utils.c & \cxreffunc{perror_with_name}{utils.c}\\
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_address() & dwarf2read.c & \cxreffunc{read_address}{dwarf2read.c}\\
\ & read\_initial\_length() & dwarf2read.c & \cxreffunc{read_initial_length}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_offset() & dwarf2read.c & \cxreffunc{read_offset}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & start\_timer() & maint.c & \cxreffunc{start_timer}{maint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ bfd\_check\_format(), bfd\_close(), bfd\_free\_window(), bfd\_get\_section\_contents\_in\_window\_with\_mode(), bfd\_init\_window(), bfd\_sections\_find\_if(), strlen()} &\\
Called by:\ & read\_dbx\_symtab() & dbxread.c & \cxreffunc{read_dbx_symtab}{dbxread.c}\\
Refs Func:\ & find\_debug\_inlined\_section() & dwarf2read.c & \cxreffunc{find_debug_inlined_section}{dwarf2read.c}\\
\ & find\_debug\_str\_section() & dwarf2read.c & \cxreffunc{find_debug_str_section}{dwarf2read.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & maint\_use\_timers & maint.c & \cxrefvar{maint_use_timers}{maint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function dwarf2\_scan\_pubtype\_for\_psymbols()}
\label{func_dwarf2_scan_pubtype_for_psymbols_dwarf2read.c}

{\stt void dwarf2\_scan\_pubtype\_for\_psymbols ( struct partial\_symtab* pst, struct objfile* objfile, enum language psymtab\_language )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & close\_bfd\_or\_archive() & dbxread.c & \cxreffunc{close_bfd_or_archive}{dbxread.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & open\_bfd\_from\_oso() & dbxread.c & \cxreffunc{open_bfd_from_oso}{dbxread.c}\\
\ & perror\_with\_name() & utils.c & \cxreffunc{perror_with_name}{utils.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_initial\_length() & dwarf2read.c & \cxreffunc{read_initial_length}{dwarf2read.c}\\
\ & read\_offset() & dwarf2read.c & \cxreffunc{read_offset}{dwarf2read.c}\\
\ & read\_string() & dwarf2read.c & \cxreffunc{read_string}{dwarf2read.c}\\
\ & start\_timer() & maint.c & \cxreffunc{start_timer}{maint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ bfd\_check\_format(), bfd\_close(), bfd\_free\_window(), bfd\_get\_section\_contents\_in\_window\_with\_mode(), bfd\_init\_window(), bfd\_sections\_find\_if()} &\\
Called by:\ & read\_dbx\_symtab() & dbxread.c & \cxreffunc{read_dbx_symtab}{dbxread.c}\\
Refs Func:\ & find\_pubtypes() & dwarf2read.c & \cxreffunc{find_pubtypes}{dwarf2read.c}\\
Refs Var:\ & maint\_use\_timers & maint.c & \cxrefvar{maint_use_timers}{maint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function find\_debug\_info\_for\_pst()}
\label{func_find_debug_info_for_pst_dwarf2read.c}

{\stt char* find\_debug\_info\_for\_pst ( struct partial\_symtab* pst, int match\_amount )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_read\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & partial\_read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{partial_read_comp_unit_head}{dwarf2read.c}\\
\ & peek\_die\_abbrev() & dwarf2read.c & \cxreffunc{peek_die_abbrev}{dwarf2read.c}\\
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_begin(), strcmp(), strlen()} &\\
Called by:\ & dwarf2\_kext\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
Refs Func:\ & dwarf2\_free\_abbrev\_table() & dwarf2read.c & \cxreffunc{dwarf2_free_abbrev_table}{dwarf2read.c}\\
\ & free\_cached\_comp\_units() & dwarf2read.c & \cxreffunc{free_cached_comp_units}{dwarf2read.c}\\
\ & free\_stack\_comp\_unit() & dwarf2read.c & \cxreffunc{free_stack_comp_unit}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & file\_symbols & buildsym.c & \cxrefvar{file_symbols}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Global Function rb\_tree\_find\_node()}
\label{func_rb_tree_find_node_dwarf2read.c}

{\stt struct rb\_tree\_node* rb\_tree\_find\_node ( struct rb\_tree\_node* root, long long key, int secondary\_key )}

\smallskip
\begin{cxreftabiii}
Prototype:& inlining.h & \ & \cxreffile{inlining.h}\\
Calls:\ & rb\_tree\_find\_node() & dwarf2read.c & \cxreffunc{rb_tree_find_node}{dwarf2read.c}\\
Called by:\ & add\_class\_to\_cache() & objc-lang.c & \cxreffunc{add_class_to_cache}{objc-lang.c}\\
\ & class\_valid\_p() & objc-lang.c & \cxreffunc{class_valid_p}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_real\_class\_in\_cache() & objc-lang.c & \cxreffunc{lookup_real_class_in_cache}{objc-lang.c}\\
\ & lookup\_repository\_type() & dwarf2read.c & \cxreffunc{lookup_repository_type}{dwarf2read.c}\\
\ & rb\_tree\_find\_node() & dwarf2read.c & \cxreffunc{rb_tree_find_node}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Global Function rb\_tree\_find\_node\_all\_keys()}
\label{func_rb_tree_find_node_all_keys_dwarf2read.c}

{\stt struct rb\_tree\_node* rb\_tree\_find\_node\_all\_keys ( struct rb\_tree\_node* root, long long key, int secondary\_key, long long third\_key )}

\smallskip
\begin{cxreftabiii}
Prototype:& inlining.h & \ & \cxreffile{inlining.h}\\
Calls:\ & rb\_tree\_find\_node\_all\_keys() & dwarf2read.c & \cxreffunc{rb_tree_find_node_all_keys}{dwarf2read.c}\\
Called by:\ & lookup\_classname\_in\_cache() & objc-lang.c & \cxreffunc{lookup_classname_in_cache}{objc-lang.c}\\
\ & lookup\_implementation\_in\_cache() & objc-lang.c & \cxreffunc{lookup_implementation_in_cache}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & rb\_tree\_find\_node\_all\_keys() & dwarf2read.c & \cxreffunc{rb_tree_find_node_all_keys}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Global Function rb\_tree\_insert()}
\label{func_rb_tree_insert_dwarf2read.c}

{\stt void rb\_tree\_insert ( struct rb\_tree\_node** root, struct rb\_tree\_node* tree, struct rb\_tree\_node* new\_node )}

\smallskip
\begin{cxreftabiii}
Prototype:& inlining.h & \ & \cxreffile{inlining.h}\\
Calls:\ & left\_rotate() & dwarf2read.c & \cxreffunc{left_rotate}{dwarf2read.c}\\
\ & plain\_tree\_insert() & dwarf2read.c & \cxreffunc{plain_tree_insert}{dwarf2read.c}\\
\ & right\_rotate() & dwarf2read.c & \cxreffunc{right_rotate}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & add\_class\_to\_cache() & objc-lang.c & \cxreffunc{add_class_to_cache}{objc-lang.c}\\
\ & add\_classname\_to\_cache() & objc-lang.c & \cxreffunc{add_classname_to_cache}{objc-lang.c}\\
\ & add\_implementation\_to\_cache() & objc-lang.c & \cxreffunc{add_implementation_to_cache}{objc-lang.c}\\
\ & dwarf2\_add\_to\_list\_of\_inlined\_calls() & dwarf2read.c & \cxreffunc{dwarf2_add_to_list_of_inlined_calls}{dwarf2read.c}\\
\ & inlined\_function\_add\_function\_names() & inlining.c & \cxreffunc{inlined_function_add_function_names}{inlining.c}\\
\ & lookup\_repository\_type() & dwarf2read.c & \cxreffunc{lookup_repository_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Global Function translate\_debug\_map\_address()}
\label{func_translate_debug_map_address_dwarf2read.c}

{\stt int translate\_debug\_map\_address ( struct oso\_to\_final\_addr\_map* map, CORE\_ADDR oso\_addr, CORE\_ADDR* addr, int highpc )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.h & \ & \cxreffile{dwarf2read.h}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & translate\_debug\_map\_address\_with\_tuple() & dwarf2read.c & \cxreffunc{translate_debug_map_address_with_tuple}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ bsearch()} &\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & dwarf2\_const\_value() & dwarf2read.c & \cxreffunc{dwarf2_const_value}{dwarf2read.c}\\
\ & dwarf2\_get\_pc\_bounds() & dwarf2read.c & \cxreffunc{dwarf2_get_pc_bounds}{dwarf2read.c}\\
\ & execute\_stack\_op() & dwarf2expr.c & \cxreffunc{execute_stack_op}{dwarf2expr.c}\\
\ & find\_location\_expression() & dwarf2loc.c & \cxreffunc{find_location_expression}{dwarf2loc.c}\\
\ & loclist\_describe\_location() & dwarf2loc.c & \cxreffunc{loclist_describe_location}{dwarf2loc.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
\ & var\_decode\_location() & dwarf2read.c & \cxreffunc{var_decode_location}{dwarf2read.c}\\
Refs Func:\ & compare\_translation\_tuples\_highpc() & dwarf2read.c & \cxreffunc{compare_translation_tuples_highpc}{dwarf2read.c}\\
\ & compare\_translation\_tuples\_nothighpc() & dwarf2read.c & \cxreffunc{compare_translation_tuples_nothighpc}{dwarf2read.c}\\
Refs Var:\ & debug\_debugmap & dwarf2read.c & \cxrefvar{debug_debugmap}{dwarf2read.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_equiv\_psym()}
\label{func_add_equiv_psym_dwarf2read.c}

{\stt static void add\_equiv\_psym ( struct equiv\_psym\_list** equiv\_psyms, const char* name )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
Called by:\ & scan\_partial\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_symbols}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_file\_name()}
\label{func_add_file_name_dwarf2read.c}

{\stt static void add\_file\_name ( struct line\_header* lh, char* name, unsigned int dir\_index, unsigned int mod\_time, unsigned int length )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
Called by:\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_include\_dir()}
\label{func_add_include_dir_dwarf2read.c}

{\stt static void add\_include\_dir ( struct line\_header* lh, char* include\_dir )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
Called by:\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_partial\_enumeration()}
\label{func_add_partial_enumeration_dwarf2read.c}

{\stt static void add\_partial\_enumeration ( struct partial\_die\_info* enum\_pdi, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_partial\_symbol() & dwarf2read.c & \cxreffunc{add_partial_symbol}{dwarf2read.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & scan\_partial\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_symbols}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_partial\_namespace()}
\label{func_add_partial_namespace_dwarf2read.c}

{\stt static void add\_partial\_namespace ( struct partial\_die\_info* pdi, CORE\_ADDR* lowpc, CORE\_ADDR* highpc, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_partial\_symbol() & dwarf2read.c & \cxreffunc{add_partial_symbol}{dwarf2read.c}\\
\ & scan\_partial\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_symbols}{dwarf2read.c}\\
Called by:\ & scan\_partial\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_symbols}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function add\_partial\_symbol()}
\label{func_add_partial_symbol_dwarf2read.c}

{\stt static void add\_partial\_symbol ( struct partial\_die\_info* pdi, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & cp\_check\_possible\_namespace\_symbols() & cp-namespace.c & \cxreffunc{cp_check_possible_namespace_symbols}{cp-namespace.c}\\
\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & objfile\_add\_special\_psym() & objfiles.c & \cxreffunc{objfile_add_special_psym}{objfiles.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & partial\_die\_full\_name() & dwarf2read.c & \cxreffunc{partial_die_full_name}{dwarf2read.c}\\
\ & pdi\_needs\_namespace() & dwarf2read.c & \cxreffunc{pdi_needs_namespace}{dwarf2read.c}\\
\ & prim\_record\_minimal\_symbol() & minsyms.c & \cxreffunc{prim_record_minimal_symbol}{minsyms.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & add\_partial\_enumeration() & dwarf2read.c & \cxreffunc{add_partial_enumeration}{dwarf2read.c}\\
\ & add\_partial\_namespace() & dwarf2read.c & \cxreffunc{add_partial_namespace}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & scan\_partial\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_symbols}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_to\_cu\_func\_list()}
\label{func_add_to_cu_func_list_dwarf2read.c}

{\stt static void add\_to\_cu\_func\_list ( const char* name, CORE\_ADDR lowpc, CORE\_ADDR highpc, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function age\_cached\_comp\_units()}
\label{func_age_cached_comp_units_dwarf2read.c}

{\stt static void age\_cached\_comp\_units ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_clear\_marks() & dwarf2read.c & \cxreffunc{dwarf2_clear_marks}{dwarf2read.c}\\
\ & dwarf2\_mark() & dwarf2read.c & \cxreffunc{dwarf2_mark}{dwarf2read.c}\\
\ & free\_one\_comp\_unit() & dwarf2read.c & \cxreffunc{free_one_comp_unit}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & free\_stack\_comp\_unit() & dwarf2read.c & \cxreffunc{free_stack_comp_unit}{dwarf2read.c}\\
\ & psymtab\_to\_symtab\_1() & dwarf2read.c & \cxreffunc{psymtab_to_symtab_1}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_max\_cache\_age & dwarf2read.c & \cxrefvar{dwarf2_max_cache_age}{dwarf2read.c}\\
\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function attr\_form\_is\_block()}
\label{func_attr_form_is_block_dwarf2read.c}

{\stt static int attr\_form\_is\_block ( struct attribute* attr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & dwarf2\_add\_member\_fn() & dwarf2read.c & \cxreffunc{dwarf2_add_member_fn}{dwarf2read.c}\\
\ & dwarf2\_symbol\_mark\_computed() & dwarf2read.c & \cxreffunc{dwarf2_symbol_mark_computed}{dwarf2read.c}\\
\ & read\_common\_block() & dwarf2read.c & \cxreffunc{read_common_block}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\ & var\_decode\_location() & dwarf2read.c & \cxreffunc{var_decode_location}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function build\_dummy\_cu()}
\label{func_build_dummy_cu_dwarf2read.c}

{\stt static struct dwarf2\_cu* build\_dummy\_cu ( struct objfile* old\_objfile, struct dwarf2\_cu* old\_cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_\_inline\_strcpy\_chk(), \_obstack\_begin(), strlen(), xstrdup()} &\\
Called by:\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Local Function build\_dummy\_objfile()}
\label{func_build_dummy_objfile_dwarf2read.c}

{\stt static struct objfile* build\_dummy\_objfile ( struct objfile* old\_objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & get\_objfile\_registry\_num\_registrations() & objfiles.c & \cxreffunc{get_objfile_registry_num_registrations}{objfiles.c}\\
\ & xcalloc() & utils.c & \cxreffunc{xcalloc}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_begin()} &\\
Called by:\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Local Function check\_cu\_functions()}
\label{func_check_cu_functions_dwarf2read.c}

{\stt static CORE\_ADDR check\_cu\_functions ( CORE\_ADDR address, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & dwarf2\_record\_line() & dwarf2read.c & \cxreffunc{dwarf2_record_line}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function check\_inlined\_function\_calls()}
\label{func_check_inlined_function_calls_dwarf2read.c}

{\stt static void check\_inlined\_function\_calls ( struct subfile* subfile, int file\_index, int line, CORE\_ADDR address, struct line\_header* lh, struct dwarf2\_cu* cu, char* comp\_dir )}

\smallskip
\begin{cxreftabiii}
Calls:\ & dwarf2\_start\_subfile() & dwarf2read.c & \cxreffunc{dwarf2_start_subfile}{dwarf2read.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & inlined\_function\_add\_function\_names() & inlining.c & \cxreffunc{inlined_function_add_function_names}{inlining.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & rb\_tree\_find\_and\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_find_and_remove_node}{dwarf2read.c}\\
\ & record\_line() & buildsym.c & \cxreffunc{record_line}{buildsym.c}\\
\ & \cxreftabiiispan{ lbasename(), strcmp()} &\\
Called by:\ & dwarf2\_record\_line() & dwarf2read.c & \cxreffunc{dwarf2_record_line}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_debug\_inlined\_stepping & dwarf2read.c & \cxrefvar{dwarf2_debug_inlined_stepping}{dwarf2read.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & subfiles & buildsym.c & \cxrefvar{subfiles}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_map\_entries\_final\_addr\_index()}
\label{func_compare_map_entries_final_addr_index_dwarf2read.c}

{\stt static int compare\_map\_entries\_final\_addr\_index ( void* thunk, const void* a, const void* b )}

\smallskip
\begin{cxreftabiii}
Used in:\ & convert\_oso\_map\_to\_final\_map() & dwarf2read.c & \cxreffunc{convert_oso_map_to_final_map}{dwarf2read.c}\\
\ & create\_kext\_addr\_map() & dwarf2read.c & \cxreffunc{create_kext_addr_map}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_map\_entries\_name()}
\label{func_compare_map_entries_name_dwarf2read.c}

{\stt static int compare\_map\_entries\_name ( const void* a, const void* b )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ strcmp()} &\\
Used in:\ & convert\_oso\_map\_to\_final\_map() & dwarf2read.c & \cxreffunc{convert_oso_map_to_final_map}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_map\_entries\_oso\_addr()}
\label{func_compare_map_entries_oso_addr_dwarf2read.c}

{\stt static int compare\_map\_entries\_oso\_addr ( const void* a, const void* b )}

\smallskip
\begin{cxreftabiii}
Used in:\ & convert\_oso\_map\_to\_final\_map() & dwarf2read.c & \cxreffunc{convert_oso_map_to_final_map}{dwarf2read.c}\\
\ & create\_kext\_addr\_map() & dwarf2read.c & \cxreffunc{create_kext_addr_map}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_translation\_final\_addr()}
\label{func_compare_translation_final_addr_dwarf2read.c}

{\stt static int compare\_translation\_final\_addr ( const void* key, const void* arrmem )}

\smallskip
\begin{cxreftabiii}
Calls:\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Used in:\ & translate\_debug\_map\_address\_with\_tuple() & dwarf2read.c & \cxreffunc{translate_debug_map_address_with_tuple}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_translation\_tuples\_highpc()}
\label{func_compare_translation_tuples_highpc_dwarf2read.c}

{\stt static int compare\_translation\_tuples\_highpc ( const void* key, const void* arrmem )}

\smallskip
\begin{cxreftabiii}
Used in:\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_translation\_tuples\_inclusive()}
\label{func_compare_translation_tuples_inclusive_dwarf2read.c}

{\stt static int compare\_translation\_tuples\_inclusive ( const void* key, const void* arrmem )}

\smallskip
\begin{cxreftabiii}
Called by:\ & dwarf2\_record\_line() & dwarf2read.c & \cxreffunc{dwarf2_record_line}{dwarf2read.c}\\
Used in:\ & dwarf2\_record\_line() & dwarf2read.c & \cxreffunc{dwarf2_record_line}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_translation\_tuples\_nothighpc()}
\label{func_compare_translation_tuples_nothighpc_dwarf2read.c}

{\stt static int compare\_translation\_tuples\_nothighpc ( const void* key, const void* arrmem )}

\smallskip
\begin{cxreftabiii}
Used in:\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function consume\_improper\_spaces()}
\label{func_consume_improper_spaces_dwarf2read.c}

{\stt static const char* consume\_improper\_spaces ( const char* p, const char* body )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & parse\_macro\_definition() & dwarf2read.c & \cxreffunc{parse_macro_definition}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function convert\_oso\_map\_to\_final\_map()}
\label{func_convert_oso_map_to_final_map_dwarf2read.c}

{\stt static struct oso\_to\_final\_addr\_map* convert\_oso\_map\_to\_final\_map ( struct nlist\_rec* nlists, int oso\_nlists\_count, char** oso\_common\_symnames, int oso\_common\_symnames\_count, struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\ & lookup\_minimal\_symbol\_by\_pc\_section\_from\_objfile() & minsyms.c & \cxreffunc{lookup_minimal_symbol_by_pc_section_from_objfile}{minsyms.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_partial\_symbol() & symtab.c & \cxreffunc{lookup_partial_symbol}{symtab.c}\\
\ & objfile\_data\_section\_offset() & objfiles.c & \cxreffunc{objfile_data_section_offset}{objfiles.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & paddr() & utils.c & \cxreffunc{paddr}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ cplus\_demangle(), qsort(), qsort\_r()} &\\
Called by:\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
Refs Func:\ & compare\_map\_entries\_final\_addr\_index() & dwarf2read.c & \cxreffunc{compare_map_entries_final_addr_index}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & compare\_map\_entries\_name() & dwarf2read.c & \cxreffunc{compare_map_entries_name}{dwarf2read.c}\\
\ & compare\_map\_entries\_oso\_addr() & dwarf2read.c & \cxreffunc{compare_map_entries_oso_addr}{dwarf2read.c}\\
Refs Var:\ & debug\_debugmap & dwarf2read.c & \cxrefvar{debug_debugmap}{dwarf2read.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function copy\_string()}
\label{func_copy_string_dwarf2read.c}

{\stt static char* copy\_string ( const char* buf, int len )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & parse\_macro\_definition() & dwarf2read.c & \cxreffunc{parse_macro_definition}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function create\_all\_comp\_units()}
\label{func_create_all_comp_units_dwarf2read.c}

{\stt static void create\_all\_comp\_units ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & read\_initial\_length() & dwarf2read.c & \cxreffunc{read_initial_length}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_\_inline\_memset\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function create\_kext\_addr\_map()}
\label{func_create_kext_addr_map_dwarf2read.c}

{\stt static struct oso\_to\_final\_addr\_map* create\_kext\_addr\_map ( struct nlist\_rec* nlists, int oso\_nlists\_count, char** oso\_common\_symnames, int oso\_common\_symnames\_count, struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\ & lookup\_minimal\_symbol\_by\_pc\_section\_from\_objfile() & minsyms.c & \cxreffunc{lookup_minimal_symbol_by_pc_section_from_objfile}{minsyms.c}\\
\cxreftabbreak{cxreftabiii}
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ qsort(), qsort\_r(), strcmp(), xstrdup()} &\\
Called by:\ & dwarf2\_kext\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
Refs Func:\ & compare\_map\_entries\_final\_addr\_index() & dwarf2read.c & \cxreffunc{compare_map_entries_final_addr_index}{dwarf2read.c}\\
\ & compare\_map\_entries\_oso\_addr() & dwarf2read.c & \cxreffunc{compare_map_entries_oso_addr}{dwarf2read.c}\\
Refs Var:\ & debug\_debugmap & dwarf2read.c & \cxrefvar{debug_debugmap}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_error()}
\label{func_db_error_dwarf2read.c}

{\stt static void db\_error ( const char* function\_name, const char* db\_action\_description, sqlite3* db )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & finalize\_stmts() & dwarf2read.c & \cxreffunc{finalize_stmts}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), sqlite3\_close(), sqlite3\_errmsg(), strlen()} &\\
Called by:\ & db\_lookup\_type() & dwarf2read.c & \cxreffunc{db_lookup_type}{dwarf2read.c}\\
\ & finalize\_stmts() & dwarf2read.c & \cxreffunc{finalize_stmts}{dwarf2read.c}\\
\ & get\_repository\_name() & dwarf2read.c & \cxreffunc{get_repository_name}{dwarf2read.c}\\
\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
\ & read\_in\_db\_abbrev\_table() & dwarf2read.c & \cxreffunc{read_in_db_abbrev_table}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_lookup\_type()}
\label{func_db_lookup_type_dwarf2read.c}

{\stt static struct die\_info* db\_lookup\_type ( int type\_id, sqlite3* db, struct abbrev\_info* abbrev\_table )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & db\_error() & dwarf2read.c & \cxreffunc{db_error}{dwarf2read.c}\\
\ & fill\_in\_die\_info() & dwarf2read.c & \cxreffunc{fill_in_die_info}{dwarf2read.c}\\
\ & get\_uleb128() & dwarf2read.c & \cxreffunc{get_uleb128}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), sqlite3\_bind\_int(), sqlite3\_column\_blob(), sqlite3\_column\_bytes(), sqlite3\_prepare\_v2(), sqlite3\_step(), strlen()} &\\
Called by:\ & fill\_in\_die\_info() & dwarf2read.c & \cxreffunc{fill_in_die_info}{dwarf2read.c}\\
\ & lookup\_repository\_type() & dwarf2read.c & \cxreffunc{lookup_repository_type}{dwarf2read.c}\\
Refs Var:\ & db\_stmt1 & dwarf2read.c & \cxrefvar{db_stmt1}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_read\_1\_byte()}
\label{func_db_read_1_byte_dwarf2read.c}

{\stt static uint8\_t db\_read\_1\_byte ( uint8\_t* info\_ptr )}

\smallskip
\begin{cxreftabiii}
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_read\_2\_bytes()}
\label{func_db_read_2_bytes_dwarf2read.c}

{\stt static uint16\_t db\_read\_2\_bytes ( uint8\_t* info\_ptr )}

\smallskip
\begin{cxreftabiii}
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
Refs Var:\ & byte\_swap\_p & dwarf2read.c & \cxrefvar{byte_swap_p}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_read\_4\_bytes()}
\label{func_db_read_4_bytes_dwarf2read.c}

{\stt static uint32\_t db\_read\_4\_bytes ( uint8\_t* info\_ptr )}

\smallskip
\begin{cxreftabiii}
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
Refs Var:\ & byte\_swap\_p & dwarf2read.c & \cxrefvar{byte_swap_p}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_read\_8\_bytes()}
\label{func_db_read_8_bytes_dwarf2read.c}

{\stt static uint64\_t db\_read\_8\_bytes ( uint8\_t* info\_ptr )}

\smallskip
\begin{cxreftabiii}
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
Refs Var:\ & byte\_swap\_p & dwarf2read.c & \cxrefvar{byte_swap_p}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_read\_attribute\_value()}
\label{func_db_read_attribute_value_dwarf2read.c}

{\stt static uint8\_t* db\_read\_attribute\_value ( struct attribute* attr, unsigned form, uint8\_t** info\_ptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & db\_read\_1\_byte() & dwarf2read.c & \cxreffunc{db_read_1_byte}{dwarf2read.c}\\
\ & db\_read\_2\_bytes() & dwarf2read.c & \cxreffunc{db_read_2_bytes}{dwarf2read.c}\\
\ & db\_read\_4\_bytes() & dwarf2read.c & \cxreffunc{db_read_4_bytes}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & db\_read\_8\_bytes() & dwarf2read.c & \cxreffunc{db_read_8_bytes}{dwarf2read.c}\\
\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
\ & db\_read\_n\_bytes() & dwarf2read.c & \cxreffunc{db_read_n_bytes}{dwarf2read.c}\\
\ & db\_read\_signed\_leb128() & dwarf2read.c & \cxreffunc{db_read_signed_leb128}{dwarf2read.c}\\
\ & db\_read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{db_read_unsigned_leb128}{dwarf2read.c}\\
\ & dwarf\_form\_name() & dwarf2read.c & \cxreffunc{dwarf_form_name}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
\ & fill\_in\_die\_info() & dwarf2read.c & \cxreffunc{fill_in_die_info}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_read\_n\_bytes()}
\label{func_db_read_n_bytes_dwarf2read.c}

{\stt static uint8\_t* db\_read\_n\_bytes ( uint8\_t* info\_ptr, unsigned int num\_bytes )}

\smallskip
\begin{cxreftabiii}
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_read\_signed\_leb128()}
\label{func_db_read_signed_leb128_dwarf2read.c}

{\stt static int32\_t db\_read\_signed\_leb128 ( uint8\_t* info\_ptr, unsigned int* bytes\_read )}

\smallskip
\begin{cxreftabiii}
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function db\_read\_unsigned\_leb128()}
\label{func_db_read_unsigned_leb128_dwarf2read.c}

{\stt static uint32\_t db\_read\_unsigned\_leb128 ( uint8\_t* info\_ptr, unsigned int* bytes\_read )}

\smallskip
\begin{cxreftabiii}
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_locdesc()}
\label{func_decode_locdesc_dwarf2read.c}

{\stt static CORE\_ADDR decode\_locdesc ( struct dwarf\_block* blk, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_complex\_location\_expr\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_complex_location_expr_complaint}{dwarf2read.c}\\
\ & dwarf\_stack\_op\_name() & dwarf2read.c & \cxreffunc{dwarf_stack_op_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_1\_signed\_byte() & dwarf2read.c & \cxreffunc{read_1_signed_byte}{dwarf2read.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_2\_signed\_bytes() & dwarf2read.c & \cxreffunc{read_2_signed_bytes}{dwarf2read.c}\\
\ & read\_4\_bytes() & dwarf2read.c & \cxreffunc{read_4_bytes}{dwarf2read.c}\\
\ & read\_4\_signed\_bytes() & dwarf2read.c & \cxreffunc{read_4_signed_bytes}{dwarf2read.c}\\
\ & read\_address() & dwarf2read.c & \cxreffunc{read_address}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_signed\_leb128() & dwarf2read.c & \cxreffunc{read_signed_leb128}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & translate\_common\_symbol\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_common_symbol_debug_map_address}{dwarf2read.c}\\
\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
Called by:\ & add\_partial\_symbol() & dwarf2read.c & \cxreffunc{add_partial_symbol}{dwarf2read.c}\\
\ & dwarf2\_add\_field() & dwarf2read.c & \cxreffunc{dwarf2_add_field}{dwarf2read.c}\\
\ & dwarf2\_add\_member\_fn() & dwarf2read.c & \cxreffunc{dwarf2_add_member_fn}{dwarf2read.c}\\
\ & read\_common\_block() & dwarf2read.c & \cxreffunc{read_common_block}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & decode\_locdesc\_common & dwarf2read.c & \cxrefvar{decode_locdesc_common}{dwarf2read.c}\\
\ & isreg & dwarf2read.c & \cxrefvar{isreg}{dwarf2read.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decrement\_use\_count()}
\label{func_decrement_use_count_dwarf2read.c}

{\stt static void decrement\_use\_count ( struct database\_info* repository, struct objfile* ofile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & close\_dwarf\_repositories() & dwarf2read.c & \cxreffunc{close_dwarf_repositories}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function determine\_class\_name()}
\label{func_determine_class_name_dwarf2read.c}

{\stt static char* determine\_class\_name ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & determine\_prefix() & dwarf2read.c & \cxreffunc{determine_prefix}{dwarf2read.c}\\
\ & die\_specification() & dwarf2read.c & \cxreffunc{die_specification}{dwarf2read.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_linkage\_name() & dwarf2read.c & \cxreffunc{dwarf2_linkage_name}{dwarf2read.c}\\
\ & dwarf2\_name() & dwarf2read.c & \cxreffunc{dwarf2_name}{dwarf2read.c}\\
\ & language\_class\_name\_from\_physname() & language.c & \cxreffunc{language_class_name_from_physname}{language.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
\ & typename\_concat() & dwarf2read.c & \cxreffunc{typename_concat}{dwarf2read.c}\\
Called by:\ & determine\_prefix() & dwarf2read.c & \cxreffunc{determine_prefix}{dwarf2read.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\ & processing\_has\_namespace\_info & cp-namespace.c & \cxrefvar{processing_has_namespace_info}{cp-namespace.c}\\
\end{cxreftabiii}


\subsubsection{Local Function determine\_prefix()}
\label{func_determine_prefix_dwarf2read.c}

{\stt static char* determine\_prefix ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & determine\_class\_name() & dwarf2read.c & \cxreffunc{determine_class_name}{dwarf2read.c}\\
\ & determine\_prefix() & dwarf2read.c & \cxreffunc{determine_prefix}{dwarf2read.c}\\
\ & namespace\_name() & dwarf2read.c & \cxreffunc{namespace_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & typename\_concat() & dwarf2read.c & \cxreffunc{typename_concat}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & determine\_class\_name() & dwarf2read.c & \cxreffunc{determine_class_name}{dwarf2read.c}\\
\ & determine\_prefix() & dwarf2read.c & \cxreffunc{determine_prefix}{dwarf2read.c}\\
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
Refs Var:\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\end{cxreftabiii}


\subsubsection{Local Function die\_containing\_type()}
\label{func_die_containing_type_dwarf2read.c}

{\stt static struct type* die\_containing\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dump\_die() & dwarf2read.c & \cxreffunc{dump_die}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
\ & tag\_type\_to\_type() & dwarf2read.c & \cxreffunc{tag_type_to_type}{dwarf2read.c}\\
Called by:\ & dwarf2\_add\_member\_fn() & dwarf2read.c & \cxreffunc{dwarf2_add_member_fn}{dwarf2read.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\ & read\_tag\_ptr\_to\_member\_type() & dwarf2read.c & \cxreffunc{read_tag_ptr_to_member_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function die\_is\_declaration()}
\label{func_die_is_declaration_dwarf2read.c}

{\stt static int die\_is\_declaration ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_flag\_true\_p() & dwarf2read.c & \cxreffunc{dwarf2_flag_true_p}{dwarf2read.c}\\
Called by:\ & dwarf2\_add\_field() & dwarf2read.c & \cxreffunc{dwarf2_add_field}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_structure\_scope() & dwarf2read.c & \cxreffunc{process_structure_scope}{dwarf2read.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function die\_specification()}
\label{func_die_specification_dwarf2read.c}

{\stt static struct die\_info* die\_specification ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
Called by:\ & determine\_class\_name() & dwarf2read.c & \cxreffunc{determine_class_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function die\_type()}
\label{func_die_type_dwarf2read.c}

{\stt static struct type* die\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dump\_die() & dwarf2read.c & \cxreffunc{dump_die}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_fundamental\_type() & dwarf2read.c & \cxreffunc{dwarf2_fundamental_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & follow\_db\_ref() & dwarf2read.c & \cxreffunc{follow_db_ref}{dwarf2read.c}\\
\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
\ & tag\_type\_to\_type() & dwarf2read.c & \cxreffunc{tag_type_to_type}{dwarf2read.c}\\
Called by:\ & dwarf2\_add\_field() & dwarf2read.c & \cxreffunc{dwarf2_add_field}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\ & read\_set\_type() & dwarf2read.c & \cxreffunc{read_set_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_subrange\_type() & dwarf2read.c & \cxreffunc{read_subrange_type}{dwarf2read.c}\\
\ & read\_subroutine\_type() & dwarf2read.c & \cxreffunc{read_subroutine_type}{dwarf2read.c}\\
\ & read\_tag\_const\_type() & dwarf2read.c & \cxreffunc{read_tag_const_type}{dwarf2read.c}\\
\ & read\_tag\_pointer\_type() & dwarf2read.c & \cxreffunc{read_tag_pointer_type}{dwarf2read.c}\\
\ & read\_tag\_ptr\_to\_member\_type() & dwarf2read.c & \cxreffunc{read_tag_ptr_to_member_type}{dwarf2read.c}\\
\ & read\_tag\_reference\_type() & dwarf2read.c & \cxreffunc{read_tag_reference_type}{dwarf2read.c}\\
\ & read\_tag\_restrict\_type() & dwarf2read.c & \cxreffunc{read_tag_restrict_type}{dwarf2read.c}\\
\ & read\_tag\_volatile\_type() & dwarf2read.c & \cxreffunc{read_tag_volatile_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_typedef() & dwarf2read.c & \cxreffunc{read_typedef}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dummy\_obstack\_deallocate()}
\label{func_dummy_obstack_deallocate_dwarf2read.c}

{\stt static void dummy\_obstack\_deallocate ( void* object, void* data )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & dwarf2\_add\_dependence() & dwarf2read.c & \cxreffunc{dwarf2_add_dependence}{dwarf2read.c}\\
\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dump\_die()}
\label{func_dump_die_dwarf2read.c}

{\stt static void dump\_die ( struct die\_info* die )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & deprecated\_print\_address\_numeric() & printcmd.c & \cxreffunc{deprecated_print_address_numeric}{printcmd.c}\\
\ & dwarf\_attr\_name() & dwarf2read.c & \cxreffunc{dwarf_attr_name}{dwarf2read.c}\\
\ & dwarf\_bool\_name() & dwarf2read.c & \cxreffunc{dwarf_bool_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_form\_name() & dwarf2read.c & \cxreffunc{dwarf_form_name}{dwarf2read.c}\\
\ & dwarf\_tag\_name() & dwarf2read.c & \cxreffunc{dwarf_tag_name}{dwarf2read.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
Called by:\ & die\_containing\_type() & dwarf2read.c & \cxreffunc{die_containing_type}{dwarf2read.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dump\_die\_list() & dwarf2read.c & \cxreffunc{dump_die_list}{dwarf2read.c}\\
\ & tag\_type\_to\_type() & dwarf2read.c & \cxreffunc{tag_type_to_type}{dwarf2read.c}\\
Refs Var:\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dump\_die\_list()}
\label{func_dump_die_list_dwarf2read.c}

{\stt static void dump\_die\_list ( struct die\_info* die )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dump\_die() & dwarf2read.c & \cxreffunc{dump_die}{dwarf2read.c}\\
\ & dump\_die\_list() & dwarf2read.c & \cxreffunc{dump_die_list}{dwarf2read.c}\\
Called by:\ & dump\_die\_list() & dwarf2read.c & \cxreffunc{dump_die_list}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_add\_dependence()}
\label{func_dwarf2_add_dependence_dwarf2read.c}

{\stt static void dwarf2\_add\_dependence ( struct dwarf2\_cu* cu, struct dwarf2\_per\_cu\_data* ref\_per\_cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & \cxreftabiiispan{ htab\_create\_alloc\_ex(), htab\_find\_slot()} &\\
Called by:\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
Refs Func:\ & dummy\_obstack\_deallocate() & dwarf2read.c & \cxreffunc{dummy_obstack_deallocate}{dwarf2read.c}\\
\ & hashtab\_obstack\_allocate() & dwarf2read.c & \cxreffunc{hashtab_obstack_allocate}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & \cxreftabiiispan{ htab\_eq\_pointer, htab\_hash\_pointer} &\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_add\_field()}
\label{func_dwarf2_add_field_dwarf2read.c}

{\stt static void dwarf2\_add\_field ( struct field\_info* fip, struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & die\_is\_declaration() & dwarf2read.c & \cxreffunc{die_is_declaration}{dwarf2read.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_linkage\_name() & dwarf2read.c & \cxreffunc{dwarf2_linkage_name}{dwarf2read.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & type\_name\_no\_tag() & gdbtypes.c & \cxreffunc{type_name_no_tag}{gdbtypes.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & bits\_per\_byte & dwarf2read.c & \cxrefvar{bits_per_byte}{dwarf2read.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_add\_member\_fn()}
\label{func_dwarf2_add_member_fn_dwarf2read.c}

{\stt static void dwarf2\_add\_member\_fn ( struct field\_info* fip, struct die\_info* die, struct type* type, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & attr\_form\_is\_block() & dwarf2read.c & \cxreffunc{attr_form_is_block}{dwarf2read.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & die\_containing\_type() & dwarf2read.c & \cxreffunc{die_containing_type}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_complex\_location\_expr\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_complex_location_expr_complaint}{dwarf2read.c}\\
\ & dwarf2\_invalid\_attrib\_class\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_invalid_attrib_class_complaint}{dwarf2read.c}\\
\ & dwarf2\_linkage\_name() & dwarf2read.c & \cxreffunc{dwarf2_linkage_name}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & smash\_to\_method\_type() & gdbtypes.c & \cxreffunc{smash_to_method_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), strcmp()} &\\
Called by:\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
Refs Func:\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_add\_to\_list\_of\_inlined\_calls()}
\label{func_dwarf2_add_to_list_of_inlined_calls_dwarf2read.c}

{\stt static void dwarf2\_add\_to\_list\_of\_inlined\_calls ( struct objfile* objfile, struct attribute* file\_attr, struct attribute* line\_attr, struct attribute* column\_attr, CORE\_ADDR lowpc, CORE\_ADDR highpc, struct address\_range\_list* ranges, char* name, char* parent\_name, struct attribute* decl\_file, struct attribute* decl\_line, struct symbol* func\_sym )}

\smallskip
\begin{cxreftabiii}
Calls:\ & rb\_tree\_insert() & dwarf2read.c & \cxreffunc{rb_tree_insert}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_attach\_fields\_to\_type()}
\label{func_dwarf2_attach_fields_to_type_dwarf2read.c}

{\stt static void dwarf2\_attach\_fields\_to\_type ( struct field\_info* fip, struct type* type, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & allocate\_cplus\_struct\_type() & gdbtypes.c & \cxreffunc{allocate_cplus_struct_type}{gdbtypes.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_attach\_fn\_fields\_to\_type()}
\label{func_dwarf2_attach_fn_fields_to_type_dwarf2read.c}

{\stt static void dwarf2\_attach\_fn\_fields\_to\_type ( struct field\_info* fip, struct type* type, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & allocate\_cplus\_struct\_type() & gdbtypes.c & \cxreffunc{allocate_cplus_struct_type}{gdbtypes.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_attr()}
\label{func_dwarf2_attr_dwarf2read.c}

{\stt static struct attribute* dwarf2\_attr ( struct die\_info* die, unsigned int name, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & follow\_db\_ref() & dwarf2read.c & \cxreffunc{follow_db_ref}{dwarf2read.c}\\
\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_repository\_name() & dwarf2read.c & \cxreffunc{get_repository_name}{dwarf2read.c}\\
Called by:\ & die\_containing\_type() & dwarf2read.c & \cxreffunc{die_containing_type}{dwarf2read.c}\\
\ & die\_is\_declaration() & dwarf2read.c & \cxreffunc{die_is_declaration}{dwarf2read.c}\\
\ & die\_specification() & dwarf2read.c & \cxreffunc{die_specification}{dwarf2read.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf2\_add\_field() & dwarf2read.c & \cxreffunc{dwarf2_add_field}{dwarf2read.c}\\
\ & dwarf2\_add\_member\_fn() & dwarf2read.c & \cxreffunc{dwarf2_add_member_fn}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_extension() & dwarf2read.c & \cxreffunc{dwarf2_extension}{dwarf2read.c}\\
\ & dwarf2\_flag\_true\_p() & dwarf2read.c & \cxreffunc{dwarf2_flag_true_p}{dwarf2read.c}\\
\ & dwarf2\_get\_pc\_bounds() & dwarf2read.c & \cxreffunc{dwarf2_get_pc_bounds}{dwarf2read.c}\\
\ & dwarf2\_linkage\_name() & dwarf2read.c & \cxreffunc{dwarf2_linkage_name}{dwarf2read.c}\\
\ & dwarf2\_name() & dwarf2read.c & \cxreffunc{dwarf2_name}{dwarf2read.c}\\
\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & process\_enumeration\_scope() & dwarf2read.c & \cxreffunc{process_enumeration_scope}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{process_full_comp_unit}{dwarf2read.c}\\
\ & process\_structure\_scope() & dwarf2read.c & \cxreffunc{process_structure_scope}{dwarf2read.c}\\
\ & read\_array\_order() & dwarf2read.c & \cxreffunc{read_array_order}{dwarf2read.c}\\
\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\ & read\_base\_type() & dwarf2read.c & \cxreffunc{read_base_type}{dwarf2read.c}\\
\ & read\_common\_block() & dwarf2read.c & \cxreffunc{read_common_block}{dwarf2read.c}\\
\ & read\_enumeration\_type() & dwarf2read.c & \cxreffunc{read_enumeration_type}{dwarf2read.c}\\
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\ & read\_subrange\_type() & dwarf2read.c & \cxreffunc{read_subrange_type}{dwarf2read.c}\\
\ & read\_subroutine\_type() & dwarf2read.c & \cxreffunc{read_subroutine_type}{dwarf2read.c}\\
\ & read\_tag\_pointer\_type() & dwarf2read.c & \cxreffunc{read_tag_pointer_type}{dwarf2read.c}\\
\ & read\_tag\_reference\_type() & dwarf2read.c & \cxreffunc{read_tag_reference_type}{dwarf2read.c}\\
\ & read\_tag\_string\_type() & dwarf2read.c & \cxreffunc{read_tag_string_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_tag\_unspecified\_type() & dwarf2read.c & \cxreffunc{read_tag_unspecified_type}{dwarf2read.c}\\
\ & read\_typedef() & dwarf2read.c & \cxreffunc{read_typedef}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_build\_include\_psymtabs()}
\label{func_dwarf2_build_include_psymtabs_dwarf2read.c}

{\stt static void dwarf2\_build\_include\_psymtabs ( struct dwarf2\_cu* cu, struct partial\_die\_info* pdi, struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\ & free\_line\_header() & dwarf2read.c & \cxreffunc{free_line_header}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_build\_psymtabs\_hard()}
\label{func_dwarf2_build_psymtabs_hard_dwarf2read.c}

{\stt static void dwarf2\_build\_psymtabs\_hard ( struct objfile* objfile, int mainline )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & create\_all\_comp\_units() & dwarf2read.c & \cxreffunc{create_all_comp_units}{dwarf2read.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_build\_include\_psymtabs() & dwarf2read.c & \cxreffunc{dwarf2_build_include_psymtabs}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_find\_comp\_unit() & dwarf2read.c & \cxreffunc{dwarf2_find_comp_unit}{dwarf2read.c}\\
\ & dwarf2\_read\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\ & dwarf2\_read\_repository\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_repository_abbrevs}{dwarf2read.c}\\
\ & free\_named\_symtabs() & symfile.c & \cxreffunc{free_named_symtabs}{symfile.c}\\
\ & free\_one\_cached\_comp\_unit() & dwarf2read.c & \cxreffunc{free_one_cached_comp_unit}{dwarf2read.c}\\
\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
\ & partial\_read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{partial_read_comp_unit_head}{dwarf2read.c}\\
\ & peek\_die\_abbrev() & dwarf2read.c & \cxreffunc{peek_die_abbrev}{dwarf2read.c}\\
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
\ & scan\_partial\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_symbols}{dwarf2read.c}\\
\ & set\_cu\_language() & dwarf2read.c & \cxreffunc{set_cu_language}{dwarf2read.c}\\
\ & set\_repository\_cu\_language() & dwarf2read.c & \cxreffunc{set_repository_cu_language}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & sort\_objfile\_thumb\_psyms() & objfiles.c & \cxreffunc{sort_objfile_thumb_psyms}{objfiles.c}\\
\ & sort\_pst\_symbols() & symfile.c & \cxreffunc{sort_pst_symbols}{symfile.c}\\
\ & start\_psymtab\_common() & symfile.c & \cxreffunc{start_psymtab_common}{symfile.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_begin(), strlen()} &\\
Called by:\ & dwarf2\_build\_psymtabs() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs}{dwarf2read.c}\\
Refs Func:\ & dwarf2\_free\_abbrev\_table() & dwarf2read.c & \cxreffunc{dwarf2_free_abbrev_table}{dwarf2read.c}\\
\ & dwarf2\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_psymtab_to_symtab}{dwarf2read.c}\\
\ & free\_cached\_comp\_units() & dwarf2read.c & \cxreffunc{free_cached_comp_units}{dwarf2read.c}\\
\ & free\_stack\_comp\_unit() & dwarf2read.c & \cxreffunc{free_stack_comp_unit}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Refs Var:\ & byte\_swap\_p & dwarf2read.c & \cxrefvar{byte_swap_p}{dwarf2read.c}\\
\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & file\_symbols & buildsym.c & \cxrefvar{file_symbols}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_clear\_marks()}
\label{func_dwarf2_clear_marks_dwarf2read.c}

{\stt static void dwarf2\_clear\_marks ( struct dwarf2\_per\_cu\_data* per\_cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & age\_cached\_comp\_units() & dwarf2read.c & \cxreffunc{age_cached_comp_units}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_complex\_location\_expr\_complaint()}
\label{func_dwarf2_complex_location_expr_complaint_dwarf2read.c}

{\stt static void dwarf2\_complex\_location\_expr\_complaint ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & dwarf2\_add\_member\_fn() & dwarf2read.c & \cxreffunc{dwarf2_add_member_fn}{dwarf2read.c}\\
\ & read\_common\_block() & dwarf2read.c & \cxreffunc{read_common_block}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_const\_value()}
\label{func_dwarf2_const_value_dwarf2read.c}

{\stt static void dwarf2\_const\_value ( struct attribute* attr, struct symbol* sym, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_const\_value\_data() & dwarf2read.c & \cxreffunc{dwarf2_const_value_data}{dwarf2read.c}\\
\ & dwarf2\_const\_value\_length\_mismatch\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_const_value_length_mismatch_complaint}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_form\_name() & dwarf2read.c & \cxreffunc{dwarf_form_name}{dwarf2read.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & store\_unsigned\_integer() & findvar.c & \cxreffunc{store_unsigned_integer}{findvar.c}\\
\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_const\_value\_data()}
\label{func_dwarf2_const_value_data_dwarf2read.c}

{\stt static void dwarf2\_const\_value\_data ( struct attribute* attr, struct symbol* sym, int bits )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
Called by:\ & dwarf2\_const\_value() & dwarf2read.c & \cxreffunc{dwarf2_const_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_const\_value\_length\_mismatch\_complaint()}
\label{func_dwarf2_const_value_length_mismatch_complaint_dwarf2read.c}

{\stt static void dwarf2\_const\_value\_length\_mismatch\_complaint ( const char* arg1, int arg2, int arg3 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & dwarf2\_const\_value() & dwarf2read.c & \cxreffunc{dwarf2_const_value}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_copy\_dwarf\_from\_file()}
\label{func_dwarf2_copy_dwarf_from_file_dwarf2read.c}

{\stt static void dwarf2\_copy\_dwarf\_from\_file ( struct objfile* objfile, bfd* abfd )}

\smallskip
\begin{cxreftabiii}
Calls:\ & dwarf2\_read\_section() & dwarf2read.c & \cxreffunc{dwarf2_read_section}{dwarf2read.c}\\
Called by:\ & dwarf2\_build\_psymtabs() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs}{dwarf2read.c}\\
\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_kext\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & dwarf\_abbrev\_section & dwarf2read.c & \cxrefvar{dwarf_abbrev_section}{dwarf2read.c}\\
\ & dwarf\_info\_section & dwarf2read.c & \cxrefvar{dwarf_info_section}{dwarf2read.c}\\
\ & dwarf\_inlined\_section & dwarf2read.c & \cxrefvar{dwarf_inlined_section}{dwarf2read.c}\\
\ & dwarf\_line\_section & dwarf2read.c & \cxrefvar{dwarf_line_section}{dwarf2read.c}\\
\ & dwarf\_loc\_section & dwarf2read.c & \cxrefvar{dwarf_loc_section}{dwarf2read.c}\\
\ & dwarf\_macinfo\_section & dwarf2read.c & \cxrefvar{dwarf_macinfo_section}{dwarf2read.c}\\
\ & dwarf\_ranges\_section & dwarf2read.c & \cxrefvar{dwarf_ranges_section}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_str\_section & dwarf2read.c & \cxrefvar{dwarf_str_section}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_create\_include\_psymtab()}
\label{func_dwarf2_create_include_psymtab_dwarf2read.c}

{\stt static void dwarf2\_create\_include\_psymtab ( char* name, struct partial\_symtab* pst, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & allocate\_psymtab() & symfile.c & \cxreffunc{allocate_psymtab}{symfile.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_extension()}
\label{func_dwarf2_extension_dwarf2read.c}

{\stt static struct die\_info* dwarf2\_extension ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
Called by:\ & namespace\_name() & dwarf2read.c & \cxreffunc{namespace_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_namespace() & dwarf2read.c & \cxreffunc{read_namespace}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_find\_comp\_unit()}
\label{func_dwarf2_find_comp_unit_dwarf2read.c}

{\stt static struct dwarf2\_per\_cu\_data* dwarf2\_find\_comp\_unit ( unsigned long offset, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_find\_containing\_comp\_unit() & dwarf2read.c & \cxreffunc{dwarf2_find_containing_comp_unit}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_find\_containing\_comp\_unit()}
\label{func_dwarf2_find_containing_comp_unit_dwarf2read.c}

{\stt static struct dwarf2\_per\_cu\_data* dwarf2\_find\_containing\_comp\_unit ( unsigned long offset, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & dwarf2\_find\_comp\_unit() & dwarf2read.c & \cxreffunc{dwarf2_find_comp_unit}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_partial\_die() & dwarf2read.c & \cxreffunc{find_partial_die}{dwarf2read.c}\\
\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_flag\_true\_p()}
\label{func_dwarf2_flag_true_p_dwarf2read.c}

{\stt static int dwarf2\_flag\_true\_p ( struct die\_info* die, unsigned name, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
Called by:\ & die\_is\_declaration() & dwarf2read.c & \cxreffunc{die_is_declaration}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_free\_abbrev\_table()}
\label{func_dwarf2_free_abbrev_table_dwarf2read.c}

{\stt static void dwarf2\_free\_abbrev\_table ( void* ptr\_to\_cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & find\_debug\_info\_for\_pst() & dwarf2read.c & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\ & load\_comp\_unit() & dwarf2read.c & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
Refs Func:\ & \cxreftabiiispan{ obstack\_free()} &\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_fundamental\_type()}
\label{func_dwarf2_fundamental_type_dwarf2read.c}

{\stt static struct type* dwarf2\_fundamental\_type ( struct objfile* objfile, int d2typeid, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
Called by:\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf\_base\_type() & dwarf2read.c & \cxreffunc{dwarf_base_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\ & read\_base\_type() & dwarf2read.c & \cxreffunc{read_base_type}{dwarf2read.c}\\
\ & read\_tag\_string\_type() & dwarf2read.c & \cxreffunc{read_tag_string_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_get\_attr\_constant\_value()}
\label{func_dwarf2_get_attr_constant_value_dwarf2read.c}

{\stt static int dwarf2\_get\_attr\_constant\_value ( struct attribute* attr, int default\_value )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf\_form\_name() & dwarf2read.c & \cxreffunc{dwarf_form_name}{dwarf2read.c}\\
Called by:\ & read\_subrange\_type() & dwarf2read.c & \cxreffunc{read_subrange_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_get\_pc\_bounds()}
\label{func_dwarf2_get_pc_bounds_dwarf2read.c}

{\stt static int dwarf2\_get\_pc\_bounds ( struct die\_info* die, CORE\_ADDR* lowpc, CORE\_ADDR* highpc, struct address\_range\_list** ranges, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & read\_address() & dwarf2read.c & \cxreffunc{read_address}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & get\_scope\_pc\_bounds() & dwarf2read.c & \cxreffunc{get_scope_pc_bounds}{dwarf2read.c}\\
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\ & read\_lexical\_block\_scope() & dwarf2read.c & \cxreffunc{read_lexical_block_scope}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_get\_ref\_die\_offset()}
\label{func_dwarf2_get_ref_die_offset_dwarf2read.c}

{\stt static unsigned int dwarf2\_get\_ref\_die\_offset ( struct attribute* attr, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf\_form\_name() & dwarf2read.c & \cxreffunc{dwarf_form_name}{dwarf2read.c}\\
Called by:\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_has\_info\_1()}
\label{func_dwarf2_has_info_1_dwarf2read.c}

{\stt static int dwarf2\_has\_info\_1 ( struct objfile* objfile, bfd* abfd )}

\smallskip
\begin{cxreftabiii}
Calls:\ & set\_objfile\_data() & objfiles.c & \cxreffunc{set_objfile_data}{objfiles.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk(), bfd\_map\_over\_sections()} &\\
Called by:\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_has\_info() & dwarf2read.c & \cxreffunc{dwarf2_has_info}{dwarf2read.c}\\
\ & dwarf2\_kext\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & dwarf2\_locate\_sections() & dwarf2read.c & \cxreffunc{dwarf2_locate_sections}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_objfile\_data\_key & dwarf2read.c & \cxrefvar{dwarf2_objfile_data_key}{dwarf2read.c}\\
\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & dwarf\_abbrev\_section & dwarf2read.c & \cxrefvar{dwarf_abbrev_section}{dwarf2read.c}\\
\ & dwarf\_eh\_frame\_section & dwarf2read.c & \cxrefvar{dwarf_eh_frame_section}{dwarf2read.c}\\
\ & dwarf\_frame\_section & dwarf2read.c & \cxrefvar{dwarf_frame_section}{dwarf2read.c}\\
\ & dwarf\_info\_section & dwarf2read.c & \cxrefvar{dwarf_info_section}{dwarf2read.c}\\
\ & dwarf\_inlined\_section & dwarf2read.c & \cxrefvar{dwarf_inlined_section}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_line\_section & dwarf2read.c & \cxrefvar{dwarf_line_section}{dwarf2read.c}\\
\ & dwarf\_loc\_section & dwarf2read.c & \cxrefvar{dwarf_loc_section}{dwarf2read.c}\\
\ & dwarf\_macinfo\_section & dwarf2read.c & \cxrefvar{dwarf_macinfo_section}{dwarf2read.c}\\
\ & dwarf\_ranges\_section & dwarf2read.c & \cxrefvar{dwarf_ranges_section}{dwarf2read.c}\\
\ & dwarf\_str\_section & dwarf2read.c & \cxrefvar{dwarf_str_section}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_invalid\_attrib\_class\_complaint()}
\label{func_dwarf2_invalid_attrib_class_complaint_dwarf2read.c}

{\stt static void dwarf2\_invalid\_attrib\_class\_complaint ( const char* arg1, const char* arg2 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & dwarf2\_add\_member\_fn() & dwarf2read.c & \cxreffunc{dwarf2_add_member_fn}{dwarf2read.c}\\
\ & dwarf2\_symbol\_mark\_computed() & dwarf2read.c & \cxreffunc{dwarf2_symbol_mark_computed}{dwarf2read.c}\\
\ & read\_common\_block() & dwarf2read.c & \cxreffunc{read_common_block}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_linkage\_name()}
\label{func_dwarf2_linkage_name_dwarf2read.c}

{\stt static char* dwarf2\_linkage\_name ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
Called by:\ & determine\_class\_name() & dwarf2read.c & \cxreffunc{determine_class_name}{dwarf2read.c}\\
\ & dwarf2\_add\_field() & dwarf2read.c & \cxreffunc{dwarf2_add_field}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_add\_member\_fn() & dwarf2read.c & \cxreffunc{dwarf2_add_member_fn}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_locate\_sections()}
\label{func_dwarf2_locate_sections_dwarf2read.c}

{\stt static void dwarf2\_locate\_sections ( bfd* ignore\_abfd, asection* sectp, void* ignore\_ptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & \cxreftabiiispan{ strcmp()} &\\
Used in:\ & dwarf2\_has\_info\_1() & dwarf2read.c & \cxreffunc{dwarf2_has_info_1}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & dwarf\_abbrev\_section & dwarf2read.c & \cxrefvar{dwarf_abbrev_section}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_aranges\_section & dwarf2read.c & \cxrefvar{dwarf_aranges_section}{dwarf2read.c}\\
\ & dwarf\_eh\_frame\_section & dwarf2read.c & \cxrefvar{dwarf_eh_frame_section}{dwarf2read.c}\\
\ & dwarf\_frame\_section & dwarf2read.c & \cxrefvar{dwarf_frame_section}{dwarf2read.c}\\
\ & dwarf\_info\_section & dwarf2read.c & \cxrefvar{dwarf_info_section}{dwarf2read.c}\\
\ & dwarf\_inlined\_section & dwarf2read.c & \cxrefvar{dwarf_inlined_section}{dwarf2read.c}\\
\ & dwarf\_line\_section & dwarf2read.c & \cxrefvar{dwarf_line_section}{dwarf2read.c}\\
\ & dwarf\_loc\_section & dwarf2read.c & \cxrefvar{dwarf_loc_section}{dwarf2read.c}\\
\ & dwarf\_macinfo\_section & dwarf2read.c & \cxrefvar{dwarf_macinfo_section}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_pubnames\_section & dwarf2read.c & \cxrefvar{dwarf_pubnames_section}{dwarf2read.c}\\
\ & dwarf\_pubtypes\_section & dwarf2read.c & \cxrefvar{dwarf_pubtypes_section}{dwarf2read.c}\\
\ & dwarf\_ranges\_section & dwarf2read.c & \cxrefvar{dwarf_ranges_section}{dwarf2read.c}\\
\ & dwarf\_str\_section & dwarf2read.c & \cxrefvar{dwarf_str_section}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_lookup\_abbrev()}
\label{func_dwarf2_lookup_abbrev_dwarf2read.c}

{\stt static struct abbrev\_info* dwarf2\_lookup\_abbrev ( unsigned int number, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & dwarf2\_read\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\ & peek\_die\_abbrev() & dwarf2read.c & \cxreffunc{peek_die_abbrev}{dwarf2read.c}\\
\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_macro\_malformed\_definition\_complaint()}
\label{func_dwarf2_macro_malformed_definition_complaint_dwarf2read.c}

{\stt static void dwarf2\_macro\_malformed\_definition\_complaint ( const char* arg1 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & parse\_macro\_definition() & dwarf2read.c & \cxreffunc{parse_macro_definition}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_macros\_too\_long\_complaint()}
\label{func_dwarf2_macros_too_long_complaint_dwarf2read.c}

{\stt static void dwarf2\_macros\_too\_long\_complaint ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & dwarf\_decode\_macros() & dwarf2read.c & \cxreffunc{dwarf_decode_macros}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_mark()}
\label{func_dwarf2_mark_dwarf2read.c}

{\stt static void dwarf2\_mark ( struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & \cxreftabiiispan{ htab\_traverse()} &\\
Called by:\ & age\_cached\_comp\_units() & dwarf2read.c & \cxreffunc{age_cached_comp_units}{dwarf2read.c}\\
Refs Func:\ & dwarf2\_mark\_helper() & dwarf2read.c & \cxreffunc{dwarf2_mark_helper}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_mark\_helper()}
\label{func_dwarf2_mark_helper_dwarf2read.c}

{\stt static int dwarf2\_mark\_helper ( void** slot, void* data )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ htab\_traverse()} &\\
Used in:\ & dwarf2\_mark() & dwarf2read.c & \cxreffunc{dwarf2_mark}{dwarf2read.c}\\
\ & dwarf2\_mark\_helper() & dwarf2read.c & \cxreffunc{dwarf2_mark_helper}{dwarf2read.c}\\
Refs Func:\ & dwarf2\_mark\_helper() & dwarf2read.c & \cxreffunc{dwarf2_mark_helper}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_name()}
\label{func_dwarf2_name_dwarf2read.c}

{\stt static char* dwarf2\_name ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
Called by:\ & determine\_class\_name() & dwarf2read.c & \cxreffunc{determine_class_name}{dwarf2read.c}\\
\ & namespace\_name() & dwarf2read.c & \cxreffunc{namespace_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_psymtab\_to\_symtab()}
\label{func_dwarf2_psymtab_to_symtab_dwarf2read.c}

{\stt static void dwarf2\_psymtab\_to\_symtab ( struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & get\_objfile\_data() & objfiles.c & \cxreffunc{get_objfile_data}{objfiles.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & psymtab\_to\_symtab\_1() & dwarf2read.c & \cxreffunc{psymtab_to_symtab_1}{dwarf2read.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Used in:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_objfile\_data\_key & dwarf2read.c & \cxrefvar{dwarf2_objfile_data_key}{dwarf2read.c}\\
\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_read\_abbrevs()}
\label{func_dwarf2_read_abbrevs_dwarf2read.c}

{\stt static void dwarf2\_read\_abbrevs ( bfd* abfd, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_lookup\_abbrev() & dwarf2read.c & \cxreffunc{dwarf2_lookup_abbrev}{dwarf2read.c}\\
\ & dwarf\_alloc\_abbrev() & dwarf2read.c & \cxreffunc{dwarf_alloc_abbrev}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_\_inline\_memset\_chk(), \_obstack\_begin(), \_obstack\_newchunk()} &\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & find\_debug\_info\_for\_pst() & dwarf2read.c & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\ & load\_comp\_unit() & dwarf2read.c & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_read\_repository\_abbrevs()}
\label{func_dwarf2_read_repository_abbrevs_dwarf2read.c}

{\stt static void dwarf2\_read\_repository\_abbrevs ( struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & find\_open\_repository() & dwarf2read.c & \cxreffunc{find_open_repository}{dwarf2read.c}\\
\ & read\_in\_db\_abbrev\_table() & dwarf2read.c & \cxreffunc{read_in_db_abbrev_table}{dwarf2read.c}\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_record\_line()}
\label{func_dwarf2_record_line_dwarf2read.c}

{\stt static int dwarf2\_record\_line ( struct line\_header* lh, char* comp\_dir, struct dwarf2\_cu* cu, CORE\_ADDR address, CORE\_ADDR baseaddr, int file, int line, int end\_sequence )}

\smallskip
\begin{cxreftabiii}
Calls:\ & check\_cu\_functions() & dwarf2read.c & \cxreffunc{check_cu_functions}{dwarf2read.c}\\
\ & check\_inlined\_function\_calls() & dwarf2read.c & \cxreffunc{check_inlined_function_calls}{dwarf2read.c}\\
\ & compare\_translation\_tuples\_inclusive() & dwarf2read.c & \cxreffunc{compare_translation_tuples_inclusive}{dwarf2read.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & record\_line() & buildsym.c & \cxreffunc{record_line}{buildsym.c}\\
\ & translate\_debug\_map\_address\_with\_tuple() & dwarf2read.c & \cxreffunc{translate_debug_map_address_with_tuple}{dwarf2read.c}\\
\ & \cxreftabiiispan{ bsearch()} &\\
Called by:\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
Refs Func:\ & compare\_translation\_tuples\_inclusive() & dwarf2read.c & \cxreffunc{compare_translation_tuples_inclusive}{dwarf2read.c}\\
Refs Var:\ & current\_subfile & buildsym.c & \cxrefvar{current_subfile}{buildsym.c}\\
\ & debug\_debugmap & dwarf2read.c & \cxrefvar{debug_debugmap}{dwarf2read.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_release\_queue()}
\label{func_dwarf2_release_queue_dwarf2read.c}

{\stt static void dwarf2\_release\_queue ( void* dummy )}

\smallskip
\begin{cxreftabiii}
Calls:\ & free\_one\_cached\_comp\_unit() & dwarf2read.c & \cxreffunc{free_one_cached_comp_unit}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Used in:\ & psymtab\_to\_symtab\_1() & dwarf2read.c & \cxreffunc{psymtab_to_symtab_1}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_queue & dwarf2read.c & \cxrefvar{dwarf2_queue}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_queue\_tail & dwarf2read.c & \cxrefvar{dwarf2_queue_tail}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_start\_subfile()}
\label{func_dwarf2_start_subfile_dwarf2read.c}

{\stt static void dwarf2\_start\_subfile ( char* filename, char* dirname, char* comp\_dir )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & start\_subfile() & buildsym.c & \cxreffunc{start_subfile}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ concat(), strcmp()} &\\
Called by:\ & check\_inlined\_function\_calls() & dwarf2read.c & \cxreffunc{check_inlined_function_calls}{dwarf2read.c}\\
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
Refs Func:\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & current\_subfile & buildsym.c & \cxrefvar{current_subfile}{buildsym.c}\\
\ & subfiles & buildsym.c & \cxrefvar{subfiles}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_statement\_list\_fits\_in\_line\_number\_section\_complaint()}
\label{func_dwarf2_statement_list_fits_in_line_number_section_complaint_dwarf2read.c}

{\stt static void dwarf2\_statement\_list\_fits\_in\_line\_number\_section\_complaint ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf2\_symbol\_mark\_computed()}
\label{func_dwarf2_symbol_mark_computed_dwarf2read.c}

{\stt static void dwarf2\_symbol\_mark\_computed ( struct attribute* attr, struct symbol* sym, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & attr\_form\_is\_block() & dwarf2read.c & \cxreffunc{attr_form_is_block}{dwarf2read.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_invalid\_attrib\_class\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_invalid_attrib_class_complaint}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & var\_decode\_location() & dwarf2read.c & \cxreffunc{var_decode_location}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_locexpr\_funcs & dwarf2loc.c & \cxrefvar{dwarf2_locexpr_funcs}{dwarf2loc.c}\\
\ & dwarf2\_loclist\_funcs & dwarf2loc.c & \cxrefvar{dwarf2_loclist_funcs}{dwarf2loc.c}\\
\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_alloc\_abbrev()}
\label{func_dwarf_alloc_abbrev_dwarf2read.c}

{\stt static struct abbrev\_info* dwarf\_alloc\_abbrev ( struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & dwarf2\_read\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_alloc\_block()}
\label{func_dwarf_alloc_block_dwarf2read.c}

{\stt static struct dwarf\_block* dwarf\_alloc\_block ( struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_alloc\_die()}
\label{func_dwarf_alloc_die_dwarf2read.c}

{\stt static struct die\_info* dwarf\_alloc\_die ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_attr\_name()}
\label{func_dwarf_attr_name_dwarf2read.c}

{\stt static const char* dwarf\_attr\_name ( unsigned int attr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & dump\_die() & dwarf2read.c & \cxreffunc{dump_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_base\_type()}
\label{func_dwarf_base_type_dwarf2read.c}

{\stt static struct type* dwarf\_base\_type ( int encoding, int size, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_fundamental\_type() & dwarf2read.c & \cxreffunc{dwarf2_fundamental_type}{dwarf2read.c}\\
Called by:\ & read\_base\_type() & dwarf2read.c & \cxreffunc{read_base_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_bool\_name()}
\label{func_dwarf_bool_name_dwarf2read.c}

{\stt static const char* dwarf\_bool\_name ( unsigned mybool )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & dump\_die() & dwarf2read.c & \cxreffunc{dump_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_decode\_line\_header()}
\label{func_dwarf_decode_line_header_dwarf2read.c}

{\stt static struct line\_header* dwarf\_decode\_line\_header ( unsigned int offset, bfd* abfd, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_file\_name() & dwarf2read.c & \cxreffunc{add_file_name}{dwarf2read.c}\\
\ & add\_include\_dir() & dwarf2read.c & \cxreffunc{add_include_dir}{dwarf2read.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & discard\_cleanups() & utils.c & \cxreffunc{discard_cleanups}{utils.c}\\
\ & dwarf2\_statement\_list\_fits\_in\_line\_number\_section\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_statement_list_fits_in_line_number_section_complaint}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_1\_signed\_byte() & dwarf2read.c & \cxreffunc{read_1_signed_byte}{dwarf2read.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_initial\_length() & dwarf2read.c & \cxreffunc{read_initial_length}{dwarf2read.c}\\
\ & read\_offset() & dwarf2read.c & \cxreffunc{read_offset}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_string() & dwarf2read.c & \cxreffunc{read_string}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & dwarf2\_build\_include\_psymtabs() & dwarf2read.c & \cxreffunc{dwarf2_build_include_psymtabs}{dwarf2read.c}\\
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
Refs Func:\ & free\_line\_header() & dwarf2read.c & \cxreffunc{free_line_header}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_decode\_lines()}
\label{func_dwarf_decode_lines_dwarf2read.c}

{\stt static void dwarf\_decode\_lines ( struct line\_header* lh, char* comp\_dir, bfd* abfd, struct dwarf2\_cu* cu, struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_file\_name() & dwarf2read.c & \cxreffunc{add_file_name}{dwarf2read.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_create\_include\_psymtab() & dwarf2read.c & \cxreffunc{dwarf2_create_include_psymtab}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_record\_line() & dwarf2read.c & \cxreffunc{dwarf2_record_line}{dwarf2read.c}\\
\ & dwarf2\_start\_subfile() & dwarf2read.c & \cxreffunc{dwarf2_start_subfile}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_address() & dwarf2read.c & \cxreffunc{read_address}{dwarf2read.c}\\
\ & read\_signed\_leb128() & dwarf2read.c & \cxreffunc{read_signed_leb128}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_string() & dwarf2read.c & \cxreffunc{read_string}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & \cxreftabiiispan{ concat(), strcmp()} &\\
Called by:\ & dwarf2\_build\_include\_psymtabs() & dwarf2read.c & \cxreffunc{dwarf2_build_include_psymtabs}{dwarf2read.c}\\
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_decode\_macros()}
\label{func_dwarf_decode_macros_dwarf2read.c}

{\stt static void dwarf\_decode\_macros ( struct line\_header* lh, unsigned int offset, char* comp\_dir, bfd* abfd, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_macros\_too\_long\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_macros_too_long_complaint}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & macro\_start\_file() & dwarf2read.c & \cxreffunc{macro_start_file}{dwarf2read.c}\\
\ & macro\_undef() & macrotab.c & \cxreffunc{macro_undef}{macrotab.c}\\
\ & parse\_macro\_definition() & dwarf2read.c & \cxreffunc{parse_macro_definition}{dwarf2read.c}\\
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_string() & dwarf2read.c & \cxreffunc{read_string}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & \cxreftabiiispan{ fprintf()} &\\
Called by:\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_form\_name()}
\label{func_dwarf_form_name_dwarf2read.c}

{\stt static const char* dwarf\_form\_name ( unsigned int form )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
\ & dump\_die() & dwarf2read.c & \cxreffunc{dump_die}{dwarf2read.c}\\
\ & dwarf2\_const\_value() & dwarf2read.c & \cxreffunc{dwarf2_const_value}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_get\_attr\_constant\_value() & dwarf2read.c & \cxreffunc{dwarf2_get_attr_constant_value}{dwarf2read.c}\\
\ & dwarf2\_get\_ref\_die\_offset() & dwarf2read.c & \cxreffunc{dwarf2_get_ref_die_offset}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_stack\_op\_name()}
\label{func_dwarf_stack_op_name_dwarf2read.c}

{\stt static const char* dwarf\_stack\_op\_name ( unsigned int op )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_tag\_name()}
\label{func_dwarf_tag_name_dwarf2read.c}

{\stt static const char* dwarf\_tag\_name ( unsigned tag )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & dump\_die() & dwarf2read.c & \cxreffunc{dump_die}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_type\_encoding\_name()}
\label{func_dwarf_type_encoding_name_dwarf2read.c}

{\stt static const char* dwarf\_type\_encoding\_name ( unsigned int enc )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & read\_base\_type() & dwarf2read.c & \cxreffunc{read_base_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function file\_full\_name()}
\label{func_file_full_name_dwarf2read.c}

{\stt static char* file\_full\_name ( int file, struct line\_header* lh, const char* comp\_dir )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), strlen(), xstrdup()} &\\
Called by:\ & macro\_start\_file() & dwarf2read.c & \cxreffunc{macro_start_file}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fill\_in\_die\_info()}
\label{func_fill_in_die_info_dwarf2read.c}

{\stt static void fill\_in\_die\_info ( struct die\_info* new\_die, int die\_len, uint8\_t* die\_bytes, uint8\_t* d\_ptr, struct abbrev\_info* abbrev\_table, sqlite3* db )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & db\_lookup\_type() & dwarf2read.c & \cxreffunc{db_lookup_type}{dwarf2read.c}\\
\ & db\_read\_attribute\_value() & dwarf2read.c & \cxreffunc{db_read_attribute_value}{dwarf2read.c}\\
\ & get\_uleb128() & dwarf2read.c & \cxreffunc{get_uleb128}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & db\_lookup\_type() & dwarf2read.c & \cxreffunc{db_lookup_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function finalize\_stmts()}
\label{func_finalize_stmts_dwarf2read.c}

{\stt static int finalize\_stmts ( sqlite3* db )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & db\_error() & dwarf2read.c & \cxreffunc{db_error}{dwarf2read.c}\\
\ & \cxreftabiiispan{ sqlite3\_finalize()} &\\
Called by:\ & close\_dwarf\_repositories() & dwarf2read.c & \cxreffunc{close_dwarf_repositories}{dwarf2read.c}\\
\ & db\_error() & dwarf2read.c & \cxreffunc{db_error}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & db\_stmt1 & dwarf2read.c & \cxrefvar{db_stmt1}{dwarf2read.c}\\
\ & db\_stmt2 & dwarf2read.c & \cxrefvar{db_stmt2}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_debug\_inlined\_section()}
\label{func_find_debug_inlined_section_dwarf2read.c}

{\stt static bfd\_boolean find\_debug\_inlined\_section ( bfd* ignore\_abfd, asection* sectp, void* ignore )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & \cxreftabiiispan{ strcmp()} &\\
Used in:\ & dwarf2\_scan\_inlined\_section\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_inlined_section_for_psymbols}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_debug\_str\_section()}
\label{func_find_debug_str_section_dwarf2read.c}

{\stt static bfd\_boolean find\_debug\_str\_section ( bfd* ignore\_abfd, asection* sectp, void* ignore )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & \cxreftabiiispan{ strcmp()} &\\
Used in:\ & dwarf2\_scan\_inlined\_section\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_inlined_section_for_psymbols}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_open\_repository()}
\label{func_find_open_repository_dwarf2read.c}

{\stt static struct database\_info* find\_open\_repository ( sqlite3* db )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & dwarf2\_read\_repository\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_repository_abbrevs}{dwarf2read.c}\\
\ & lookup\_repository\_type() & dwarf2read.c & \cxreffunc{lookup_repository_type}{dwarf2read.c}\\
\ & set\_repository\_cu\_language() & dwarf2read.c & \cxreffunc{set_repository_cu_language}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & num\_open\_dbs & dwarf2read.c & \cxrefvar{num_open_dbs}{dwarf2read.c}\\
\ & repositories & dwarf2read.c & \cxrefvar{repositories}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_partial\_die()}
\label{func_find_partial_die_dwarf2read.c}

{\stt static struct partial\_die\_info* find\_partial\_die ( unsigned long offset, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_find\_containing\_comp\_unit() & dwarf2read.c & \cxreffunc{dwarf2_find_containing_comp_unit}{dwarf2read.c}\\
\ & find\_partial\_die\_in\_comp\_unit() & dwarf2read.c & \cxreffunc{find_partial_die_in_comp_unit}{dwarf2read.c}\\
\ & load\_comp\_unit() & dwarf2read.c & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & fixup\_partial\_die() & dwarf2read.c & \cxreffunc{fixup_partial_die}{dwarf2read.c}\\
\ & guess\_structure\_name() & dwarf2read.c & \cxreffunc{guess_structure_name}{dwarf2read.c}\\
\ & partial\_die\_parent\_scope() & dwarf2read.c & \cxreffunc{partial_die_parent_scope}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_partial\_die\_in\_comp\_unit()}
\label{func_find_partial_die_in_comp_unit_dwarf2read.c}

{\stt static struct partial\_die\_info* find\_partial\_die\_in\_comp\_unit ( unsigned long offset, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), basename(), htab\_find\_with\_hash()} &\\
Called by:\ & find\_partial\_die() & dwarf2read.c & \cxreffunc{find_partial_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_pubtypes()}
\label{func_find_pubtypes_dwarf2read.c}

{\stt static bfd\_boolean find\_pubtypes ( bfd* ignore\_abfd, asection* sectp, void* ignore )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ strcmp()} &\\
Used in:\ & dwarf2\_scan\_pubtype\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_pubtype_for_psymbols}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fix\_inlined\_subroutine\_symbols()}
\label{func_fix_inlined_subroutine_symbols_dwarf2read.c}

{\stt static void fix\_inlined\_subroutine\_symbols ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & process\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{process_full_comp_unit}{dwarf2read.c}\\
Refs Var:\ & inlined\_subroutine\_symbols & dwarf2read.c & \cxrefvar{inlined_subroutine_symbols}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fixup\_partial\_die()}
\label{func_fixup_partial_die_dwarf2read.c}

{\stt static void fixup\_partial\_die ( struct partial\_die\_info* part\_die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & find\_partial\_die() & dwarf2read.c & \cxreffunc{find_partial_die}{dwarf2read.c}\\
\ & fixup\_partial\_die() & dwarf2read.c & \cxreffunc{fixup_partial_die}{dwarf2read.c}\\
\ & guess\_structure\_name() & dwarf2read.c & \cxreffunc{guess_structure_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & fixup\_partial\_die() & dwarf2read.c & \cxreffunc{fixup_partial_die}{dwarf2read.c}\\
\ & partial\_die\_parent\_scope() & dwarf2read.c & \cxreffunc{partial_die_parent_scope}{dwarf2read.c}\\
\ & scan\_partial\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_symbols}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function follow\_db\_ref()}
\label{func_follow_db_ref_dwarf2read.c}

{\stt static struct die\_info* follow\_db\_ref ( struct die\_info* die, struct attribute* repository\_spec, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & lookup\_repository\_type() & dwarf2read.c & \cxreffunc{lookup_repository_type}{dwarf2read.c}\\
Called by:\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function follow\_die\_ref()}
\label{func_follow_die_ref_dwarf2read.c}

{\stt static struct die\_info* follow\_die\_ref ( struct die\_info* src\_die, struct attribute* attr, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_find\_containing\_comp\_unit() & dwarf2read.c & \cxreffunc{dwarf2_find_containing_comp_unit}{dwarf2read.c}\\
\ & dwarf2\_get\_ref\_die\_offset() & dwarf2read.c & \cxreffunc{dwarf2_get_ref_die_offset}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & die\_containing\_type() & dwarf2read.c & \cxreffunc{die_containing_type}{dwarf2read.c}\\
\ & die\_specification() & dwarf2read.c & \cxreffunc{die_specification}{dwarf2read.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_extension() & dwarf2read.c & \cxreffunc{dwarf2_extension}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_cached\_comp\_units()}
\label{func_free_cached_comp_units_dwarf2read.c}

{\stt static void free\_cached\_comp\_units ( void* data )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & free\_one\_comp\_unit() & dwarf2read.c & \cxreffunc{free_one_comp_unit}{dwarf2read.c}\\
Used in:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & find\_debug\_info\_for\_pst() & dwarf2read.c & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_die\_list()}
\label{func_free_die_list_dwarf2read.c}

{\stt static void free\_die\_list ( struct die\_info* dies )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & free\_die\_list() & dwarf2read.c & \cxreffunc{free_die_list}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & free\_die\_list() & dwarf2read.c & \cxreffunc{free_die_list}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & free\_one\_comp\_unit() & dwarf2read.c & \cxreffunc{free_one_comp_unit}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_line\_header()}
\label{func_free_line_header_dwarf2read.c}

{\stt static void free\_line\_header ( struct line\_header* lh )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & dwarf2\_build\_include\_psymtabs() & dwarf2read.c & \cxreffunc{dwarf2_build_include_psymtabs}{dwarf2read.c}\\
Used in:\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_one\_cached\_comp\_unit()}
\label{func_free_one_cached_comp_unit_dwarf2read.c}

{\stt static void free\_one\_cached\_comp\_unit ( void* target\_cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & free\_one\_comp\_unit() & dwarf2read.c & \cxreffunc{free_one_comp_unit}{dwarf2read.c}\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & dwarf2\_release\_queue() & dwarf2read.c & \cxreffunc{dwarf2_release_queue}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_one\_comp\_unit()}
\label{func_free_one_comp_unit_dwarf2read.c}

{\stt static void free\_one\_comp\_unit ( void* data )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & free\_die\_list() & dwarf2read.c & \cxreffunc{free_die_list}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & age\_cached\_comp\_units() & dwarf2read.c & \cxreffunc{age_cached_comp_units}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & free\_cached\_comp\_units() & dwarf2read.c & \cxreffunc{free_cached_comp_units}{dwarf2read.c}\\
\ & free\_one\_cached\_comp\_unit() & dwarf2read.c & \cxreffunc{free_one_cached_comp_unit}{dwarf2read.c}\\
Used in:\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
Refs Func:\ & \cxreftabiiispan{ obstack\_free()} &\\
\end{cxreftabiii}


\subsubsection{Local Function free\_stack\_comp\_unit()}
\label{func_free_stack_comp_unit_dwarf2read.c}

{\stt static void free\_stack\_comp\_unit ( void* data )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & age\_cached\_comp\_units() & dwarf2read.c & \cxreffunc{age_cached_comp_units}{dwarf2read.c}\\
Used in:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & find\_debug\_info\_for\_pst() & dwarf2read.c & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & \cxreftabiiispan{ obstack\_free()} &\\
\end{cxreftabiii}


\subsubsection{Local Function get\_die\_type()}
\label{func_get_die_type_dwarf2read.c}

{\stt static struct type* get\_die\_type ( struct die\_info* die, htab\_t type\_hash )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ htab\_find\_with\_hash()} &\\
Called by:\ & reset\_die\_and\_siblings\_types() & dwarf2read.c & \cxreffunc{reset_die_and_siblings_types}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_repository\_name()}
\label{func_get_repository_name_dwarf2read.c}

{\stt static struct attribute* get\_repository\_name ( struct attribute* attr, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & db\_error() & dwarf2read.c & \cxreffunc{db_error}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), sqlite3\_bind\_int(), sqlite3\_column\_text(), sqlite3\_prepare\_v2(), sqlite3\_step(), strlen()} &\\
Called by:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
Refs Var:\ & db\_stmt2 & dwarf2read.c & \cxrefvar{db_stmt2}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_scope\_pc\_bounds()}
\label{func_get_scope_pc_bounds_dwarf2read.c}

{\stt static void get\_scope\_pc\_bounds ( struct die\_info* die, CORE\_ADDR* lowpc, CORE\_ADDR* highpc, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_get\_pc\_bounds() & dwarf2read.c & \cxreffunc{dwarf2_get_pc_bounds}{dwarf2read.c}\\
\ & get\_scope\_pc\_bounds() & dwarf2read.c & \cxreffunc{get_scope_pc_bounds}{dwarf2read.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & get\_scope\_pc\_bounds() & dwarf2read.c & \cxreffunc{get_scope_pc_bounds}{dwarf2read.c}\\
\ & process\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{process_full_comp_unit}{dwarf2read.c}\\
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_uleb128()}
\label{func_get_uleb128_dwarf2read.c}

{\stt static uint32\_t get\_uleb128 ( uint8\_t** addr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & db\_lookup\_type() & dwarf2read.c & \cxreffunc{db_lookup_type}{dwarf2read.c}\\
\ & fill\_in\_die\_info() & dwarf2read.c & \cxreffunc{fill_in_die_info}{dwarf2read.c}\\
\ & read\_in\_db\_abbrev\_table() & dwarf2read.c & \cxreffunc{read_in_db_abbrev_table}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function guess\_structure\_name()}
\label{func_guess_structure_name_dwarf2read.c}

{\stt static void guess\_structure\_name ( struct partial\_die\_info* struct\_pdi, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & find\_partial\_die() & dwarf2read.c & \cxreffunc{find_partial_die}{dwarf2read.c}\\
\ & language\_class\_name\_from\_physname() & language.c & \cxreffunc{language_class_name_from_physname}{language.c}\\
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & fixup\_partial\_die() & dwarf2read.c & \cxreffunc{fixup_partial_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function hashtab\_obstack\_allocate()}
\label{func_hashtab_obstack_allocate_dwarf2read.c}

{\stt static void* hashtab\_obstack\_allocate ( void* data, size\_t size, size\_t count )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk()} &\\
Used in:\ & dwarf2\_add\_dependence() & dwarf2read.c & \cxreffunc{dwarf2_add_dependence}{dwarf2read.c}\\
\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function increment\_use\_count()}
\label{func_increment_use_count_dwarf2read.c}

{\stt static void increment\_use\_count ( struct database\_info* repository, struct objfile* ofile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function initialize\_cu\_func\_list()}
\label{func_initialize_cu_func_list_dwarf2read.c}

{\stt static void initialize\_cu\_func\_list ( struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function initialize\_repositories()}
\label{func_initialize_repositories_dwarf2read.c}

{\stt static void initialize\_repositories ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
Refs Var:\ & repositories & dwarf2read.c & \cxrefvar{repositories}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_type\_tag\_for\_partial()}
\label{func_is_type_tag_for_partial_dwarf2read.c}

{\stt static int is\_type\_tag\_for\_partial ( int tag )}

\smallskip
\begin{cxreftabiii}
Called by:\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_vtable\_name()}
\label{func_is_vtable_name_dwarf2read.c}

{\stt static int is\_vtable\_name ( const char* name, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & is\_cplus\_marker() & demangle.c & \cxreffunc{is_cplus_marker}{demangle.c}\\
\ & \cxreftabiiispan{ strncmp()} &\\
Called by:\ & gnuv2\_value\_rtti\_type() & gnu-v2-abi.c & \cxreffunc{gnuv2_value_rtti_type}{gnu-v2-abi.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\ & record\_minimal\_symbol() & dbxread.c & \cxreffunc{record_minimal_symbol}{dbxread.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function left\_rotate()}
\label{func_left_rotate_dwarf2read.c}

{\stt static void left\_rotate ( struct rb\_tree\_node** root, struct rb\_tree\_node* x )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & rb\_delete\_fixup() & dwarf2read.c & \cxreffunc{rb_delete_fixup}{dwarf2read.c}\\
\ & rb\_tree\_insert() & dwarf2read.c & \cxreffunc{rb_tree_insert}{dwarf2read.c}\\
\ & rb\_tree\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_remove_node}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function load\_comp\_unit()}
\label{func_load_comp_unit_dwarf2read.c}

{\stt static void load\_comp\_unit ( struct dwarf2\_per\_cu\_data* this\_cu, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_read\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & partial\_read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{partial_read_comp_unit_head}{dwarf2read.c}\\
\ & peek\_die\_abbrev() & dwarf2read.c & \cxreffunc{peek_die_abbrev}{dwarf2read.c}\\
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\ & set\_cu\_language() & dwarf2read.c & \cxreffunc{set_cu_language}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_begin()} &\\
Called by:\ & find\_partial\_die() & dwarf2read.c & \cxreffunc{find_partial_die}{dwarf2read.c}\\
Refs Func:\ & dwarf2\_free\_abbrev\_table() & dwarf2read.c & \cxreffunc{dwarf2_free_abbrev_table}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function load\_full\_comp\_unit()}
\label{func_load_full_comp_unit_dwarf2read.c}

{\stt static struct dwarf2\_cu* load\_full\_comp\_unit ( struct dwarf2\_per\_cu\_data* per\_cu, struct oso\_to\_final\_addr\_map* addr\_map )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & discard\_cleanups() & utils.c & \cxreffunc{discard_cleanups}{utils.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_read\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & read\_comp\_unit() & dwarf2read.c & \cxreffunc{read_comp_unit}{dwarf2read.c}\\
\ & read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{read_comp_unit_head}{dwarf2read.c}\\
\ & set\_cu\_language() & dwarf2read.c & \cxreffunc{set_cu_language}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_begin()} &\\
Called by:\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_kext\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_queue() & dwarf2read.c & \cxreffunc{process_queue}{dwarf2read.c}\\
Refs Func:\ & dwarf2\_free\_abbrev\_table() & dwarf2read.c & \cxreffunc{dwarf2_free_abbrev_table}{dwarf2read.c}\\
\ & free\_one\_comp\_unit() & dwarf2read.c & \cxreffunc{free_one_comp_unit}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function load\_partial\_dies()}
\label{func_load_partial_dies_dwarf2read.c}

{\stt static struct partial\_die\_info* load\_partial\_dies ( bfd* abfd, char* info\_ptr, int building\_psymtab, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & is\_type\_tag\_for\_partial() & dwarf2read.c & \cxreffunc{is_type_tag_for_partial}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & locate\_pdi\_sibling() & dwarf2read.c & \cxreffunc{locate_pdi_sibling}{dwarf2read.c}\\
\ & peek\_die\_abbrev() & dwarf2read.c & \cxreffunc{peek_die_abbrev}{dwarf2read.c}\\
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk(), htab\_create\_alloc\_ex(), htab\_find\_slot\_with\_hash(), strlen()} &\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & load\_comp\_unit() & dwarf2read.c & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
Refs Func:\ & dummy\_obstack\_deallocate() & dwarf2read.c & \cxreffunc{dummy_obstack_deallocate}{dwarf2read.c}\\
\ & hashtab\_obstack\_allocate() & dwarf2read.c & \cxreffunc{hashtab_obstack_allocate}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & partial\_die\_eq() & dwarf2read.c & \cxreffunc{partial_die_eq}{dwarf2read.c}\\
\ & partial\_die\_hash() & dwarf2read.c & \cxreffunc{partial_die_hash}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function locate\_pdi\_sibling()}
\label{func_locate_pdi_sibling_dwarf2read.c}

{\stt static char* locate\_pdi\_sibling ( struct partial\_die\_info* orig\_pdi, char* info\_ptr, bfd* abfd, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & skip\_children() & dwarf2read.c & \cxreffunc{skip_children}{dwarf2read.c}\\
Called by:\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function lookup\_repository\_type()}
\label{func_lookup_repository_type_dwarf2read.c}

{\stt static void* lookup\_repository\_type ( int type\_id, sqlite3* db, struct dwarf2\_cu* cu, int return\_die )}

\smallskip
\begin{cxreftabiii}
Calls:\ & db\_lookup\_type() & dwarf2read.c & \cxreffunc{db_lookup_type}{dwarf2read.c}\\
\ & find\_open\_repository() & dwarf2read.c & \cxreffunc{find_open_repository}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & rb\_tree\_find\_node() & dwarf2read.c & \cxreffunc{rb_tree_find_node}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & rb\_tree\_insert() & dwarf2read.c & \cxreffunc{rb_tree_insert}{dwarf2read.c}\\
\ & tag\_type\_to\_type() & dwarf2read.c & \cxreffunc{tag_type_to_type}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & follow\_db\_ref() & dwarf2read.c & \cxreffunc{follow_db_ref}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function macro\_start\_file()}
\label{func_macro_start_file_dwarf2read.c}

{\stt static struct macro\_source\_file* macro\_start\_file ( int file, int line, struct macro\_source\_file* current\_file, const char* comp\_dir, struct line\_header* lh, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Calls:\ & file\_full\_name() & dwarf2read.c & \cxreffunc{file_full_name}{dwarf2read.c}\\
\ & macro\_include() & macrotab.c & \cxreffunc{macro_include}{macrotab.c}\\
\ & macro\_set\_main() & macrotab.c & \cxreffunc{macro_set_main}{macrotab.c}\\
\ & new\_macro\_table() & macrotab.c & \cxreffunc{new_macro_table}{macrotab.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & dwarf\_decode\_macros() & dwarf2read.c & \cxreffunc{dwarf_decode_macros}{dwarf2read.c}\\
Refs Var:\ & pending\_macros & buildsym.c & \cxrefvar{pending_macros}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function namespace\_name()}
\label{func_namespace_name_dwarf2read.c}

{\stt static const char* namespace\_name ( struct die\_info* die, int* is\_anonymous, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_extension() & dwarf2read.c & \cxreffunc{dwarf2_extension}{dwarf2read.c}\\
\ & dwarf2\_name() & dwarf2read.c & \cxreffunc{dwarf2_name}{dwarf2read.c}\\
Called by:\ & determine\_prefix() & dwarf2read.c & \cxreffunc{determine_prefix}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_namespace() & dwarf2read.c & \cxreffunc{read_namespace}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_symbol()}
\label{func_new_symbol_dwarf2read.c}

{\stt static struct symbol* new\_symbol ( struct die\_info* die, struct type* type, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_symbol\_to\_list() & buildsym.c & \cxreffunc{add_symbol_to_list}{buildsym.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_const\_value() & dwarf2read.c & \cxreffunc{dwarf2_const_value}{dwarf2read.c}\\
\ & dwarf2\_linkage\_name() & dwarf2read.c & \cxreffunc{dwarf2_linkage_name}{dwarf2read.c}\\
\ & dwarf\_tag\_name() & dwarf2read.c & \cxreffunc{dwarf_tag_name}{dwarf2read.c}\\
\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
\ & gdbarch\_int\_bit() & gdbarch.c & \cxreffunc{gdbarch_int_bit}{gdbarch.c}\\
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & symbol\_search\_name() & symtab.c & \cxreffunc{symbol_search_name}{symtab.c}\\
\ & symbol\_set\_names() & symtab.c & \cxreffunc{symbol_set_names}{symtab.c}\\
\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
\ & typename\_concat() & dwarf2read.c & \cxreffunc{typename_concat}{dwarf2read.c}\\
\ & var\_decode\_location() & dwarf2read.c & \cxreffunc{var_decode_location}{dwarf2read.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk(), strlen()} &\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & process\_enumeration\_scope() & dwarf2read.c & \cxreffunc{process_enumeration_scope}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_structure\_scope() & dwarf2read.c & \cxreffunc{process_structure_scope}{dwarf2read.c}\\
\ & read\_common\_block() & dwarf2read.c & \cxreffunc{read_common_block}{dwarf2read.c}\\
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\ & read\_namespace() & dwarf2read.c & \cxreffunc{read_namespace}{dwarf2read.c}\\
\ & read\_tag\_pointer\_type() & dwarf2read.c & \cxreffunc{read_tag_pointer_type}{dwarf2read.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & file\_symbols & buildsym.c & \cxrefvar{file_symbols}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\ & global\_symbols & buildsym.c & \cxrefvar{global_symbols}{buildsym.c}\\
\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\ & processing\_has\_namespace\_info & cp-namespace.c & \cxrefvar{processing_has_namespace_info}{cp-namespace.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function num\_nodes\_in\_tree()}
\label{func_num_nodes_in_tree_dwarf2read.c}

{\stt static int num\_nodes\_in\_tree ( struct rb\_tree\_node* tree )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & num\_nodes\_in\_tree() & dwarf2read.c & \cxreffunc{num_nodes_in_tree}{dwarf2read.c}\\
Called by:\ & num\_nodes\_in\_tree() & dwarf2read.c & \cxreffunc{num_nodes_in_tree}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function offset\_and\_type\_eq()}
\label{func_offset_and_type_eq_dwarf2read.c}

{\stt static int offset\_and\_type\_eq ( const void* item\_lhs, const void* item\_rhs )}

\smallskip
\begin{cxreftabiii}
Used in:\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function offset\_and\_type\_hash()}
\label{func_offset_and_type_hash_dwarf2read.c}

{\stt static hashval\_t offset\_and\_type\_hash ( const void* item )}

\smallskip
\begin{cxreftabiii}
Used in:\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function open\_dwarf\_repository()}
\label{func_open_dwarf_repository_dwarf2read.c}

{\stt static int open\_dwarf\_repository ( char* dirname, char* filename, struct objfile* objfile, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & build\_dummy\_cu() & dwarf2read.c & \cxreffunc{build_dummy_cu}{dwarf2read.c}\\
\ & build\_dummy\_objfile() & dwarf2read.c & \cxreffunc{build_dummy_objfile}{dwarf2read.c}\\
\ & db\_error() & dwarf2read.c & \cxreffunc{db_error}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & increment\_use\_count() & dwarf2read.c & \cxreffunc{increment_use_count}{dwarf2read.c}\\
\ & initialize\_repositories() & dwarf2read.c & \cxreffunc{initialize_repositories}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), sqlite3\_open(), strcmp(), strlen()} &\\
Called by:\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
Refs Var:\ & num\_open\_dbs & dwarf2read.c & \cxrefvar{num_open_dbs}{dwarf2read.c}\\
\ & repositories & dwarf2read.c & \cxrefvar{repositories}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function parse\_macro\_definition()}
\label{func_parse_macro_definition_dwarf2read.c}

{\stt static void parse\_macro\_definition ( struct macro\_source\_file* file, int line, const char* body )}

\smallskip
\begin{cxreftabiii}
Calls:\ & consume\_improper\_spaces() & dwarf2read.c & \cxreffunc{consume_improper_spaces}{dwarf2read.c}\\
\ & copy\_string() & dwarf2read.c & \cxreffunc{copy_string}{dwarf2read.c}\\
\ & dwarf2\_macro\_malformed\_definition\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_macro_malformed_definition_complaint}{dwarf2read.c}\\
\ & macro\_define\_function() & macrotab.c & \cxreffunc{macro_define_function}{macrotab.c}\\
\cxreftabbreak{cxreftabiii}
\ & macro\_define\_object() & macrotab.c & \cxreffunc{macro_define_object}{macrotab.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
Called by:\ & dwarf\_decode\_macros() & dwarf2read.c & \cxreffunc{dwarf_decode_macros}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function partial\_die\_eq()}
\label{func_partial_die_eq_dwarf2read.c}

{\stt static int partial\_die\_eq ( const void* item\_lhs, const void* item\_rhs )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function partial\_die\_full\_name()}
\label{func_partial_die_full_name_dwarf2read.c}

{\stt static char* partial\_die\_full\_name ( struct partial\_die\_info* pdi, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & partial\_die\_parent\_scope() & dwarf2read.c & \cxreffunc{partial_die_parent_scope}{dwarf2read.c}\\
\ & typename\_concat() & dwarf2read.c & \cxreffunc{typename_concat}{dwarf2read.c}\\
Called by:\ & add\_partial\_symbol() & dwarf2read.c & \cxreffunc{add_partial_symbol}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function partial\_die\_hash()}
\label{func_partial_die_hash_dwarf2read.c}

{\stt static hashval\_t partial\_die\_hash ( const void* item )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Used in:\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function partial\_die\_parent\_scope()}
\label{func_partial_die_parent_scope_dwarf2read.c}

{\stt static const char* partial\_die\_parent\_scope ( struct partial\_die\_info* pdi, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & find\_partial\_die() & dwarf2read.c & \cxreffunc{find_partial_die}{dwarf2read.c}\\
\ & fixup\_partial\_die() & dwarf2read.c & \cxreffunc{fixup_partial_die}{dwarf2read.c}\\
\ & partial\_die\_parent\_scope() & dwarf2read.c & \cxreffunc{partial_die_parent_scope}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & typename\_concat() & dwarf2read.c & \cxreffunc{typename_concat}{dwarf2read.c}\\
Called by:\ & partial\_die\_full\_name() & dwarf2read.c & \cxreffunc{partial_die_full_name}{dwarf2read.c}\\
\ & partial\_die\_parent\_scope() & dwarf2read.c & \cxreffunc{partial_die_parent_scope}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function partial\_read\_comp\_unit\_head()}
\label{func_partial_read_comp_unit_head_dwarf2read.c}

{\stt static char* partial\_read\_comp\_unit\_head ( struct comp\_unit\_head* header, char* info\_ptr, bfd* abfd )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{read_comp_unit_head}{dwarf2read.c}\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & find\_debug\_info\_for\_pst() & dwarf2read.c & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & load\_comp\_unit() & dwarf2read.c & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function pdi\_needs\_namespace()}
\label{func_pdi_needs_namespace_dwarf2read.c}

{\stt static int pdi\_needs\_namespace ( enum dwarf\_tag tag )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & add\_partial\_symbol() & dwarf2read.c & \cxreffunc{add_partial_symbol}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function peek\_die\_abbrev()}
\label{func_peek_die_abbrev_dwarf2read.c}

{\stt static struct abbrev\_info* peek\_die\_abbrev ( char* info\_ptr, int* bytes\_read, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_lookup\_abbrev() & dwarf2read.c & \cxreffunc{dwarf2_lookup_abbrev}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & find\_debug\_info\_for\_pst() & dwarf2read.c & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\ & load\_comp\_unit() & dwarf2read.c & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\ & skip\_children() & dwarf2read.c & \cxreffunc{skip_children}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function plain\_tree\_insert()}
\label{func_plain_tree_insert_dwarf2read.c}

{\stt static void plain\_tree\_insert ( struct rb\_tree\_node** root, struct rb\_tree\_node* new\_node )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & plain\_tree\_insert() & dwarf2read.c & \cxreffunc{plain_tree_insert}{dwarf2read.c}\\
Called by:\ & plain\_tree\_insert() & dwarf2read.c & \cxreffunc{plain_tree_insert}{dwarf2read.c}\\
\ & rb\_tree\_insert() & dwarf2read.c & \cxreffunc{rb_tree_insert}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function process\_die()}
\label{func_process_die_dwarf2read.c}

{\stt static void process\_die ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & process\_enumeration\_scope() & dwarf2read.c & \cxreffunc{process_enumeration_scope}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_structure\_scope() & dwarf2read.c & \cxreffunc{process_structure_scope}{dwarf2read.c}\\
\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\ & read\_base\_type() & dwarf2read.c & \cxreffunc{read_base_type}{dwarf2read.c}\\
\ & read\_common\_block() & dwarf2read.c & \cxreffunc{read_common_block}{dwarf2read.c}\\
\ & read\_enumeration\_type() & dwarf2read.c & \cxreffunc{read_enumeration_type}{dwarf2read.c}\\
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_lexical\_block\_scope() & dwarf2read.c & \cxreffunc{read_lexical_block_scope}{dwarf2read.c}\\
\ & read\_namespace() & dwarf2read.c & \cxreffunc{read_namespace}{dwarf2read.c}\\
\ & read\_set\_type() & dwarf2read.c & \cxreffunc{read_set_type}{dwarf2read.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\ & read\_subrange\_type() & dwarf2read.c & \cxreffunc{read_subrange_type}{dwarf2read.c}\\
\ & read\_subroutine\_type() & dwarf2read.c & \cxreffunc{read_subroutine_type}{dwarf2read.c}\\
\ & read\_tag\_pointer\_type() & dwarf2read.c & \cxreffunc{read_tag_pointer_type}{dwarf2read.c}\\
\ & read\_tag\_ptr\_to\_member\_type() & dwarf2read.c & \cxreffunc{read_tag_ptr_to_member_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_tag\_reference\_type() & dwarf2read.c & \cxreffunc{read_tag_reference_type}{dwarf2read.c}\\
\ & read\_tag\_string\_type() & dwarf2read.c & \cxreffunc{read_tag_string_type}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\ & read\_typedef() & dwarf2read.c & \cxreffunc{read_typedef}{dwarf2read.c}\\
Called by:\ & process\_enumeration\_scope() & dwarf2read.c & \cxreffunc{process_enumeration_scope}{dwarf2read.c}\\
\ & process\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{process_full_comp_unit}{dwarf2read.c}\\
\ & process\_structure\_scope() & dwarf2read.c & \cxreffunc{process_structure_scope}{dwarf2read.c}\\
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\ & read\_lexical\_block\_scope() & dwarf2read.c & \cxreffunc{read_lexical_block_scope}{dwarf2read.c}\\
\ & read\_namespace() & dwarf2read.c & \cxreffunc{read_namespace}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_allow\_inlined\_stepping & dwarf2read.c & \cxrefvar{dwarf2_allow_inlined_stepping}{dwarf2read.c}\\
\ & processing\_has\_namespace\_info & cp-namespace.c & \cxrefvar{processing_has_namespace_info}{cp-namespace.c}\\
\end{cxreftabiii}


\subsubsection{Local Function process\_enumeration\_scope()}
\label{func_process_enumeration_scope_dwarf2read.c}

{\stt static void process\_enumeration\_scope ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function process\_full\_comp\_unit()}
\label{func_process_full_comp_unit_dwarf2read.c}

{\stt static void process\_full\_comp\_unit ( struct dwarf2\_per\_cu\_data* per\_cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & buildsym\_init() & buildsym.c & \cxreffunc{buildsym_init}{buildsym.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & end\_symtab() & buildsym.c & \cxreffunc{end_symtab}{buildsym.c}\\
\ & executable\_objfile() & objfiles.c & \cxreffunc{executable_objfile}{objfiles.c}\\
\ & fix\_inlined\_subroutine\_symbols() & dwarf2read.c & \cxreffunc{fix_inlined_subroutine_symbols}{dwarf2read.c}\\
\ & get\_scope\_pc\_bounds() & dwarf2read.c & \cxreffunc{get_scope_pc_bounds}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_kext\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
\ & process\_queue() & dwarf2read.c & \cxreffunc{process_queue}{dwarf2read.c}\\
Refs Func:\ & really\_free\_pendings() & buildsym.c & \cxreffunc{really_free_pendings}{buildsym.c}\\
Refs Var:\ & file\_symbols & buildsym.c & \cxrefvar{file_symbols}{buildsym.c}\\
\ & inlined\_subroutine\_symbols & dwarf2read.c & \cxrefvar{inlined_subroutine_symbols}{dwarf2read.c}\\
\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\end{cxreftabiii}


\subsubsection{Local Function process\_queue()}
\label{func_process_queue_dwarf2read.c}

{\stt static void process\_queue ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Calls:\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
\ & process\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{process_full_comp_unit}{dwarf2read.c}\\
\ & reset\_die\_and\_siblings\_types() & dwarf2read.c & \cxreffunc{reset_die_and_siblings_types}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & psymtab\_to\_symtab\_1() & dwarf2read.c & \cxreffunc{psymtab_to_symtab_1}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & dwarf2\_queue & dwarf2read.c & \cxrefvar{dwarf2_queue}{dwarf2read.c}\\
\ & dwarf2\_queue\_tail & dwarf2read.c & \cxrefvar{dwarf2_queue_tail}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function process\_structure\_scope()}
\label{func_process_structure_scope_dwarf2read.c}

{\stt static void process\_structure\_scope ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & die\_is\_declaration() & dwarf2read.c & \cxreffunc{die_is_declaration}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
Refs Var:\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\end{cxreftabiii}


\subsubsection{Local Function psymtab\_to\_symtab\_1()}
\label{func_psymtab_to_symtab_1_dwarf2read.c}

{\stt static void psymtab\_to\_symtab\_1 ( struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & age\_cached\_comp\_units() & dwarf2read.c & \cxreffunc{age_cached_comp_units}{dwarf2read.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & fputs\_filtered() & utils.c & \cxreffunc{fputs_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & process\_queue() & dwarf2read.c & \cxreffunc{process_queue}{dwarf2read.c}\\
\ & psymtab\_to\_symtab\_1() & dwarf2read.c & \cxreffunc{psymtab_to_symtab_1}{dwarf2read.c}\\
\ & queue\_comp\_unit() & dwarf2read.c & \cxreffunc{queue_comp_unit}{dwarf2read.c}\\
\ & wrap\_here() & utils.c & \cxreffunc{wrap_here}{utils.c}\\
Called by:\ & dwarf2\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_psymtab_to_symtab}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & psymtab\_to\_symtab\_1() & dwarf2read.c & \cxreffunc{psymtab_to_symtab_1}{dwarf2read.c}\\
Refs Func:\ & dwarf2\_release\_queue() & dwarf2read.c & \cxreffunc{dwarf2_release_queue}{dwarf2read.c}\\
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function queue\_comp\_unit()}
\label{func_queue_comp_unit_dwarf2read.c}

{\stt static void queue\_comp\_unit ( struct dwarf2\_per\_cu\_data* per\_cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & psymtab\_to\_symtab\_1() & dwarf2read.c & \cxreffunc{psymtab_to_symtab_1}{dwarf2read.c}\\
\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_queue & dwarf2read.c & \cxrefvar{dwarf2_queue}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_queue\_tail & dwarf2read.c & \cxrefvar{dwarf2_queue_tail}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function rb\_delete\_fixup()}
\label{func_rb_delete_fixup_dwarf2read.c}

{\stt static void rb\_delete\_fixup ( struct rb\_tree\_node** root, struct rb\_tree\_node* x )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & left\_rotate() & dwarf2read.c & \cxreffunc{left_rotate}{dwarf2read.c}\\
\ & right\_rotate() & dwarf2read.c & \cxreffunc{right_rotate}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & rb\_tree\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_remove_node}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function rb\_print\_node()}
\label{func_rb_print_node_dwarf2read.c}

{\stt static void rb\_print\_node ( struct rb\_tree\_node* tree )}

\smallskip
\begin{cxreftabiii}
Calls:\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & \cxreftabiiispan{ fprintf()} &\\
Called by:\ & rb\_print\_tree() & dwarf2read.c & \cxreffunc{rb_print_tree}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function rb\_print\_tree()}
\label{func_rb_print_tree_dwarf2read.c}

{\stt static void rb\_print\_tree ( struct rb\_tree\_node* tree, int indent\_level )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & rb\_print\_node() & dwarf2read.c & \cxreffunc{rb_print_node}{dwarf2read.c}\\
\ & rb\_print\_tree() & dwarf2read.c & \cxreffunc{rb_print_tree}{dwarf2read.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), fprintf()} &\\
Called by:\ & rb\_print\_tree() & dwarf2read.c & \cxreffunc{rb_print_tree}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function rb\_tree\_find\_and\_remove\_node()}
\label{func_rb_tree_find_and_remove_node_dwarf2read.c}

{\stt static struct rb\_tree\_node* rb\_tree\_find\_and\_remove\_node ( struct rb\_tree\_node** root, struct rb\_tree\_node* cur\_node, long long key, int secondary\_key )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & rb\_tree\_find\_and\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_find_and_remove_node}{dwarf2read.c}\\
\ & rb\_tree\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_remove_node}{dwarf2read.c}\\
Called by:\ & check\_inlined\_function\_calls() & dwarf2read.c & \cxreffunc{check_inlined_function_calls}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & rb\_tree\_find\_and\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_find_and_remove_node}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function rb\_tree\_minimum()}
\label{func_rb_tree_minimum_dwarf2read.c}

{\stt static struct rb\_tree\_node* rb\_tree\_minimum ( struct rb\_tree\_node* node )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & rb\_tree\_successor() & dwarf2read.c & \cxreffunc{rb_tree_successor}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function rb\_tree\_remove\_node()}
\label{func_rb_tree_remove_node_dwarf2read.c}

{\stt static struct rb\_tree\_node* rb\_tree\_remove\_node ( struct rb\_tree\_node** root, struct rb\_tree\_node* node )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & left\_rotate() & dwarf2read.c & \cxreffunc{left_rotate}{dwarf2read.c}\\
\ & rb\_delete\_fixup() & dwarf2read.c & \cxreffunc{rb_delete_fixup}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & rb\_tree\_successor() & dwarf2read.c & \cxreffunc{rb_tree_successor}{dwarf2read.c}\\
\ & right\_rotate() & dwarf2read.c & \cxreffunc{right_rotate}{dwarf2read.c}\\
\ & verify\_rb\_tree() & dwarf2read.c & \cxreffunc{verify_rb_tree}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & rb\_tree\_find\_and\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_find_and_remove_node}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_debug\_inlined\_stepping & dwarf2read.c & \cxrefvar{dwarf2_debug_inlined_stepping}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function rb\_tree\_successor()}
\label{func_rb_tree_successor_dwarf2read.c}

{\stt static struct rb\_tree\_node* rb\_tree\_successor ( struct rb\_tree\_node* node )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & rb\_tree\_minimum() & dwarf2read.c & \cxreffunc{rb_tree_minimum}{dwarf2read.c}\\
Called by:\ & rb\_tree\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_remove_node}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_1\_byte()}
\label{func_read_1_byte_dwarf2read.c}

{\stt static unsigned int read\_1\_byte ( bfd* abfd, char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & dwarf2\_read\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_scan\_inlined\_section\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_inlined_section_for_psymbols}{dwarf2read.c}\\
\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\ & dwarf\_decode\_macros() & dwarf2read.c & \cxreffunc{dwarf_decode_macros}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{read_comp_unit_head}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function read\_1\_signed\_byte()}
\label{func_read_1_signed_byte_dwarf2read.c}

{\stt static int read\_1\_signed\_byte ( bfd* abfd, char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_2\_bytes()}
\label{func_read_2_bytes_dwarf2read.c}

{\stt static unsigned int read\_2\_bytes ( bfd* abfd, char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & dwarf2\_scan\_inlined\_section\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_inlined_section_for_psymbols}{dwarf2read.c}\\
\ & dwarf2\_scan\_pubtype\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_pubtype_for_psymbols}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{read_comp_unit_head}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_2\_signed\_bytes()}
\label{func_read_2_signed_bytes_dwarf2read.c}

{\stt static int read\_2\_signed\_bytes ( bfd* abfd, char* buf )}

\smallskip
\begin{cxreftabiii}
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_4\_bytes()}
\label{func_read_4_bytes_dwarf2read.c}

{\stt static unsigned int read\_4\_bytes ( bfd* abfd, char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function read\_4\_signed\_bytes()}
\label{func_read_4_signed_bytes_dwarf2read.c}

{\stt static int read\_4\_signed\_bytes ( bfd* abfd, char* buf )}

\smallskip
\begin{cxreftabiii}
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_8\_bytes()}
\label{func_read_8_bytes_dwarf2read.c}

{\stt static unsigned long read\_8\_bytes ( bfd* abfd, char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_address()}
\label{func_read_address_dwarf2read.c}

{\stt static CORE\_ADDR read\_address ( bfd* abfd, char* buf, struct dwarf2\_cu* cu, int* bytes\_read )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & dwarf2\_get\_pc\_bounds() & dwarf2read.c & \cxreffunc{dwarf2_get_pc_bounds}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_scan\_inlined\_section\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_inlined_section_for_psymbols}{dwarf2read.c}\\
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
\ & var\_decode\_location() & dwarf2read.c & \cxreffunc{var_decode_location}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_array\_order()}
\label{func_read_array_order_dwarf2read.c}

{\stt static enum dwarf\_array\_dim\_ordering read\_array\_order ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & \cxreftabiiispan{ strstr()} &\\
Called by:\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_array\_type()}
\label{func_read_array_type_dwarf2read.c}

{\stt static void read\_array\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_fundamental\_type() & dwarf2read.c & \cxreffunc{dwarf2_fundamental_type}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & read\_array\_order() & dwarf2read.c & \cxreffunc{read_array_order}{dwarf2read.c}\\
\ & read\_subrange\_type() & dwarf2read.c & \cxreffunc{read_subrange_type}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
Refs Func:\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_attribute()}
\label{func_read_attribute_dwarf2read.c}

{\stt static char* read\_attribute ( struct attribute* attr, struct attr\_abbrev* abbrev, bfd* abfd, char* info\_ptr, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
Called by:\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
\ & read\_partial\_die() & dwarf2read.c & \cxreffunc{read_partial_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_attribute\_value()}
\label{func_read_attribute_value_dwarf2read.c}

{\stt static char* read\_attribute\_value ( struct attribute* attr, unsigned form, bfd* abfd, char* info\_ptr, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf\_alloc\_block() & dwarf2read.c & \cxreffunc{dwarf_alloc_block}{dwarf2read.c}\\
\ & dwarf\_form\_name() & dwarf2read.c & \cxreffunc{dwarf_form_name}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_4\_bytes() & dwarf2read.c & \cxreffunc{read_4_bytes}{dwarf2read.c}\\
\ & read\_8\_bytes() & dwarf2read.c & \cxreffunc{read_8_bytes}{dwarf2read.c}\\
\ & read\_address() & dwarf2read.c & \cxreffunc{read_address}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & read\_indirect\_string() & dwarf2read.c & \cxreffunc{read_indirect_string}{dwarf2read.c}\\
\ & read\_n\_bytes() & dwarf2read.c & \cxreffunc{read_n_bytes}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_signed\_leb128() & dwarf2read.c & \cxreffunc{read_signed_leb128}{dwarf2read.c}\\
\ & read\_string() & dwarf2read.c & \cxreffunc{read_string}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
Called by:\ & read\_attribute() & dwarf2read.c & \cxreffunc{read_attribute}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_base\_type()}
\label{func_read_base_type_dwarf2read.c}

{\stt static void read\_base\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_fundamental\_type() & dwarf2read.c & \cxreffunc{dwarf2_fundamental_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_base\_type() & dwarf2read.c & \cxreffunc{dwarf_base_type}{dwarf2read.c}\\
\ & dwarf\_type\_encoding\_name() & dwarf2read.c & \cxreffunc{dwarf_type_encoding_name}{dwarf2read.c}\\
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_common\_block()}
\label{func_read_common_block_dwarf2read.c}

{\stt static void read\_common\_block ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_symbol\_to\_list() & buildsym.c & \cxreffunc{add_symbol_to_list}{buildsym.c}\\
\ & attr\_form\_is\_block() & dwarf2read.c & \cxreffunc{attr_form_is_block}{dwarf2read.c}\\
\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_complex\_location\_expr\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_complex_location_expr_complaint}{dwarf2read.c}\\
\ & dwarf2\_invalid\_attrib\_class\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_invalid_attrib_class_complaint}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
Refs Var:\ & decode\_locdesc\_common & dwarf2read.c & \cxrefvar{decode_locdesc_common}{dwarf2read.c}\\
\ & global\_symbols & buildsym.c & \cxrefvar{global_symbols}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function read\_comp\_unit()}
\label{func_read_comp_unit_dwarf2read.c}

{\stt static struct die\_info* read\_comp\_unit ( char* info\_ptr, bfd* abfd, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & read\_die\_and\_children() & dwarf2read.c & \cxreffunc{read_die_and_children}{dwarf2read.c}\\
Called by:\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_comp\_unit\_head()}
\label{func_read_comp_unit_head_dwarf2read.c}

{\stt static char* read\_comp\_unit\_head ( struct comp\_unit\_head* cu\_header, char* info\_ptr, bfd* abfd )}

\smallskip
\begin{cxreftabiii}
Calls:\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_initial\_length() & dwarf2read.c & \cxreffunc{read_initial_length}{dwarf2read.c}\\
\ & read\_offset() & dwarf2read.c & \cxreffunc{read_offset}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
\ & partial\_read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{partial_read_comp_unit_head}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_die\_and\_children()}
\label{func_read_die_and_children_dwarf2read.c}

{\stt static struct die\_info* read\_die\_and\_children ( char* info\_ptr, bfd* abfd, struct dwarf2\_cu* cu, char** new\_info\_ptr, struct die\_info* parent )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & read\_die\_and\_siblings() & dwarf2read.c & \cxreffunc{read_die_and_siblings}{dwarf2read.c}\\
\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
\ & store\_in\_ref\_table() & dwarf2read.c & \cxreffunc{store_in_ref_table}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & read\_comp\_unit() & dwarf2read.c & \cxreffunc{read_comp_unit}{dwarf2read.c}\\
\ & read\_die\_and\_siblings() & dwarf2read.c & \cxreffunc{read_die_and_siblings}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_die\_and\_siblings()}
\label{func_read_die_and_siblings_dwarf2read.c}

{\stt static struct die\_info* read\_die\_and\_siblings ( char* info\_ptr, bfd* abfd, struct dwarf2\_cu* cu, char** new\_info\_ptr, struct die\_info* parent )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & read\_die\_and\_children() & dwarf2read.c & \cxreffunc{read_die_and_children}{dwarf2read.c}\\
Called by:\ & read\_die\_and\_children() & dwarf2read.c & \cxreffunc{read_die_and_children}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_enumeration\_type()}
\label{func_read_enumeration_type_dwarf2read.c}

{\stt static void read\_enumeration\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & typename\_concat() & dwarf2read.c & \cxreffunc{typename_concat}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
Refs Var:\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\ & processing\_has\_namespace\_info & cp-namespace.c & \cxrefvar{processing_has_namespace_info}{cp-namespace.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_file\_scope()}
\label{func_read_file_scope_dwarf2read.c}

{\stt static void read\_file\_scope ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\ & dwarf\_decode\_macros() & dwarf2read.c & \cxreffunc{dwarf_decode_macros}{dwarf2read.c}\\
\ & get\_scope\_pc\_bounds() & dwarf2read.c & \cxreffunc{get_scope_pc_bounds}{dwarf2read.c}\\
\ & initialize\_cu\_func\_list() & dwarf2read.c & \cxreffunc{initialize_cu_func_list}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & record\_debugformat() & buildsym.c & \cxreffunc{record_debugformat}{buildsym.c}\\
\ & record\_producer() & buildsym.c & \cxreffunc{record_producer}{buildsym.c}\\
\ & set\_cu\_language() & dwarf2read.c & \cxreffunc{set_cu_language}{dwarf2read.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
\ & start\_symtab() & buildsym.c & \cxreffunc{start_symtab}{buildsym.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), strchr()} &\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
Refs Func:\ & free\_line\_header() & dwarf2read.c & \cxreffunc{free_line_header}{dwarf2read.c}\\
\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & processing\_gcc\_compilation & buildsym.c & \cxrefvar{processing_gcc_compilation}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_full\_die()}
\label{func_read_full_die_dwarf2read.c}

{\stt static char* read\_full\_die ( struct die\_info** diep, bfd* abfd, char* info\_ptr, struct dwarf2\_cu* cu, int* has\_children )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_add\_dependence() & dwarf2read.c & \cxreffunc{dwarf2_add_dependence}{dwarf2read.c}\\
\ & dwarf2\_find\_containing\_comp\_unit() & dwarf2read.c & \cxreffunc{dwarf2_find_containing_comp_unit}{dwarf2read.c}\\
\ & dwarf2\_lookup\_abbrev() & dwarf2read.c & \cxreffunc{dwarf2_lookup_abbrev}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_alloc\_die() & dwarf2read.c & \cxreffunc{dwarf_alloc_die}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
\ & queue\_comp\_unit() & dwarf2read.c & \cxreffunc{queue_comp_unit}{dwarf2read.c}\\
\ & read\_attribute() & dwarf2read.c & \cxreffunc{read_attribute}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & read\_die\_and\_children() & dwarf2read.c & \cxreffunc{read_die_and_children}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_func\_scope()}
\label{func_read_func_scope_dwarf2read.c}

{\stt static void read\_func\_scope ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_to\_cu\_func\_list() & dwarf2read.c & \cxreffunc{add_to_cu_func_list}{dwarf2read.c}\\
\ & determine\_prefix() & dwarf2read.c & \cxreffunc{determine_prefix}{dwarf2read.c}\\
\ & die\_specification() & dwarf2read.c & \cxreffunc{die_specification}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_get\_pc\_bounds() & dwarf2read.c & \cxreffunc{dwarf2_get_pc_bounds}{dwarf2read.c}\\
\ & dwarf2\_linkage\_name() & dwarf2read.c & \cxreffunc{dwarf2_linkage_name}{dwarf2read.c}\\
\ & dwarf2\_symbol\_mark\_computed() & dwarf2read.c & \cxreffunc{dwarf2_symbol_mark_computed}{dwarf2read.c}\\
\ & finish\_block() & buildsym.c & \cxreffunc{finish_block}{buildsym.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & pop\_context() & buildsym.c & \cxreffunc{pop_context}{buildsym.c}\\
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & push\_context() & buildsym.c & \cxreffunc{push_context}{buildsym.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & context\_stack\_depth & buildsym.c & \cxrefvar{context_stack_depth}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\ & file\_symbols & buildsym.c & \cxrefvar{file_symbols}{buildsym.c}\\
\ & local\_symbols & buildsym.c & \cxrefvar{local_symbols}{buildsym.c}\\
\ & param\_symbols & buildsym.c & \cxrefvar{param_symbols}{buildsym.c}\\
\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_in\_db\_abbrev\_table()}
\label{func_read_in_db_abbrev_table_dwarf2read.c}

{\stt static void read\_in\_db\_abbrev\_table ( struct abbrev\_info** abbrev\_table, sqlite3* db )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & db\_error() & dwarf2read.c & \cxreffunc{db_error}{dwarf2read.c}\\
\ & get\_uleb128() & dwarf2read.c & \cxreffunc{get_uleb128}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), sqlite3\_column\_blob(), sqlite3\_column\_bytes(), sqlite3\_column\_int(), sqlite3\_finalize(), sqlite3\_prepare\_v2(), sqlite3\_step(), strlen()} &\\
Called by:\ & dwarf2\_read\_repository\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_repository_abbrevs}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_indirect\_string()}
\label{func_read_indirect_string_dwarf2read.c}

{\stt static char* read\_indirect\_string ( bfd* abfd, char* buf, const struct comp\_unit\_head* cu\_header, unsigned int* bytes\_read\_ptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & read\_offset() & dwarf2read.c & \cxreffunc{read_offset}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_initial\_length()}
\label{func_read_initial_length_dwarf2read.c}

{\stt static long read\_initial\_length ( bfd* abfd, char* buf, struct comp\_unit\_head* cu\_header, int* bytes\_read )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & create\_all\_comp\_units() & dwarf2read.c & \cxreffunc{create_all_comp_units}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_debug\_map\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_debug_map_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_kext\_psymtab\_to\_symtab() & dwarf2read.c & \cxreffunc{dwarf2_kext_psymtab_to_symtab}{dwarf2read.c}\\
\ & dwarf2\_scan\_inlined\_section\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_inlined_section_for_psymbols}{dwarf2read.c}\\
\ & dwarf2\_scan\_pubtype\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_pubtype_for_psymbols}{dwarf2read.c}\\
\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\ & read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{read_comp_unit_head}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function read\_inlined\_subroutine\_scope()}
\label{func_read_inlined_subroutine_scope_dwarf2read.c}

{\stt static void read\_inlined\_subroutine\_scope ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_symbol\_to\_inlined\_subroutine\_list() & inlining.c & \cxreffunc{add_symbol_to_inlined_subroutine_list}{inlining.c}\\
\ & dwarf2\_add\_to\_list\_of\_inlined\_calls() & dwarf2read.c & \cxreffunc{dwarf2_add_to_list_of_inlined_calls}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_get\_pc\_bounds() & dwarf2read.c & \cxreffunc{dwarf2_get_pc_bounds}{dwarf2read.c}\\
\ & dwarf2\_linkage\_name() & dwarf2read.c & \cxreffunc{dwarf2_linkage_name}{dwarf2read.c}\\
\ & finish\_block() & buildsym.c & \cxreffunc{finish_block}{buildsym.c}\\
\ & follow\_die\_ref() & dwarf2read.c & \cxreffunc{follow_die_ref}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\ & pop\_context() & buildsym.c & \cxreffunc{pop_context}{buildsym.c}\\
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & push\_context() & buildsym.c & \cxreffunc{push_context}{buildsym.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
Refs Var:\ & inlined\_subroutine\_symbols & dwarf2read.c & \cxrefvar{inlined_subroutine_symbols}{dwarf2read.c}\\
\ & local\_symbols & buildsym.c & \cxrefvar{local_symbols}{buildsym.c}\\
\ & param\_symbols & buildsym.c & \cxrefvar{param_symbols}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_lexical\_block\_scope()}
\label{func_read_lexical_block_scope_dwarf2read.c}

{\stt static void read\_lexical\_block\_scope ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dwarf2\_get\_pc\_bounds() & dwarf2read.c & \cxreffunc{dwarf2_get_pc_bounds}{dwarf2read.c}\\
\ & finish\_block() & buildsym.c & \cxreffunc{finish_block}{buildsym.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & pop\_context() & buildsym.c & \cxreffunc{pop_context}{buildsym.c}\\
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & push\_context() & buildsym.c & \cxreffunc{push_context}{buildsym.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
Refs Var:\ & local\_symbols & buildsym.c & \cxrefvar{local_symbols}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_n\_bytes()}
\label{func_read_n_bytes_dwarf2read.c}

{\stt static char* read\_n\_bytes ( bfd* abfd, char* buf, unsigned int size )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_namespace()}
\label{func_read_namespace_dwarf2read.c}

{\stt static void read\_namespace ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & cp\_add\_using\_directive() & cp-namespace.c & \cxreffunc{cp_add_using_directive}{cp-namespace.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_extension() & dwarf2read.c & \cxreffunc{dwarf2_extension}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & namespace\_name() & dwarf2read.c & \cxreffunc{namespace_name}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
\ & typename\_concat() & dwarf2read.c & \cxreffunc{typename_concat}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
Refs Func:\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_offset()}
\label{func_read_offset_dwarf2read.c}

{\stt static long read\_offset ( bfd* abfd, char* buf, const struct comp\_unit\_head* cu\_header, int* bytes\_read )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & dwarf2\_scan\_inlined\_section\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_inlined_section_for_psymbols}{dwarf2read.c}\\
\ & dwarf2\_scan\_pubtype\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_pubtype_for_psymbols}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\ & read\_comp\_unit\_head() & dwarf2read.c & \cxreffunc{read_comp_unit_head}{dwarf2read.c}\\
\ & read\_indirect\_string() & dwarf2read.c & \cxreffunc{read_indirect_string}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_partial\_die()}
\label{func_read_partial_die_dwarf2read.c}

{\stt static char* read\_partial\_die ( struct partial\_die\_info* part\_die, struct abbrev\_info* abbrev, unsigned int abbrev\_len, bfd* abfd, char* info\_ptr, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & attr\_form\_is\_block() & dwarf2read.c & \cxreffunc{attr_form_is_block}{dwarf2read.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_complex\_location\_expr\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_complex_location_expr_complaint}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_get\_ref\_die\_offset() & dwarf2read.c & \cxreffunc{dwarf2_get_ref_die_offset}{dwarf2read.c}\\
\ & dwarf2\_invalid\_attrib\_class\_complaint() & dwarf2read.c & \cxreffunc{dwarf2_invalid_attrib_class_complaint}{dwarf2read.c}\\
\ & get\_repository\_name() & dwarf2read.c & \cxreffunc{get_repository_name}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & open\_dwarf\_repository() & dwarf2read.c & \cxreffunc{open_dwarf_repository}{dwarf2read.c}\\
\ & read\_attribute() & dwarf2read.c & \cxreffunc{read_attribute}{dwarf2read.c}\\
\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), isdigit(), isupper(), strchr(), strlen(), xstrdup()} &\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_debug\_info\_for\_pst() & dwarf2read.c & \cxreffunc{find_debug_info_for_pst}{dwarf2read.c}\\
\ & load\_comp\_unit() & dwarf2read.c & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & psym\_equivalences & dwarf2read.c & \cxrefvar{psym_equivalences}{dwarf2read.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_set\_type()}
\label{func_read_set_type_dwarf2read.c}

{\stt static void read\_set\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & create\_set\_type() & gdbtypes.c & \cxreffunc{create_set_type}{gdbtypes.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_signed\_leb128()}
\label{func_read_signed_leb128_dwarf2read.c}

{\stt static long read\_signed\_leb128 ( bfd* abfd, char* buf, unsigned int* bytes\_read\_ptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function read\_string()}
\label{func_read_string_dwarf2read.c}

{\stt static char* read\_string ( bfd* abfd, char* buf, unsigned int* bytes\_read\_ptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & dwarf2\_scan\_pubtype\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_pubtype_for_psymbols}{dwarf2read.c}\\
\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\ & dwarf\_decode\_macros() & dwarf2read.c & \cxreffunc{dwarf_decode_macros}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_structure\_type()}
\label{func_read_structure_type_dwarf2read.c}

{\stt static void read\_structure\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & allocate\_cplus\_struct\_type() & gdbtypes.c & \cxreffunc{allocate_cplus_struct_type}{gdbtypes.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & determine\_class\_name() & dwarf2read.c & \cxreffunc{determine_class_name}{dwarf2read.c}\\
\ & die\_containing\_type() & dwarf2read.c & \cxreffunc{die_containing_type}{dwarf2read.c}\\
\ & die\_is\_declaration() & dwarf2read.c & \cxreffunc{die_is_declaration}{dwarf2read.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dwarf2\_add\_field() & dwarf2read.c & \cxreffunc{dwarf2_add_field}{dwarf2read.c}\\
\ & dwarf2\_add\_member\_fn() & dwarf2read.c & \cxreffunc{dwarf2_add_member_fn}{dwarf2read.c}\\
\ & dwarf2\_attach\_fields\_to\_type() & dwarf2read.c & \cxreffunc{dwarf2_attach_fields_to_type}{dwarf2read.c}\\
\ & dwarf2\_attach\_fn\_fields\_to\_type() & dwarf2read.c & \cxreffunc{dwarf2_attach_fn_fields_to_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & is\_vtable\_name() & dwarf2read.c & \cxreffunc{is_vtable_name}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objc\_invalidate\_objc\_class() & objc-lang.c & \cxreffunc{objc_invalidate_objc_class}{objc-lang.c}\\
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), strcmp(), strlen()} &\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
Refs Func:\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_subrange\_type()}
\label{func_read_subrange_type_dwarf2read.c}

{\stt static void read\_subrange\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & dwarf2\_get\_attr\_constant\_value() & dwarf2read.c & \cxreffunc{dwarf2_get_attr_constant_value}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function read\_subroutine\_type()}
\label{func_read_subroutine_type_dwarf2read.c}

{\stt static void read\_subroutine\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & make\_function\_type() & gdbtypes.c & \cxreffunc{make_function_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\ & sibling\_die() & dwarf2read.c & \cxreffunc{sibling_die}{dwarf2read.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_const\_type()}
\label{func_read_tag_const_type_dwarf2read.c}

{\stt static void read\_tag\_const\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & make\_cvr\_type() & gdbtypes.c & \cxreffunc{make_cvr_type}{gdbtypes.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_pointer\_type()}
\label{func_read_tag_pointer_type_dwarf2read.c}

{\stt static void read\_tag\_pointer\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_address\_class\_type\_flags() & gdbarch.c & \cxreffunc{gdbarch_address_class_type_flags}{gdbarch.c}\\
\ & gdbarch\_address\_class\_type\_flags\_p() & gdbarch.c & \cxreffunc{gdbarch_address_class_type_flags_p}{gdbarch.c}\\
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & make\_pointer\_type() & gdbtypes.c & \cxreffunc{make_pointer_type}{gdbtypes.c}\\
\ & make\_type\_with\_address\_space() & gdbtypes.c & \cxreffunc{make_type_with_address_space}{gdbtypes.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_ptr\_to\_member\_type()}
\label{func_read_tag_ptr_to_member_type_dwarf2read.c}

{\stt static void read\_tag\_ptr\_to\_member\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & die\_containing\_type() & dwarf2read.c & \cxreffunc{die_containing_type}{dwarf2read.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\ & smash\_to\_member\_type() & gdbtypes.c & \cxreffunc{smash_to_member_type}{gdbtypes.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_reference\_type()}
\label{func_read_tag_reference_type_dwarf2read.c}

{\stt static void read\_tag\_reference\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_restrict\_type()}
\label{func_read_tag_restrict_type_dwarf2read.c}

{\stt static void read\_tag\_restrict\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & make\_cvr\_type() & gdbtypes.c & \cxreffunc{make_cvr_type}{gdbtypes.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_string\_type()}
\label{func_read_tag_string_type_dwarf2read.c}

{\stt static void read\_tag\_string\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & create\_string\_type() & gdbtypes.c & \cxreffunc{create_string_type}{gdbtypes.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2\_fundamental\_type() & dwarf2read.c & \cxreffunc{dwarf2_fundamental_type}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_unspecified\_type()}
\label{func_read_tag_unspecified_type_dwarf2read.c}

{\stt static void read\_tag\_unspecified\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_volatile\_type()}
\label{func_read_tag_volatile_type_dwarf2read.c}

{\stt static void read\_tag\_volatile\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & make\_cvr\_type() & gdbtypes.c & \cxreffunc{make_cvr_type}{gdbtypes.c}\\
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_type\_die()}
\label{func_read_type_die_dwarf2read.c}

{\stt static void read\_type\_die ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & determine\_prefix() & dwarf2read.c & \cxreffunc{determine_prefix}{dwarf2read.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_tag\_name() & dwarf2read.c & \cxreffunc{dwarf_tag_name}{dwarf2read.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\ & read\_base\_type() & dwarf2read.c & \cxreffunc{read_base_type}{dwarf2read.c}\\
\ & read\_enumeration\_type() & dwarf2read.c & \cxreffunc{read_enumeration_type}{dwarf2read.c}\\
\ & read\_set\_type() & dwarf2read.c & \cxreffunc{read_set_type}{dwarf2read.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\ & read\_subrange\_type() & dwarf2read.c & \cxreffunc{read_subrange_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_subroutine\_type() & dwarf2read.c & \cxreffunc{read_subroutine_type}{dwarf2read.c}\\
\ & read\_tag\_const\_type() & dwarf2read.c & \cxreffunc{read_tag_const_type}{dwarf2read.c}\\
\ & read\_tag\_pointer\_type() & dwarf2read.c & \cxreffunc{read_tag_pointer_type}{dwarf2read.c}\\
\ & read\_tag\_ptr\_to\_member\_type() & dwarf2read.c & \cxreffunc{read_tag_ptr_to_member_type}{dwarf2read.c}\\
\ & read\_tag\_reference\_type() & dwarf2read.c & \cxreffunc{read_tag_reference_type}{dwarf2read.c}\\
\ & read\_tag\_restrict\_type() & dwarf2read.c & \cxreffunc{read_tag_restrict_type}{dwarf2read.c}\\
\ & read\_tag\_string\_type() & dwarf2read.c & \cxreffunc{read_tag_string_type}{dwarf2read.c}\\
\ & read\_tag\_unspecified\_type() & dwarf2read.c & \cxreffunc{read_tag_unspecified_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_tag\_volatile\_type() & dwarf2read.c & \cxreffunc{read_tag_volatile_type}{dwarf2read.c}\\
\ & read\_typedef() & dwarf2read.c & \cxreffunc{read_typedef}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\ & tag\_type\_to\_type() & dwarf2read.c & \cxreffunc{tag_type_to_type}{dwarf2read.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & processing\_current\_prefix & cp-namespace.c & \cxrefvar{processing_current_prefix}{cp-namespace.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function read\_typedef()}
\label{func_read_typedef_dwarf2read.c}

{\stt static void read\_typedef ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & dwarf2\_attr() & dwarf2read.c & \cxreffunc{dwarf2_attr}{dwarf2read.c}\\
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_die\_type() & dwarf2read.c & \cxreffunc{set_die_type}{dwarf2read.c}\\
Called by:\ & process\_die() & dwarf2read.c & \cxreffunc{process_die}{dwarf2read.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_unsigned\_leb128()}
\label{func_read_unsigned_leb128_dwarf2read.c}

{\stt static unsigned long read\_unsigned\_leb128 ( bfd* abfd, char* buf, unsigned int* bytes\_read\_ptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & dwarf2\_read\_abbrevs() & dwarf2read.c & \cxreffunc{dwarf2_read_abbrevs}{dwarf2read.c}\\
\ & dwarf2\_scan\_inlined\_section\_for\_psymbols() & dwarf2read.c & \cxreffunc{dwarf2_scan_inlined_section_for_psymbols}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_decode\_line\_header() & dwarf2read.c & \cxreffunc{dwarf_decode_line_header}{dwarf2read.c}\\
\ & dwarf\_decode\_lines() & dwarf2read.c & \cxreffunc{dwarf_decode_lines}{dwarf2read.c}\\
\ & dwarf\_decode\_macros() & dwarf2read.c & \cxreffunc{dwarf_decode_macros}{dwarf2read.c}\\
\ & peek\_die\_abbrev() & dwarf2read.c & \cxreffunc{peek_die_abbrev}{dwarf2read.c}\\
\ & read\_attribute\_value() & dwarf2read.c & \cxreffunc{read_attribute_value}{dwarf2read.c}\\
\ & read\_full\_die() & dwarf2read.c & \cxreffunc{read_full_die}{dwarf2read.c}\\
\ & scan\_partial\_inlined\_function\_symbols() & dwarf2read.c & \cxreffunc{scan_partial_inlined_function_symbols}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function reset\_die\_and\_siblings\_types()}
\label{func_reset_die_and_siblings_types_dwarf2read.c}

{\stt static void reset\_die\_and\_siblings\_types ( struct die\_info* start\_die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & get\_die\_type() & dwarf2read.c & \cxreffunc{get_die_type}{dwarf2read.c}\\
\ & reset\_die\_and\_siblings\_types() & dwarf2read.c & \cxreffunc{reset_die_and_siblings_types}{dwarf2read.c}\\
Called by:\ & process\_queue() & dwarf2read.c & \cxreffunc{process_queue}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & reset\_die\_and\_siblings\_types() & dwarf2read.c & \cxreffunc{reset_die_and_siblings_types}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function right\_rotate()}
\label{func_right_rotate_dwarf2read.c}

{\stt static void right\_rotate ( struct rb\_tree\_node** root, struct rb\_tree\_node* x )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & rb\_delete\_fixup() & dwarf2read.c & \cxreffunc{rb_delete_fixup}{dwarf2read.c}\\
\ & rb\_tree\_insert() & dwarf2read.c & \cxreffunc{rb_tree_insert}{dwarf2read.c}\\
\ & rb\_tree\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_remove_node}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function scan\_partial\_inlined\_function\_symbols()}
\label{func_scan_partial_inlined_function_symbols_dwarf2read.c}

{\stt static void scan\_partial\_inlined\_function\_symbols ( struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & cp\_check\_possible\_namespace\_symbols() & cp-namespace.c & \cxreffunc{cp_check_possible_namespace_symbols}{cp-namespace.c}\\
\ & objfile\_text\_section\_offset() & objfiles.c & \cxreffunc{objfile_text_section_offset}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_address() & dwarf2read.c & \cxreffunc{read_address}{dwarf2read.c}\\
\ & read\_indirect\_string() & dwarf2read.c & \cxreffunc{read_indirect_string}{dwarf2read.c}\\
\ & read\_initial\_length() & dwarf2read.c & \cxreffunc{read_initial_length}{dwarf2read.c}\\
\ & read\_offset() & dwarf2read.c & \cxreffunc{read_offset}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function scan\_partial\_symbols()}
\label{func_scan_partial_symbols_dwarf2read.c}

{\stt static void scan\_partial\_symbols ( struct partial\_die\_info* first\_die, CORE\_ADDR* lowpc, CORE\_ADDR* highpc, struct dwarf2\_cu* cu, struct equiv\_psym\_list** equiv\_psyms )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & add\_equiv\_psym() & dwarf2read.c & \cxreffunc{add_equiv_psym}{dwarf2read.c}\\
\ & add\_partial\_enumeration() & dwarf2read.c & \cxreffunc{add_partial_enumeration}{dwarf2read.c}\\
\ & add\_partial\_namespace() & dwarf2read.c & \cxreffunc{add_partial_namespace}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & add\_partial\_symbol() & dwarf2read.c & \cxreffunc{add_partial_symbol}{dwarf2read.c}\\
\ & fixup\_partial\_die() & dwarf2read.c & \cxreffunc{fixup_partial_die}{dwarf2read.c}\\
Called by:\ & add\_partial\_namespace() & dwarf2read.c & \cxreffunc{add_partial_namespace}{dwarf2read.c}\\
\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_cu\_language()}
\label{func_set_cu_language_dwarf2read.c}

{\stt static void set\_cu\_language ( unsigned int lang, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & language\_def() & language.c & \cxreffunc{language_def}{language.c}\\
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\ & load\_comp\_unit() & dwarf2read.c & \cxreffunc{load_comp_unit}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & load\_full\_comp\_unit() & dwarf2read.c & \cxreffunc{load_full_comp_unit}{dwarf2read.c}\\
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
\ & set\_repository\_cu\_language() & dwarf2read.c & \cxreffunc{set_repository_cu_language}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_die\_type()}
\label{func_set_die_type_dwarf2read.c}

{\stt static void set\_die\_type ( struct die\_info* die, struct type* type, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk(), htab\_create\_alloc\_ex(), htab\_find\_slot\_with\_hash()} &\\
Called by:\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\ & read\_base\_type() & dwarf2read.c & \cxreffunc{read_base_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_enumeration\_type() & dwarf2read.c & \cxreffunc{read_enumeration_type}{dwarf2read.c}\\
\ & read\_namespace() & dwarf2read.c & \cxreffunc{read_namespace}{dwarf2read.c}\\
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\ & read\_subrange\_type() & dwarf2read.c & \cxreffunc{read_subrange_type}{dwarf2read.c}\\
\ & read\_subroutine\_type() & dwarf2read.c & \cxreffunc{read_subroutine_type}{dwarf2read.c}\\
\ & read\_tag\_const\_type() & dwarf2read.c & \cxreffunc{read_tag_const_type}{dwarf2read.c}\\
\ & read\_tag\_pointer\_type() & dwarf2read.c & \cxreffunc{read_tag_pointer_type}{dwarf2read.c}\\
\ & read\_tag\_ptr\_to\_member\_type() & dwarf2read.c & \cxreffunc{read_tag_ptr_to_member_type}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_tag\_reference\_type() & dwarf2read.c & \cxreffunc{read_tag_reference_type}{dwarf2read.c}\\
\ & read\_tag\_restrict\_type() & dwarf2read.c & \cxreffunc{read_tag_restrict_type}{dwarf2read.c}\\
\ & read\_tag\_string\_type() & dwarf2read.c & \cxreffunc{read_tag_string_type}{dwarf2read.c}\\
\ & read\_tag\_unspecified\_type() & dwarf2read.c & \cxreffunc{read_tag_unspecified_type}{dwarf2read.c}\\
\ & read\_tag\_volatile\_type() & dwarf2read.c & \cxreffunc{read_tag_volatile_type}{dwarf2read.c}\\
\ & read\_typedef() & dwarf2read.c & \cxreffunc{read_typedef}{dwarf2read.c}\\
Refs Func:\ & dummy\_obstack\_deallocate() & dwarf2read.c & \cxreffunc{dummy_obstack_deallocate}{dwarf2read.c}\\
\ & hashtab\_obstack\_allocate() & dwarf2read.c & \cxreffunc{hashtab_obstack_allocate}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & offset\_and\_type\_eq() & dwarf2read.c & \cxreffunc{offset_and_type_eq}{dwarf2read.c}\\
\ & offset\_and\_type\_hash() & dwarf2read.c & \cxreffunc{offset_and_type_hash}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_dwarf2\_cmd()}
\label{func_set_dwarf2_cmd_dwarf2read.c}

{\stt static void set\_dwarf2\_cmd ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ help\_list()} &\\
Used in:\ & \_initialize\_dwarf2\_read() & dwarf2read.c & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & set\_dwarf2\_cmdlist & dwarf2read.c & \cxrefvar{set_dwarf2_cmdlist}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_repository\_cu\_language()}
\label{func_set_repository_cu_language_dwarf2read.c}

{\stt static void set\_repository\_cu\_language ( unsigned int language, struct dwarf2\_cu* old\_cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & find\_open\_repository() & dwarf2read.c & \cxreffunc{find_open_repository}{dwarf2read.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & set\_cu\_language() & dwarf2read.c & \cxreffunc{set_cu_language}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & dwarf2\_build\_psymtabs\_hard() & dwarf2read.c & \cxreffunc{dwarf2_build_psymtabs_hard}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_debug\_debugmap()}
\label{func_show_debug_debugmap_dwarf2read.c}

{\stt static void show\_debug\_debugmap ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_dwarf2\_read() & dwarf2read.c & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_dwarf2\_cmd()}
\label{func_show_dwarf2_cmd_dwarf2read.c}

{\stt static void show\_dwarf2\_cmd ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ cmd\_show\_list()} &\\
Used in:\ & \_initialize\_dwarf2\_read() & dwarf2read.c & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
Refs Var:\ & show\_dwarf2\_cmdlist & dwarf2read.c & \cxrefvar{show_dwarf2_cmdlist}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_dwarf2\_max\_cache\_age()}
\label{func_show_dwarf2_max_cache_age_dwarf2read.c}

{\stt static void show\_dwarf2\_max\_cache\_age ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_dwarf2\_read() & dwarf2read.c & \cxreffunc{_initialize_dwarf2_read}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function sibling\_die()}
\label{func_sibling_die_dwarf2read.c}

{\stt static struct die\_info* sibling\_die ( struct die\_info* die )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & determine\_class\_name() & dwarf2read.c & \cxreffunc{determine_class_name}{dwarf2read.c}\\
\ & get\_scope\_pc\_bounds() & dwarf2read.c & \cxreffunc{get_scope_pc_bounds}{dwarf2read.c}\\
\ & process\_enumeration\_scope() & dwarf2read.c & \cxreffunc{process_enumeration_scope}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_structure\_scope() & dwarf2read.c & \cxreffunc{process_structure_scope}{dwarf2read.c}\\
\ & read\_array\_type() & dwarf2read.c & \cxreffunc{read_array_type}{dwarf2read.c}\\
\ & read\_common\_block() & dwarf2read.c & \cxreffunc{read_common_block}{dwarf2read.c}\\
\ & read\_file\_scope() & dwarf2read.c & \cxreffunc{read_file_scope}{dwarf2read.c}\\
\ & read\_func\_scope() & dwarf2read.c & \cxreffunc{read_func_scope}{dwarf2read.c}\\
\ & read\_inlined\_subroutine\_scope() & dwarf2read.c & \cxreffunc{read_inlined_subroutine_scope}{dwarf2read.c}\\
\ & read\_lexical\_block\_scope() & dwarf2read.c & \cxreffunc{read_lexical_block_scope}{dwarf2read.c}\\
\ & read\_namespace() & dwarf2read.c & \cxreffunc{read_namespace}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_structure\_type() & dwarf2read.c & \cxreffunc{read_structure_type}{dwarf2read.c}\\
\ & read\_subroutine\_type() & dwarf2read.c & \cxreffunc{read_subroutine_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function skip\_children()}
\label{func_skip_children_dwarf2read.c}

{\stt static char* skip\_children ( char* info\_ptr, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & peek\_die\_abbrev() & dwarf2read.c & \cxreffunc{peek_die_abbrev}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
Called by:\ & locate\_pdi\_sibling() & dwarf2read.c & \cxreffunc{locate_pdi_sibling}{dwarf2read.c}\\
\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function skip\_leb128()}
\label{func_skip_leb128_dwarf2read.c}

{\stt static char* skip\_leb128 ( bfd* abfd, char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & skip\_one\_die() & dwarf2read.c & \cxreffunc{skip_one_die}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function skip\_one\_die()}
\label{func_skip_one_die_dwarf2read.c}

{\stt static char* skip\_one\_die ( char* info\_ptr, struct abbrev\_info* abbrev, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf2\_get\_ref\_die\_offset() & dwarf2read.c & \cxreffunc{dwarf2_get_ref_die_offset}{dwarf2read.c}\\
\ & dwarf\_form\_name() & dwarf2read.c & \cxreffunc{dwarf_form_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & read\_1\_byte() & dwarf2read.c & \cxreffunc{read_1_byte}{dwarf2read.c}\\
\ & read\_2\_bytes() & dwarf2read.c & \cxreffunc{read_2_bytes}{dwarf2read.c}\\
\ & read\_4\_bytes() & dwarf2read.c & \cxreffunc{read_4_bytes}{dwarf2read.c}\\
\ & read\_attribute() & dwarf2read.c & \cxreffunc{read_attribute}{dwarf2read.c}\\
\ & read\_string() & dwarf2read.c & \cxreffunc{read_string}{dwarf2read.c}\\
\ & read\_unsigned\_leb128() & dwarf2read.c & \cxreffunc{read_unsigned_leb128}{dwarf2read.c}\\
\ & skip\_children() & dwarf2read.c & \cxreffunc{skip_children}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & skip\_leb128() & dwarf2read.c & \cxreffunc{skip_leb128}{dwarf2read.c}\\
Called by:\ & load\_partial\_dies() & dwarf2read.c & \cxreffunc{load_partial_dies}{dwarf2read.c}\\
\ & skip\_children() & dwarf2read.c & \cxreffunc{skip_children}{dwarf2read.c}\\
Refs Var:\ & dwarf2\_per\_objfile & dwarf2read.c & \cxrefvar{dwarf2_per_objfile}{dwarf2read.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function store\_in\_ref\_table()}
\label{func_store_in_ref_table_dwarf2read.c}

{\stt static void store\_in\_ref\_table ( unsigned int offset, struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Called by:\ & read\_die\_and\_children() & dwarf2read.c & \cxreffunc{read_die_and_children}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function tag\_type\_to\_type()}
\label{func_tag_type_to_type_dwarf2read.c}

{\stt static struct type* tag\_type\_to\_type ( struct die\_info* die, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & dump\_die() & dwarf2read.c & \cxreffunc{dump_die}{dwarf2read.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & read\_type\_die() & dwarf2read.c & \cxreffunc{read_type_die}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & die\_containing\_type() & dwarf2read.c & \cxreffunc{die_containing_type}{dwarf2read.c}\\
\ & die\_type() & dwarf2read.c & \cxreffunc{die_type}{dwarf2read.c}\\
\ & lookup\_repository\_type() & dwarf2read.c & \cxreffunc{lookup_repository_type}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function translate\_common\_symbol\_debug\_map\_address()}
\label{func_translate_common_symbol_debug_map_address_dwarf2read.c}

{\stt static int translate\_common\_symbol\_debug\_map\_address ( struct oso\_to\_final\_addr\_map* map, const char* name, CORE\_ADDR* addr )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & decode\_locdesc() & dwarf2read.c & \cxreffunc{decode_locdesc}{dwarf2read.c}\\
\ & var\_decode\_location() & dwarf2read.c & \cxreffunc{var_decode_location}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & debug\_debugmap & dwarf2read.c & \cxrefvar{debug_debugmap}{dwarf2read.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function translate\_debug\_map\_address\_with\_tuple()}
\label{func_translate_debug_map_address_with_tuple_dwarf2read.c}

{\stt static CORE\_ADDR translate\_debug\_map\_address\_with\_tuple ( struct oso\_to\_final\_addr\_map* map, struct oso\_final\_addr\_tuple* match, CORE\_ADDR oso\_addr, int highpc )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & paddr() & utils.c & \cxreffunc{paddr}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ bsearch()} &\\
Called by:\ & dwarf2\_record\_line() & dwarf2read.c & \cxreffunc{dwarf2_record_line}{dwarf2read.c}\\
\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
Refs Func:\ & compare\_translation\_final\_addr() & dwarf2read.c & \cxreffunc{compare_translation_final_addr}{dwarf2read.c}\\
Refs Var:\ & debug\_debugmap & dwarf2read.c & \cxrefvar{debug_debugmap}{dwarf2read.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function tree\_height()}
\label{func_tree_height_dwarf2read.c}

{\stt static int tree\_height ( struct rb\_tree\_node* tree )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & tree\_height() & dwarf2read.c & \cxreffunc{tree_height}{dwarf2read.c}\\
Called by:\ & tree\_height() & dwarf2read.c & \cxreffunc{tree_height}{dwarf2read.c}\\
\ & verify\_tree\_heights() & dwarf2read.c & \cxreffunc{verify_tree_heights}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function typename\_concat()}
\label{func_typename_concat_dwarf2read.c}

{\stt static char* typename\_concat ( struct obstack* obs, const char* prefix, const char* suffix, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & obconcat() & symfile.c & \cxreffunc{obconcat}{symfile.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcat\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcat\_chk(), \_\_inline\_strcpy\_chk(), strlen()} &\\
Called by:\ & determine\_class\_name() & dwarf2read.c & \cxreffunc{determine_class_name}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\ & determine\_prefix() & dwarf2read.c & \cxreffunc{determine_prefix}{dwarf2read.c}\\
\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\ & partial\_die\_full\_name() & dwarf2read.c & \cxreffunc{partial_die_full_name}{dwarf2read.c}\\
\ & partial\_die\_parent\_scope() & dwarf2read.c & \cxreffunc{partial_die_parent_scope}{dwarf2read.c}\\
\ & read\_enumeration\_type() & dwarf2read.c & \cxreffunc{read_enumeration_type}{dwarf2read.c}\\
\ & read\_namespace() & dwarf2read.c & \cxreffunc{read_namespace}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function var\_decode\_location()}
\label{func_var_decode_location_dwarf2read.c}

{\stt static void var\_decode\_location ( struct attribute* attr, struct symbol* sym, struct dwarf2\_cu* cu )}

\smallskip
\begin{cxreftabiii}
Calls:\ & attr\_form\_is\_block() & dwarf2read.c & \cxreffunc{attr_form_is_block}{dwarf2read.c}\\
\ & dwarf2\_symbol\_mark\_computed() & dwarf2read.c & \cxreffunc{dwarf2_symbol_mark_computed}{dwarf2read.c}\\
\ & fixup\_symbol\_section() & symtab.c & \cxreffunc{fixup_symbol_section}{symtab.c}\\
\ & objfile\_section\_offset() & objfiles.c & \cxreffunc{objfile_section_offset}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_address() & dwarf2read.c & \cxreffunc{read_address}{dwarf2read.c}\\
\ & translate\_common\_symbol\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_common_symbol_debug_map_address}{dwarf2read.c}\\
\ & translate\_debug\_map\_address() & dwarf2read.c & \cxreffunc{translate_debug_map_address}{dwarf2read.c}\\
Called by:\ & new\_symbol() & dwarf2read.c & \cxreffunc{new_symbol}{dwarf2read.c}\\
\end{cxreftabiii}


\subsubsection{Local Function verify\_rb\_tree()}
\label{func_verify_rb_tree_dwarf2read.c}

{\stt static int verify\_rb\_tree ( struct rb\_tree\_node* tree )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & verify\_tree\_colors() & dwarf2read.c & \cxreffunc{verify_tree_colors}{dwarf2read.c}\\
\ & verify\_tree\_heights() & dwarf2read.c & \cxreffunc{verify_tree_heights}{dwarf2read.c}\\
\ & \cxreftabiiispan{ fprintf()} &\\
Called by:\ & rb\_tree\_remove\_node() & dwarf2read.c & \cxreffunc{rb_tree_remove_node}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function verify\_tree\_colors()}
\label{func_verify_tree_colors_dwarf2read.c}

{\stt static int verify\_tree\_colors ( struct rb\_tree\_node* tree )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & verify\_tree\_colors() & dwarf2read.c & \cxreffunc{verify_tree_colors}{dwarf2read.c}\\
Called by:\ & verify\_rb\_tree() & dwarf2read.c & \cxreffunc{verify_rb_tree}{dwarf2read.c}\\
\ & verify\_tree\_colors() & dwarf2read.c & \cxreffunc{verify_tree_colors}{dwarf2read.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function verify\_tree\_heights()}
\label{func_verify_tree_heights_dwarf2read.c}

{\stt static int verify\_tree\_heights ( struct rb\_tree\_node* tree )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarf2read.c & \ & \cxreffile{dwarf2read.c}\\
Calls:\ & tree\_height() & dwarf2read.c & \cxreffunc{tree_height}{dwarf2read.c}\\
Called by:\ & verify\_rb\_tree() & dwarf2read.c & \cxreffunc{verify_rb_tree}{dwarf2read.c}\\
\end{cxreftabiii}

