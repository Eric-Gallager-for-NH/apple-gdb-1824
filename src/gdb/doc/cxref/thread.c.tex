% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF thread.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File thread.c}{File thread.c}
\section{File thread.c}
\label{file_thread.c}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{0.8in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.6in}{\stt \#include <regex.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.4in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{0.6in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.6in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inferior.h"} &\cxreffile{inferior.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.4in}{\stt \#include "gdb-events.h"} &\cxreffile{gdb-events.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "environ.h"} &\cxreffile{environ.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "value.h"} &\cxreffile{value.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "target.h"} &\cxreffile{target.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbthread.h"} &\cxreffile{gdbthread.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "exceptions.h"} &\cxreffile{exceptions.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\hspace*{0.2in}{\stt \#include <setjmp.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "regcache.h"} &\cxreffile{regcache.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb.h"} &\cxreffile{gdb.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "wrapper.h"} &\cxreffile{wrapper.h}\\
\hspace*{0.2in}{\stt \#include "gdb.h"} &\cxreffile{gdb.h}\\
\hspace*{0.2in}{\stt \#include "varobj.h"} &\cxreffile{varobj.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <ctype.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <limits.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <sys/types.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <signal.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "macosx/macosx-nat-infthread.h"} &\cxreffile{macosx/macosx-nat-infthread.h}\\
\hspace*{0.2in}{\stt \#include <mach/mach.h>} &\\
\end{cxreftabi}


\subsection{Type definitions}


\subsubsection{Type struct current\_thread\_cleanup}
\label{type_struct_current_thread_cleanup_thread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct current\_thread\_cleanup} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt ptid\_t inferior\_ptid;} &\\
\hspace*{0.2in}{\stt int print;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct select\_thread\_args}
\label{type_struct_select_thread_args_thread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct select\_thread\_args} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt const char* tidstr;} &\\
\hspace*{0.2in}{\stt int print;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable thread\_list}
\label{var_thread_list_thread.c}

{\stt struct thread\_info* thread\_list}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & add\_thread() & thread.c & \cxreffunc{add_thread}{thread.c}\\
\ & delete\_step\_resume\_breakpoint() & thread.c & \cxreffunc{delete_step_resume_breakpoint}{thread.c}\\
\ & delete\_thread() & thread.c & \cxreffunc{delete_thread}{thread.c}\\
\ & do\_captured\_list\_thread\_ids() & thread.c & \cxreffunc{do_captured_list_thread_ids}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_thread\_id() & thread.c & \cxreffunc{find_thread_id}{thread.c}\\
\ & find\_thread\_pid() & thread.c & \cxreffunc{find_thread_pid}{thread.c}\\
\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & info\_threads\_command() & thread.c & \cxreffunc{info_threads_command}{thread.c}\\
\ & init\_thread\_list() & thread.c & \cxreffunc{init_thread_list}{thread.c}\\
\ & iterate\_over\_threads() & thread.c & \cxreffunc{iterate_over_threads}{thread.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & prune\_threads() & thread.c & \cxreffunc{prune_threads}{thread.c}\\
\ & thread\_apply\_all\_command() & thread.c & \cxreffunc{thread_apply_all_command}{thread.c}\\
\ & valid\_thread\_id() & thread.c & \cxreffunc{valid_thread_id}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Variable highest\_thread\_num}
\label{var_highest_thread_num_thread.c}

{\stt int highest\_thread\_num}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote.c & \ & \cxreffile{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & add\_thread() & thread.c & \cxreffunc{add_thread}{thread.c}\\
\ & init\_thread\_list() & thread.c & \cxreffunc{init_thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Variable thread\_cmd\_list}
\label{var_thread_cmd_list_thread.c}

{\stt struct cmd\_list\_element* thread\_cmd\_list}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & \_initialize\_thread() & thread.c & \cxreffunc{_initialize_thread}{thread.c}\\
\end{cxreftabiii}


\subsubsection{External Variables}

{\bf scheduler\_lock\_ptid}
\label{var_scheduler_lock_ptid_thread.c}

{\stt extern struct ptid scheduler\_lock\_ptid}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_thread()}
\label{func__initialize_thread_thread.c}

{\stt void \_initialize\_thread ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& thread.c & \ & \cxreffile{thread.c}\\
Calls:\ & \cxreftabiiispan{ add\_cmd(), add\_com\_alias(), add\_info(), add\_prefix\_cmd()} &\\
Refs Func:\ & info\_threads\_command() & thread.c & \cxreffunc{info_threads_command}{thread.c}\\
\ & thread\_apply\_all\_command() & thread.c & \cxreffunc{thread_apply_all_command}{thread.c}\\
\ & thread\_apply\_command() & thread.c & \cxreffunc{thread_apply_command}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & thread\_command() & thread.c & \cxreffunc{thread_command}{thread.c}\\
Refs Var:\ & thread\_cmd\_list & thread.c & \cxrefvar{thread_cmd_list}{thread.c}\\
\ & xdb\_commands & main.c & \cxrefvar{xdb_commands}{main.c}\\
\ & \cxreftabiiispan{ cmdlist} &\\
\end{cxreftabiii}


\subsubsection{Global Function add\_thread()}
\label{func_add_thread_thread.c}

{\stt struct thread\_info* add\_thread ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & record\_currthread() & remote.c & \cxreffunc{record_currthread}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_newthread\_step() & remote.c & \cxreffunc{remote_newthread_step}{remote.c}\\
\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
Refs Var:\ & highest\_thread\_num & thread.c & \cxrefvar{highest_thread_num}{thread.c}\\
\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function delete\_step\_resume\_breakpoint()}
\label{func_delete_step_resume_breakpoint_thread.c}

{\stt void delete\_step\_resume\_breakpoint ( void* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Used in:\ & fetch\_inferior\_event() & infrun.c & \cxreffunc{fetch_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & wait\_for\_inferior() & infrun.c & \cxreffunc{wait_for_inferior}{infrun.c}\\
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function delete\_thread()}
\label{func_delete_thread_thread.c}

{\stt void delete\_thread ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & free\_thread() & thread.c & \cxreffunc{free_thread}{thread.c}\\
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
Called by:\ & prune\_threads() & thread.c & \cxreffunc{prune_threads}{thread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function find\_thread\_id()}
\label{func_find_thread_id_thread.c}

{\stt struct thread\_info* find\_thread\_id ( int num )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Called by:\ & do\_captured\_thread\_select() & thread.c & \cxreffunc{do_captured_thread_select}{thread.c}\\
\ & load\_infrun\_state() & thread.c & \cxreffunc{load_infrun_state}{thread.c}\\
\ & restore\_thread\_inlined\_call\_stack() & inlining.c & \cxreffunc{restore_thread_inlined_call_stack}{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & save\_infrun\_state() & thread.c & \cxreffunc{save_infrun_state}{thread.c}\\
\ & save\_thread\_inlined\_call\_stack() & inlining.c & \cxreffunc{save_thread_inlined_call_stack}{inlining.c}\\
\ & thread\_apply\_command() & thread.c & \cxreffunc{thread_apply_command}{thread.c}\\
\ & thread\_id\_to\_pid() & thread.c & \cxreffunc{thread_id_to_pid}{thread.c}\\
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function find\_thread\_pid()}
\label{func_find_thread_pid_thread.c}

{\stt struct thread\_info* find\_thread\_pid ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function gdb\_list\_thread\_ids()}
\label{func_gdb_list_thread_ids_thread.c}

{\stt enum gdb\_rc gdb\_list\_thread\_ids ( struct ui\_out* uiout, char** error\_message )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdb.h & \ & \cxreffile{gdb.h}\\
Calls:\ & \cxreftabiiispan{ catch\_exceptions\_with\_msg()} &\\
Refs Func:\ & do\_captured\_list\_thread\_ids() & thread.c & \cxreffunc{do_captured_list_thread_ids}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function gdb\_thread\_select()}
\label{func_gdb_thread_select_thread.c}

{\stt enum gdb\_rc gdb\_thread\_select ( struct ui\_out* uiout, const char* tidstr, int print, char** error\_message )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdb.h & \ & \cxreffile{gdb.h}\\
Calls:\ & \cxreftabiiispan{ catch\_exceptions\_with\_msg()} &\\
Called by:\ & thread\_command() & thread.c & \cxreffunc{thread_command}{thread.c}\\
Refs Func:\ & do\_captured\_thread\_select() & thread.c & \cxreffunc{do_captured_thread_select}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function in\_thread\_list()}
\label{func_in_thread_list_thread.c}

{\stt int in\_thread\_list ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
Called by:\ & breakpoint\_re\_set\_thread() & breakpoint.c & \cxreffunc{breakpoint_re_set_thread}{breakpoint.c}\\
\ & context\_switch() & infrun.c & \cxreffunc{context_switch}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & record\_currthread() & remote.c & \cxreffunc{record_currthread}{remote.c}\\
\ & remote\_newthread\_step() & remote.c & \cxreffunc{remote_newthread_step}{remote.c}\\
\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\ & set\_momentary\_breakpoint() & breakpoint.c & \cxreffunc{set_momentary_breakpoint}{breakpoint.c}\\
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function init\_thread\_list()}
\label{func_init_thread_list_thread.c}

{\stt void init\_thread\_list ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & free\_thread() & thread.c & \cxreffunc{free_thread}{thread.c}\\
Called by:\ & kill\_command() & inflow.c & \cxreffunc{kill_command}{inflow.c}\\
\ & start\_remote() & infrun.c & \cxreffunc{start_remote}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & highest\_thread\_num & thread.c & \cxrefvar{highest_thread_num}{thread.c}\\
\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function iterate\_over\_threads()}
\label{func_iterate_over_threads_thread.c}

{\stt struct thread\_info* iterate\_over\_threads ( int (*callback)(struct thread\_info*,void*), void* data )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Called by:\ & check\_safe\_call() & valops.c & \cxreffunc{check_safe_call}{valops.c}\\
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function load\_infrun\_state()}
\label{func_load_infrun_state_thread.c}

{\stt void load\_infrun\_state ( ptid\_t ptid, CORE\_ADDR* prev\_pc, int* trap\_expected, struct breakpoint** step\_resume\_breakpoint, CORE\_ADDR* step\_range\_start, CORE\_ADDR* step\_range\_end, struct address\_range\_list** stepping\_ranges, struct frame\_id* step\_frame\_id, int* handling\_longjmp, int* another\_trap, int* stepping\_through\_solib\_after\_catch, bpstat* stepping\_through\_solib\_catchpoints, int* current\_line, struct symtab** current\_symtab )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & find\_thread\_id() & thread.c & \cxreffunc{find_thread_id}{thread.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & restore\_thread\_inlined\_call\_stack() & inlining.c & \cxreffunc{restore_thread_inlined_call_stack}{inlining.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & context\_switch() & infrun.c & \cxreffunc{context_switch}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function make\_cleanup\_restore\_current\_thread()}
\label{func_make_cleanup_restore_current_thread_thread.c}

{\stt struct cleanup* make\_cleanup\_restore\_current\_thread ( ptid\_t inferior\_ptid, int print )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdb.h & \ & \cxreffile{gdb.h}\\
Calls:\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & check\_safe\_call() & valops.c & \cxreffunc{check_safe_call}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & safe\_check\_is\_thread\_unsafe() & valops.c & \cxreffunc{safe_check_is_thread_unsafe}{valops.c}\\
\ & thread\_apply\_all\_command() & thread.c & \cxreffunc{thread_apply_all_command}{thread.c}\\
\ & thread\_apply\_command() & thread.c & \cxreffunc{thread_apply_command}{thread.c}\\
Refs Func:\ & do\_restore\_current\_thread\_cleanup() & thread.c & \cxreffunc{do_restore_current_thread_cleanup}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function pid\_to\_thread\_id()}
\label{func_pid_to_thread_id_thread.c}

{\stt int pid\_to\_thread\_id ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
Called by:\ & bpstat\_find\_step\_resume\_breakpoint() & breakpoint.c & \cxreffunc{bpstat_find_step_resume_breakpoint}{breakpoint.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_re\_set\_thread() & breakpoint.c & \cxreffunc{breakpoint_re_set_thread}{breakpoint.c}\\
\ & breakpoint\_thread\_match() & breakpoint.c & \cxreffunc{breakpoint_thread_match}{breakpoint.c}\\
\ & do\_captured\_thread\_select() & thread.c & \cxreffunc{do_captured_thread_select}{thread.c}\\
\ & do\_check\_is\_thread\_unsafe() & valops.c & \cxreffunc{do_check_is_thread_unsafe}{valops.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & load\_infrun\_state() & thread.c & \cxreffunc{load_infrun_state}{thread.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & restore\_thread\_inlined\_call\_stack() & inlining.c & \cxreffunc{restore_thread_inlined_call_stack}{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & save\_infrun\_state() & thread.c & \cxreffunc{save_infrun_state}{thread.c}\\
\ & save\_thread\_inlined\_call\_stack() & inlining.c & \cxreffunc{save_thread_inlined_call_stack}{inlining.c}\\
\ & set\_momentary\_breakpoint() & breakpoint.c & \cxreffunc{set_momentary_breakpoint}{breakpoint.c}\\
\ & thread\_command() & thread.c & \cxreffunc{thread_command}{thread.c}\\
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function prune\_threads()}
\label{func_prune_threads_thread.c}

{\stt void prune\_threads ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & delete\_thread() & thread.c & \cxreffunc{delete_thread}{thread.c}\\
\ & thread\_alive() & thread.c & \cxreffunc{thread_alive}{thread.c}\\
Called by:\ & do\_captured\_list\_thread\_ids() & thread.c & \cxreffunc{do_captured_list_thread_ids}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & info\_threads\_command() & thread.c & \cxreffunc{info_threads_command}{thread.c}\\
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function save\_infrun\_state()}
\label{func_save_infrun_state_thread.c}

{\stt void save\_infrun\_state ( ptid\_t ptid, CORE\_ADDR prev\_pc, int trap\_expected, struct breakpoint* step\_resume\_breakpoint, CORE\_ADDR step\_range\_start, CORE\_ADDR step\_range\_end, struct address\_range\_list* stepping\_ranges, const struct frame\_id* step\_frame\_id, int handling\_longjmp, int another\_trap, int stepping\_through\_solib\_after\_catch, bpstat stepping\_through\_solib\_catchpoints, int current\_line, struct symtab* current\_symtab )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & find\_thread\_id() & thread.c & \cxreffunc{find_thread_id}{thread.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & save\_thread\_inlined\_call\_stack() & inlining.c & \cxreffunc{save_thread_inlined_call_stack}{inlining.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & context\_switch() & infrun.c & \cxreffunc{context_switch}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function switch\_to\_thread()}
\label{func_switch_to_thread_thread.c}

{\stt void switch\_to\_thread ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & do\_hand\_call\_cleanups() & utils.c & \cxreffunc{do_hand_call_cleanups}{utils.c}\\
\ & flush\_cached\_frames() & frame.c & \cxreffunc{flush_cached_frames}{frame.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & inlined\_function\_call\_stack\_pc() & inlining.c & \cxreffunc{inlined_function_call_stack_pc}{inlining.c}\\
\ & inlined\_function\_update\_call\_stack() & inlining.c & \cxreffunc{inlined_function_update_call_stack}{inlining.c}\\
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\ & read\_pc() & regcache.c & \cxreffunc{read_pc}{regcache.c}\\
\ & registers\_changed() & regcache.c & \cxreffunc{registers_changed}{regcache.c}\\
\ & restore\_thread\_inlined\_call\_stack() & inlining.c & \cxreffunc{restore_thread_inlined_call_stack}{inlining.c}\\
\ & save\_thread\_inlined\_call\_stack() & inlining.c & \cxreffunc{save_thread_inlined_call_stack}{inlining.c}\\
\ & scheduler\_lock\_on\_p() & infrun.c & \cxreffunc{scheduler_lock_on_p}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & scheduler\_run\_this\_ptid() & infrun.c & \cxreffunc{scheduler_run_this_ptid}{infrun.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
Called by:\ & do\_captured\_thread\_select() & thread.c & \cxreffunc{do_captured_thread_select}{thread.c}\\
\ & do\_check\_is\_thread\_unsafe() & valops.c & \cxreffunc{do_check_is_thread_unsafe}{valops.c}\\
\ & info\_threads\_command() & thread.c & \cxreffunc{info_threads_command}{thread.c}\\
\ & restore\_current\_thread() & thread.c & \cxreffunc{restore_current_thread}{thread.c}\\
\ & thread\_apply\_all\_command() & thread.c & \cxreffunc{thread_apply_all_command}{thread.c}\\
\ & thread\_apply\_command() & thread.c & \cxreffunc{thread_apply_command}{thread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & stop\_pc & infcmd.c & \cxrefvar{stop_pc}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function thread\_id\_to\_pid()}
\label{func_thread_id_to_pid_thread.c}

{\stt ptid\_t thread\_id\_to\_pid ( int num )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Calls:\ & find\_thread\_id() & thread.c & \cxreffunc{find_thread_id}{thread.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function valid\_thread\_id()}
\label{func_valid_thread_id_thread.c}

{\stt int valid\_thread\_id ( int num )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbthread.h & \ & \cxreffile{gdbthread.h}\\
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
Refs Var:\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_captured\_list\_thread\_ids()}
\label{func_do_captured_list_thread_ids_thread.c}

{\stt static int do\_captured\_list\_thread\_ids ( struct ui\_out* uiout, void* arg )}

\smallskip
\begin{cxreftabiii}
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & make\_cleanup\_ui\_out\_list\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_list_begin_end}{ui-out.c}\\
\ & make\_cleanup\_ui\_out\_tuple\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_tuple_begin_end}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & prune\_threads() & thread.c & \cxreffunc{prune_threads}{thread.c}\\
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & \cxreftabiiispan{ macosx\_print\_thread\_details()} &\\
Used in:\ & gdb\_list\_thread\_ids() & thread.c & \cxreffunc{gdb_list_thread_ids}{thread.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_captured\_thread\_select()}
\label{func_do_captured_thread_select_thread.c}

{\stt static int do\_captured\_thread\_select ( struct ui\_out* uiout, void* in\_args )}

\smallskip
\begin{cxreftabiii}
Calls:\ & clear\_inlined\_subroutine\_print\_frames() & inlining.c & \cxreffunc{clear_inlined_subroutine_print_frames}{inlining.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_thread\_id() & thread.c & \cxreffunc{find_thread_id}{thread.c}\\
\ & frame\_relative\_level() & frame.c & \cxreffunc{frame_relative_level}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\ & get\_frame\_type() & frame.c & \cxreffunc{get_frame_type}{frame.c}\\
\ & parse\_and\_eval() & eval.c & \cxreffunc{parse_and_eval}{eval.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & print\_stack\_frame() & stack.c & \cxreffunc{print_stack_frame}{stack.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
\ & thread\_alive() & thread.c & \cxreffunc{thread_alive}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & \cxreftabiiispan{ deprecated\_context\_hook()} &\\
Used in:\ & gdb\_thread\_select() & thread.c & \cxreffunc{gdb_thread_select}{thread.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & deprecated\_context\_hook & top.c & \cxrefvar{deprecated_context_hook}{top.c}\\
\ & deprecated\_selected\_frame & frame.c & \cxrefvar{deprecated_selected_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_restore\_current\_thread\_cleanup()}
\label{func_do_restore_current_thread_cleanup_thread.c}

{\stt static void do\_restore\_current\_thread\_cleanup ( void* arg )}

\smallskip
\begin{cxreftabiii}
Calls:\ & restore\_current\_thread() & thread.c & \cxreffunc{restore_current_thread}{thread.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Used in:\ & make\_cleanup\_restore\_current\_thread() & thread.c & \cxreffunc{make_cleanup_restore_current_thread}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_thread()}
\label{func_free_thread_thread.c}

{\stt static void free\_thread ( struct thread\_info* tp )}

\smallskip
\begin{cxreftabiii}
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & delete\_thread() & thread.c & \cxreffunc{delete_thread}{thread.c}\\
\ & init\_thread\_list() & thread.c & \cxreffunc{init_thread_list}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function info\_threads\_command()}
\label{func_info_threads_command_thread.c}

{\stt static void info\_threads\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& thread.c & \ & \cxreffile{thread.c}\\
Calls:\ & clear\_inlined\_subroutine\_print\_frames() & inlining.c & \cxreffunc{clear_inlined_subroutine_print_frames}{inlining.c}\\
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_selected\_frame() & frame.c & \cxreffunc{get_selected_frame}{frame.c}\\
\ & print\_stack\_frame() & stack.c & \cxreffunc{print_stack_frame}{stack.c}\\
\ & prune\_threads() & thread.c & \cxreffunc{prune_threads}{thread.c}\\
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & show\_stack\_frame() & stack.c & \cxreffunc{show_stack_frame}{stack.c}\\
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\ & ui\_out\_text\_fmt() & ui-out.c & \cxreffunc{ui_out_text_fmt}{ui-out.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), strlcat(), strlcpy(), strlen()} &\\
Used in:\ & \_initialize\_thread() & thread.c & \cxreffunc{_initialize_thread}{thread.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function restore\_current\_thread()}
\label{func_restore_current_thread_thread.c}

{\stt static void restore\_current\_thread ( ptid\_t ptid, int print )}

\smallskip
\begin{cxreftabiii}
Prototype:& thread.c & \ & \cxreffile{thread.c}\\
Calls:\ & clear\_inlined\_subroutine\_print\_frames() & inlining.c & \cxreffunc{clear_inlined_subroutine_print_frames}{inlining.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\ & print\_stack\_frame() & stack.c & \cxreffunc{print_stack_frame}{stack.c}\\
\cxreftabbreak{cxreftabiii}
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
Called by:\ & do\_restore\_current\_thread\_cleanup() & thread.c & \cxreffunc{do_restore_current_thread_cleanup}{thread.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function thread\_alive()}
\label{func_thread_alive_thread.c}

{\stt static int thread\_alive ( struct thread\_info* tp )}

\smallskip
\begin{cxreftabiii}
Prototype:& thread.c & \ & \cxreffile{thread.c}\\
Calls:\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
Called by:\ & do\_captured\_thread\_select() & thread.c & \cxreffunc{do_captured_thread_select}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & prune\_threads() & thread.c & \cxreffunc{prune_threads}{thread.c}\\
\ & thread\_apply\_all\_command() & thread.c & \cxreffunc{thread_apply_all_command}{thread.c}\\
\ & thread\_apply\_command() & thread.c & \cxreffunc{thread_apply_command}{thread.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Local Function thread\_apply\_all\_command()}
\label{func_thread_apply_all_command_thread.c}

{\stt static void thread\_apply\_all\_command ( const char* cmd, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& thread.c & \ & \cxreffile{thread.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup\_restore\_current\_thread() & thread.c & \cxreffunc{make_cleanup_restore_current_thread}{thread.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
\ & thread\_alive() & thread.c & \cxreffunc{thread_alive}{thread.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), safe\_execute\_command(), xstrdup()} &\\
Used in:\ & \_initialize\_thread() & thread.c & \cxreffunc{_initialize_thread}{thread.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & thread\_list & thread.c & \cxrefvar{thread_list}{thread.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function thread\_apply\_command()}
\label{func_thread_apply_command_thread.c}

{\stt static void thread\_apply\_command ( const char* tidlist, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& thread.c & \ & \cxreffile{thread.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & execute\_command() & top.c & \cxreffunc{execute_command}{top.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_thread\_id() & thread.c & \cxreffunc{find_thread_id}{thread.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_restore\_current\_thread() & thread.c & \cxreffunc{make_cleanup_restore_current_thread}{thread.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
\ & thread\_alive() & thread.c & \cxreffunc{thread_alive}{thread.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), isalpha(), strtol(), xstrdup()} &\\
Used in:\ & \_initialize\_thread() & thread.c & \cxreffunc{_initialize_thread}{thread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function thread\_command()}
\label{func_thread_command_thread.c}

{\stt static void thread\_command ( const char* tidstr, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& thread.c & \ & \cxreffile{thread.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdb\_thread\_select() & thread.c & \cxreffunc{gdb_thread_select}{thread.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
Used in:\ & \_initialize\_thread() & thread.c & \cxreffunc{_initialize_thread}{thread.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}

