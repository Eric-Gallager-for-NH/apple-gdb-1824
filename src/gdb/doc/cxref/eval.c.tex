% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF eval.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File eval.c}{File eval.c}
\section{File eval.c}
\label{file_eval.c}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.4in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.2in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\hspace*{0.2in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "f-lang.h"} &\cxreffile{f-lang.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cp-abi.h"} &\cxreffile{cp-abi.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "infcall.h"} &\cxreffile{infcall.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objc-lang.h"} &\cxreffile{objc-lang.h}\\
\hspace*{0.2in}{\stt \#include <Availability.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "block.h"} &\cxreffile{block.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "parser-defs.h"} &\cxreffile{parser-defs.h}\\
\hspace*{0.2in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cp-support.h"} &\cxreffile{cp-support.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <math.h>} &\\
\end{cxreftabi}


\subsection{Variables}


\subsubsection{Variable print\_closure}
\label{var_print_closure_eval.c}

{\stt int print\_closure}

\smallskip
\begin{cxreftabiii}
Visible in:\ & eval.c & \ & \cxreffile{eval.c}\\
Used in:\ & do\_restore\_print\_closure() & eval.c & \cxreffunc{do_restore_print_closure}{eval.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & make\_cleanup\_set\_restore\_print\_closure() & eval.c & \cxreffunc{make_cleanup_set_restore_print_closure}{eval.c}\\
\end{cxreftabiii}


\subsubsection{External Variables}

{\bf overload\_resolution}
\label{var_overload_resolution_eval.c}

{\stt extern int overload\_resolution}

\smallskip
\begin{cxreftabiii}
Defined in:& valops.c & \ & \cxrefvar{overload_resolution}{valops.c}\\
\end{cxreftabiii}

\medskip
{\bf objectprint}
\label{var_objectprint_eval.c}

{\stt extern int objectprint}

\smallskip
\begin{cxreftabiii}
Defined in:& cp-valprint.c & \ & \cxrefvar{objectprint}{cp-valprint.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function calc\_f77\_array\_dims()}
\label{func_calc_f77_array_dims_eval.c}

{\stt int calc\_f77\_array\_dims ( struct type* array\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& f-lang.h & \ & \cxreffile{f-lang.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & f77\_print\_array() & f-valprint.c & \cxreffunc{f77_print_array}{f-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function evaluate\_expression()}
\label{func_evaluate_expression_eval.c}

{\stt struct value* evaluate\_expression ( struct expression* exp )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & evaluate\_subexp() & eval.c & \cxreffunc{evaluate_subexp}{eval.c}\\
Called by:\ & breakpoint\_cond\_eval() & breakpoint.c & \cxreffunc{breakpoint_cond_eval}{breakpoint.c}\\
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & do\_one\_display() & printcmd.c & \cxreffunc{do_one_display}{printcmd.c}\\
\ & encode\_actions() & tracepoint.c & \cxreffunc{encode_actions}{tracepoint.c}\\
\ & gdb\_evaluate\_expression() & wrapper.c & \cxreffunc{gdb_evaluate_expression}{wrapper.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & invoke\_block\_command() & printcmd.c & \cxreffunc{invoke_block_command}{printcmd.c}\\
\ & output\_command() & printcmd.c & \cxreffunc{output_command}{printcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_and\_eval() & eval.c & \cxreffunc{parse_and_eval}{eval.c}\\
\ & parse\_and\_eval\_address() & eval.c & \cxreffunc{parse_and_eval_address}{eval.c}\\
\ & parse\_and\_eval\_address\_1() & eval.c & \cxreffunc{parse_and_eval_address_1}{eval.c}\\
\ & parse\_and\_eval\_long() & eval.c & \cxreffunc{parse_and_eval_long}{eval.c}\\
\ & parse\_to\_comma\_and\_eval() & eval.c & \cxreffunc{parse_to_comma_and_eval}{eval.c}\\
\ & print\_command\_1() & printcmd.c & \cxreffunc{print_command_1}{printcmd.c}\\
\ & set\_command() & printcmd.c & \cxreffunc{set_command}{printcmd.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & watchpoint\_check() & breakpoint.c & \cxreffunc{watchpoint_check}{breakpoint.c}\\
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function evaluate\_subexp\_standard()}
\label{func_evaluate_subexp_standard_eval.c}

{\stt struct value* evaluate\_subexp\_standard ( struct type* expect\_type, struct expression* exp, int* pos, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& expression.h & \ & \cxreffile{expression.h}\\
Calls:\ & access\_value\_history() & value.c & \cxreffunc{access_value_history}{value.c}\\
\ & allocate\_repeat\_value() & value.c & \cxreffunc{allocate_repeat_value}{value.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & binop\_user\_defined\_p() & valarith.c & \cxreffunc{binop_user_defined_p}{valarith.c}\\
\ & block\_for\_pc() & block.c & \cxreffunc{block_for_pc}{block.c}\\
\ & calc\_f77\_array\_dims() & eval.c & \cxreffunc{calc_f77_array_dims}{eval.c}\\
\ & call\_function\_by\_hand\_expecting\_type() & infcall.c & \cxreffunc{call_function_by_hand_expecting_type}{infcall.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & create\_cached\_function() & value.c & \cxreffunc{create_cached_function}{value.c}\\
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\ & evaluate\_subexp() & eval.c & \cxreffunc{evaluate_subexp}{eval.c}\\
\ & evaluate\_subexp\_for\_address() & eval.c & \cxreffunc{evaluate_subexp_for_address}{eval.c}\\
\ & evaluate\_subexp\_for\_sizeof() & eval.c & \cxreffunc{evaluate_subexp_for_sizeof}{eval.c}\\
\ & evaluate\_subexp\_with\_coercion() & eval.c & \cxreffunc{evaluate_subexp_with_coercion}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & f77\_get\_dynamic\_lowerbound() & f-valprint.c & \cxreffunc{f77_get_dynamic_lowerbound}{f-valprint.c}\\
\ & f77\_get\_dynamic\_upperbound() & f-valprint.c & \cxreffunc{f77_get_dynamic_upperbound}{f-valprint.c}\\
\ & find\_function\_addr() & infcall.c & \cxreffunc{find_function_addr}{infcall.c}\\
\ & find\_implementation() & objc-lang.c & \cxreffunc{find_implementation}{objc-lang.c}\\
\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
\ & find\_pc\_function() & blockframe.c & \cxreffunc{find_pc_function}{blockframe.c}\\
\ & frame\_map\_regnum\_to\_name() & frame.c & \cxreffunc{frame_map_regnum_to_name}{frame.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_ptr\_bit() & gdbarch.c & \cxreffunc{gdbarch_ptr_bit}{gdbarch.c}\\
\ & get\_closure\_dynamic\_type() & gdbtypes.c & \cxreffunc{get_closure_dynamic_type}{gdbtypes.c}\\
\ & get\_discrete\_bounds() & gdbtypes.c & \cxreffunc{get_discrete_bounds}{gdbtypes.c}\\
\ & get\_selected\_frame() & frame.c & \cxreffunc{get_selected_frame}{frame.c}\\
\ & init\_array\_element() & eval.c & \cxreffunc{init_array_element}{eval.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & lang\_bool\_type() & language.c & \cxreffunc{lang_bool_type}{language.c}\\
\ & longest\_to\_int() & valprint.c & \cxreffunc{longest_to_int}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_cached\_function() & value.c & \cxreffunc{lookup_cached_function}{value.c}\\
\ & lookup\_child\_selector() & objc-lang.c & \cxreffunc{lookup_child_selector}{objc-lang.c}\\
\ & lookup\_function\_type() & gdbtypes.c & \cxreffunc{lookup_function_type}{gdbtypes.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\ & lookup\_struct\_elt\_type() & gdbtypes.c & \cxreffunc{lookup_struct_elt_type}{gdbtypes.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & unop\_user\_defined\_p() & valarith.c & \cxreffunc{unop_user_defined_p}{valarith.c}\\
\ & using\_struct\_return() & value.c & \cxreffunc{using_struct_return}{value.c}\\
\ & value\_add() & valarith.c & \cxreffunc{value_add}{valarith.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_aggregate\_elt() & valops.c & \cxreffunc{value_aggregate_elt}{valops.c}\\
\ & value\_array() & valops.c & \cxreffunc{value_array}{valops.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_bitstring() & valops.c & \cxreffunc{value_bitstring}{valops.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\ & value\_complement() & valarith.c & \cxreffunc{value_complement}{valarith.c}\\
\ & value\_concat() & valarith.c & \cxreffunc{value_concat}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_from\_double() & value.c & \cxreffunc{value_from_double}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
\ & value\_in() & valarith.c & \cxreffunc{value_in}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_less() & valarith.c & \cxreffunc{value_less}{valarith.c}\\
\ & value\_literal\_complex() & valops.c & \cxreffunc{value_literal_complex}{valops.c}\\
\ & value\_logical\_not() & valarith.c & \cxreffunc{value_logical_not}{valarith.c}\\
\ & value\_neg() & valarith.c & \cxreffunc{value_neg}{valarith.c}\\
\ & value\_nsstring() & objc-lang.c & \cxreffunc{value_nsstring}{objc-lang.c}\\
\ & value\_of\_internalvar() & value.c & \cxreffunc{value_of_internalvar}{value.c}\\
\ & value\_of\_local() & valops.c & \cxreffunc{value_of_local}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_of\_register() & findvar.c & \cxreffunc{value_of_register}{findvar.c}\\
\ & value\_of\_variable() & valops.c & \cxreffunc{value_of_variable}{valops.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_pos() & valarith.c & \cxreffunc{value_pos}{valarith.c}\\
\ & value\_repeat() & valops.c & \cxreffunc{value_repeat}{valops.c}\\
\ & value\_rtti\_target\_type() & valops.c & \cxreffunc{value_rtti_target_type}{valops.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_string() & valops.c & \cxreffunc{value_string}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_virtual\_fn\_field() & cp-abi.c & \cxreffunc{value_virtual_fn_field}{cp-abi.c}\\
\ & value\_x\_binop() & valarith.c & \cxreffunc{value_x_binop}{valarith.c}\\
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_huge\_valf(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_\_inline\_memset\_chk(), \_\_inline\_strcpy\_chk()} &\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_scm() & scm-lang.c & \cxreffunc{evaluate_subexp_scm}{scm-lang.c}\\
Used in:\ & parse.c & \ & \cxreffile{parse.c}\\
Refs Var:\ & builtin\_type\_char & gdbtypes.c & \cxrefvar{builtin_type_char}{gdbtypes.c}\\
\ & builtin\_type\_f\_complex\_s16 & f-lang.c & \cxrefvar{builtin_type_f_complex_s16}{f-lang.c}\\
\ & builtin\_type\_f\_integer & f-lang.c & \cxrefvar{builtin_type_f_integer}{f-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & builtin\_type\_long & gdbtypes.c & \cxrefvar{builtin_type_long}{gdbtypes.c}\\
\ & builtin\_type\_void & gdbtypes.c & \cxrefvar{builtin_type_void}{gdbtypes.c}\\
\ & builtin\_type\_void\_data\_ptr & gdbtypes.c & \cxrefvar{builtin_type_void_data_ptr}{gdbtypes.c}\\
\ & builtin\_type\_void\_func\_ptr & gdbtypes.c & \cxrefvar{builtin_type_void_func_ptr}{gdbtypes.c}\\
\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & deprecated\_hp\_som\_som\_object\_present & symtab.c & \cxrefvar{deprecated_hp_som_som_object_present}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & objectprint & cp-valprint.c & \cxrefvar{objectprint}{cp-valprint.c}\\
\ & overload\_resolution & valops.c & \cxrefvar{overload_resolution}{valops.c}\\
\ & print\_closure & eval.c & \cxrefvar{print_closure}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Global Function evaluate\_subexp\_with\_coercion()}
\label{func_evaluate_subexp_with_coercion_eval.c}

{\stt struct value* evaluate\_subexp\_with\_coercion ( struct expression* exp, int* pos, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & block\_innermost\_frame() & blockframe.c & \cxreffunc{block_innermost_frame}{blockframe.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & evaluate\_subexp() & eval.c & \cxreffunc{evaluate_subexp}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & locate\_var\_value() & findvar.c & \cxreffunc{locate_var_value}{findvar.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
Refs Var:\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function evaluate\_type()}
\label{func_evaluate_type_eval.c}

{\stt struct value* evaluate\_type ( struct expression* exp )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & evaluate\_subexp() & eval.c & \cxreffunc{evaluate_subexp}{eval.c}\\
Called by:\ & gdb\_evaluate\_type() & wrapper.c & \cxreffunc{gdb_evaluate_type}{wrapper.c}\\
\ & maintenance\_print\_type() & typeprint.c & \cxreffunc{maintenance_print_type}{typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & whatis\_exp() & typeprint.c & \cxreffunc{whatis_exp}{typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function make\_cleanup\_set\_restore\_print\_closure()}
\label{func_make_cleanup_set_restore_print_closure_eval.c}

{\stt struct cleanup* make\_cleanup\_set\_restore\_print\_closure ( int newval )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
Called by:\ & invoke\_block\_command() & printcmd.c & \cxreffunc{invoke_block_command}{printcmd.c}\\
\ & varobj\_evaluate\_expression() & varobj.c & \cxreffunc{varobj_evaluate_expression}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_evaluate\_type() & varobj.c & \cxreffunc{varobj_evaluate_type}{varobj.c}\\
\ & varobj\_parse\_exp\_1() & varobj.c & \cxreffunc{varobj_parse_exp_1}{varobj.c}\\
Refs Func:\ & do\_restore\_print\_closure() & eval.c & \cxreffunc{do_restore_print_closure}{eval.c}\\
Refs Var:\ & print\_closure & eval.c & \cxrefvar{print_closure}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Global Function parse\_and\_eval()}
\label{func_parse_and_eval_eval.c}

{\stt struct value* parse\_and\_eval ( const char* exp )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_expression() & parse.c & \cxreffunc{parse_expression}{parse.c}\\
Called by:\ & do\_captured\_thread\_select() & thread.c & \cxreffunc{do_captured_thread_select}{thread.c}\\
\ & ignore\_command() & breakpoint.c & \cxreffunc{ignore_command}{breakpoint.c}\\
\ & parse\_frame\_specification\_1() & stack.c & \cxreffunc{parse_frame_specification_1}{stack.c}\\
\ & quit\_force() & top.c & \cxreffunc{quit_force}{top.c}\\
\ & return\_command() & stack.c & \cxreffunc{return_command}{stack.c}\\
Refs Func:\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
Refs Var:\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function parse\_and\_eval\_address()}
\label{func_parse_and_eval_address_eval.c}

{\stt CORE\_ADDR parse\_and\_eval\_address ( const char* exp )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_expression() & parse.c & \cxreffunc{parse_expression}{parse.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
Called by:\ & add\_symbol\_file\_command() & symfile.c & \cxreffunc{add_symbol_file_command}{symfile.c}\\
\ & add\_symbol\_file\_from\_memory\_command() & symfile-mem.c & \cxreffunc{add_symbol_file_from_memory_command}{symfile-mem.c}\\
\ & maintenance\_translate\_address() & maint.c & \cxreffunc{maintenance_translate_address}{maint.c}\\
\ & mem\_command() & memattr.c & \cxreffunc{mem_command}{memattr.c}\\
\ & sym\_info() & printcmd.c & \cxreffunc{sym_info}{printcmd.c}\\
\ & trace\_find\_outside\_command() & tracepoint.c & \cxreffunc{trace_find_outside_command}{tracepoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & trace\_find\_pc\_command() & tracepoint.c & \cxreffunc{trace_find_pc_command}{tracepoint.c}\\
\ & trace\_find\_range\_command() & tracepoint.c & \cxreffunc{trace_find_range_command}{tracepoint.c}\\
Refs Func:\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
Refs Var:\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\end{cxreftabiii}


\subsubsection{Global Function parse\_and\_eval\_address\_1()}
\label{func_parse_and_eval_address_1_eval.c}

{\stt CORE\_ADDR parse\_and\_eval\_address\_1 ( const char** expptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_exp\_1() & parse.c & \cxreffunc{parse_exp_1}{parse.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
Called by:\ & decode\_indirect() & linespec.c & \cxreffunc{decode_indirect}{linespec.c}\\
Refs Func:\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
Refs Var:\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\end{cxreftabiii}


\subsubsection{Global Function parse\_and\_eval\_long()}
\label{func_parse_and_eval_long_eval.c}

{\stt long parse\_and\_eval\_long ( const char* exp )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_expression() & parse.c & \cxreffunc{parse_expression}{parse.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
Called by:\ & backtrace\_command\_1() & stack.c & \cxreffunc{backtrace_command_1}{stack.c}\\
\ & breakpoints\_info() & breakpoint.c & \cxreffunc{breakpoints_info}{breakpoint.c}\\
\ & continue\_command() & infcmd.c & \cxreffunc{continue_command}{infcmd.c}\\
\ & down\_silently\_base() & stack.c & \cxreffunc{down_silently_base}{stack.c}\\
\ & maintenance\_info\_breakpoints() & breakpoint.c & \cxreffunc{maintenance_info_breakpoints}{breakpoint.c}\\
\ & re\_execute\_command() & infcmd.c & \cxreffunc{re_execute_command}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_radix() & valprint.c & \cxreffunc{set_radix}{valprint.c}\\
\ & show\_commands() & top.c & \cxreffunc{show_commands}{top.c}\\
\ & show\_values() & value.c & \cxreffunc{show_values}{value.c}\\
\ & signal\_command() & infcmd.c & \cxreffunc{signal_command}{infcmd.c}\\
\ & signals\_info() & infrun.c & \cxreffunc{signals_info}{infrun.c}\\
\ & step\_1\_inlining() & infcmd.c & \cxreffunc{step_1_inlining}{infcmd.c}\\
\ & step\_1\_no\_inlining() & infcmd.c & \cxreffunc{step_1_no_inlining}{infcmd.c}\\
\ & trace\_find\_command() & tracepoint.c & \cxreffunc{trace_find_command}{tracepoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & trace\_find\_tracepoint\_command() & tracepoint.c & \cxreffunc{trace_find_tracepoint_command}{tracepoint.c}\\
\ & tracepoints\_info() & tracepoint.c & \cxreffunc{tracepoints_info}{tracepoint.c}\\
\ & up\_silently\_base() & stack.c & \cxreffunc{up_silently_base}{stack.c}\\
Refs Func:\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
Refs Var:\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\end{cxreftabiii}


\subsubsection{Global Function parse\_and\_eval\_type()}
\label{func_parse_and_eval_type_eval.c}

{\stt struct type* parse\_and\_eval\_type ( char* p, int length )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & parse\_expression() & parse.c & \cxreffunc{parse_expression}{parse.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & gdb\_parse\_and\_eval\_type() & wrapper.c & \cxreffunc{gdb_parse_and_eval_type}{wrapper.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\end{cxreftabiii}


\subsubsection{Global Function parse\_to\_comma\_and\_eval()}
\label{func_parse_to_comma_and_eval_eval.c}

{\stt struct value* parse\_to\_comma\_and\_eval ( const char** expp )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_exp\_1() & parse.c & \cxreffunc{parse_exp_1}{parse.c}\\
Called by:\ & printf\_command() & printcmd.c & \cxreffunc{printf_command}{printcmd.c}\\
Refs Func:\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
Refs Var:\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_restore\_print\_closure()}
\label{func_do_restore_print_closure_eval.c}

{\stt static void do\_restore\_print\_closure ( void* in\_oldval )}

\smallskip
\begin{cxreftabiii}
Used in:\ & make\_cleanup\_set\_restore\_print\_closure() & eval.c & \cxreffunc{make_cleanup_set_restore_print_closure}{eval.c}\\
Refs Var:\ & print\_closure & eval.c & \cxrefvar{print_closure}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Local Function evaluate\_struct\_tuple()}
\label{func_evaluate_struct_tuple_eval.c}

{\stt static struct value* evaluate\_struct\_tuple ( struct value* struct\_val, struct expression* exp, int* pos, enum noside noside, int nargs )}

\smallskip
\begin{cxreftabiii}
Prototype:& eval.c & \ & \cxreffile{eval.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & evaluate\_subexp() & eval.c & \cxreffunc{evaluate_subexp}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_label() & eval.c & \cxreffunc{get_label}{eval.c}\\
\ & modify\_field() & value.c & \cxreffunc{modify_field}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_writeable() & value.c & \cxreffunc{value_contents_writeable}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), strcmp()} &\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Local Function evaluate\_subexp()}
\label{func_evaluate_subexp_eval.c}

{\stt static struct value* evaluate\_subexp ( struct type* expect\_type, struct expression* exp, int* pos, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& eval.c & \ & \cxreffile{eval.c}\\
Called by:\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\ & evaluate\_subexp\_for\_address() & eval.c & \cxreffunc{evaluate_subexp_for_address}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_for\_sizeof() & eval.c & \cxreffunc{evaluate_subexp_for_sizeof}{eval.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & evaluate\_subexp\_with\_coercion() & eval.c & \cxreffunc{evaluate_subexp_with_coercion}{eval.c}\\
\ & evaluate\_type() & eval.c & \cxreffunc{evaluate_type}{eval.c}\\
\ & init\_array\_element() & eval.c & \cxreffunc{init_array_element}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Local Function evaluate\_subexp\_for\_address()}
\label{func_evaluate_subexp_for_address_eval.c}

{\stt static struct value* evaluate\_subexp\_for\_address ( struct expression* exp, int* pos, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& eval.c & \ & \cxreffile{eval.c}\\
Calls:\ & block\_innermost\_frame() & blockframe.c & \cxreffunc{block_innermost_frame}{blockframe.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp() & eval.c & \cxreffunc{evaluate_subexp}{eval.c}\\
\ & locate\_var\_value() & findvar.c & \cxreffunc{locate_var_value}{findvar.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function evaluate\_subexp\_for\_sizeof()}
\label{func_evaluate_subexp_for_sizeof_eval.c}

{\stt static struct value* evaluate\_subexp\_for\_sizeof ( struct expression* exp, int* pos )}

\smallskip
\begin{cxreftabiii}
Prototype:& eval.c & \ & \cxreffile{eval.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & evaluate\_subexp() & eval.c & \cxreffunc{evaluate_subexp}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_label()}
\label{func_get_label_eval.c}

{\stt static char* get\_label ( struct expression* exp, int* pos )}

\smallskip
\begin{cxreftabiii}
Prototype:& eval.c & \ & \cxreffile{eval.c}\\
Calls:\ & longest\_to\_int() & valprint.c & \cxreffunc{longest_to_int}{valprint.c}\\
Called by:\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Local Function init\_array\_element()}
\label{func_init_array_element_eval.c}

{\stt static long init\_array\_element ( struct value* array, struct value* element, struct expression* exp, int* pos, enum noside noside, long low\_bound, long high\_bound )}

\smallskip
\begin{cxreftabiii}
Prototype:& eval.c & \ & \cxreffile{eval.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & evaluate\_subexp() & eval.c & \cxreffunc{evaluate_subexp}{eval.c}\\
\ & init\_array\_element() & eval.c & \cxreffunc{init_array_element}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_huge\_valf(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & init\_array\_element() & eval.c & \cxreffunc{init_array_element}{eval.c}\\
\end{cxreftabiii}

