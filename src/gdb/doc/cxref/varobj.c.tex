% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF varobj.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File varobj.c}{File varobj.c}
\section{File varobj.c}
\label{file_varobj.c}

\smallskip
\begin{cxreftabiii}
Refs Func:\ & c\_make\_name\_of\_child() & varobj.c & \cxreffunc{c_make_name_of_child}{varobj.c}\\
\ & c\_number\_of\_children() & varobj.c & \cxreffunc{c_number_of_children}{varobj.c}\\
\ & c\_path\_expr\_of\_child() & varobj.c & \cxreffunc{c_path_expr_of_child}{varobj.c}\\
\ & c\_type\_of\_child() & varobj.c & \cxreffunc{c_type_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\ & c\_value\_of\_root() & varobj.c & \cxreffunc{c_value_of_root}{varobj.c}\\
\ & c\_value\_of\_variable() & varobj.c & \cxreffunc{c_value_of_variable}{varobj.c}\\
\ & c\_variable\_editable() & varobj.c & \cxreffunc{c_variable_editable}{varobj.c}\\
\ & cplus\_make\_name\_of\_child() & varobj.c & \cxreffunc{cplus_make_name_of_child}{varobj.c}\\
\ & cplus\_number\_of\_children() & varobj.c & \cxreffunc{cplus_number_of_children}{varobj.c}\\
\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
\ & cplus\_type\_of\_child() & varobj.c & \cxreffunc{cplus_type_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
\ & cplus\_value\_of\_root() & varobj.c & \cxreffunc{cplus_value_of_root}{varobj.c}\\
\ & cplus\_value\_of\_variable() & varobj.c & \cxreffunc{cplus_value_of_variable}{varobj.c}\\
\ & cplus\_variable\_editable() & varobj.c & \cxreffunc{cplus_variable_editable}{varobj.c}\\
\ & java\_make\_name\_of\_child() & varobj.c & \cxreffunc{java_make_name_of_child}{varobj.c}\\
\ & java\_number\_of\_children() & varobj.c & \cxreffunc{java_number_of_children}{varobj.c}\\
\ & java\_path\_expr\_of\_child() & varobj.c & \cxreffunc{java_path_expr_of_child}{varobj.c}\\
\ & java\_type\_of\_child() & varobj.c & \cxreffunc{java_type_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & java\_value\_of\_child() & varobj.c & \cxreffunc{java_value_of_child}{varobj.c}\\
\ & java\_value\_of\_root() & varobj.c & \cxreffunc{java_value_of_root}{varobj.c}\\
\ & java\_value\_of\_variable() & varobj.c & \cxreffunc{java_value_of_variable}{varobj.c}\\
\ & java\_variable\_editable() & varobj.c & \cxreffunc{java_variable_editable}{varobj.c}\\
\end{cxreftabiii}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "exceptions.h"} &\cxreffile{exceptions.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\hspace*{0.2in}{\stt \#include <setjmp.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.4in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.2in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cp-abi.h"} &\cxreffile{cp-abi.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "wrapper.h"} &\cxreffile{wrapper.h}\\
\hspace*{0.2in}{\stt \#include "gdb.h"} &\cxreffile{gdb.h}\\
\hspace*{0.2in}{\stt \#include "varobj.h"} &\cxreffile{varobj.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "block.h"} &\cxreffile{block.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\hspace*{0.2in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <uuid/uuid.h>} &\\
\hspace*{0.2in}{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/obstack.h"} &\cxreffile{../include/obstack.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <math.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "varobj.h"} &\cxreffile{varobj.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "parser-defs.h"} &\cxreffile{parser-defs.h}\\
\hspace*{0.2in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define VAROBJ\_TABLE\_SIZE 227}

\medskip
{\stt \#define CPLUS\_FAKE\_CHILD( x )}


\subsection{Type definitions}


\subsubsection{Type struct varobj\_root}
\label{type_struct_varobj_root_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct varobj\_root} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct expression* exp;} &\\
\hspace*{0.2in}{\stt struct block* valid\_block;} &\\
\hspace*{0.2in}{\stt struct frame\_id frame;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int use\_selected\_frame;} &\\
\hspace*{0.2in}{\stt int in\_scope;} &\\
\hspace*{0.2in}{\stt struct language\_specific* lang;} &\\
\hspace*{0.2in}{\stt struct varobj* rootvar;} &\\
\hspace*{0.2in}{\stt struct varobj\_root* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum varobj\_join\_type}
\label{type_enum_varobj_join_type_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum varobj\_join\_type} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt VAROBJ\_AS\_DUNNO;} &\\
\hspace*{0.2in}{\stt VAROBJ\_AS\_STRUCT;} &\\
\hspace*{0.2in}{\stt VAROBJ\_AS\_PTR\_TO\_SCALAR;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt VAROBJ\_AS\_PTR\_TO\_STRUCT;} &\\
\hspace*{0.2in}{\stt VAROBJ\_AS\_ARRAY;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct varobj}
\label{type_struct_varobj_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct varobj} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* name;} &\\
\hspace*{0.2in}{\stt char* path\_expr;} &\\
\hspace*{0.2in}{\stt enum varobj\_join\_type join\_in\_expr;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int elide\_in\_expr;} &\\
\hspace*{0.2in}{\stt char* obj\_name;} &\\
\hspace*{0.2in}{\stt int index;} &\\
\hspace*{0.2in}{\stt struct type* type;} &\\
\hspace*{0.2in}{\stt struct type* dynamic\_type;} &\\
\hspace*{0.2in}{\stt char* dynamic\_type\_name;} &\\
\hspace*{0.2in}{\stt struct value* value;} &\\
\hspace*{0.2in}{\stt int error;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int num\_children;} &\\
\hspace*{0.2in}{\stt struct varobj* parent;} &\\
\hspace*{0.2in}{\stt struct varobj\_child* children;} &\\
\hspace*{0.2in}{\stt int fake\_child;} &\\
\hspace*{0.2in}{\stt struct varobj\_root* root;} &\\
\hspace*{0.2in}{\stt enum varobj\_display\_formats format;} &\\
\hspace*{0.2in}{\stt int updated;} &\\
\hspace*{0.2in}{\stt struct objfile\_hitlist* hitlist;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct varobj\_child}
\label{type_struct_varobj_child_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct varobj\_child} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct varobj* child;} &\\
\hspace*{0.2in}{\stt struct varobj\_child* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct vstack}
\label{type_struct_vstack_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct vstack} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct varobj* var;} &\\
\hspace*{0.2in}{\stt struct vstack* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct cpstack}
\label{type_struct_cpstack_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct cpstack} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* name;} &\\
\hspace*{0.2in}{\stt struct cpstack* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct vlist}
\label{type_struct_vlist_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct vlist} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct varobj* var;} &\\
\hspace*{0.2in}{\stt struct vlist* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct varobj\_changelist\_elem}
\label{type_struct_varobj_changelist_elem_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct varobj\_changelist\_elem} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct varobj* var;} &\\
\hspace*{0.2in}{\stt enum varobj\_type\_change type\_changed;} &\\
\hspace*{0.2in}{\stt struct varobj\_changelist\_elem* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct varobj\_changelist}
\label{type_struct_varobj_changelist_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct varobj\_changelist} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct varobj\_changelist\_elem* tail;} &\\
\hspace*{0.2in}{\stt struct varobj\_changelist\_elem* head;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct language\_specific}
\label{type_struct_language_specific_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct language\_specific} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum varobj\_languages language;} &\\
\hspace*{0.2in}{\stt int (*number\_of\_children)(struct varobj* parent);} &\\
\hspace*{0.2in}{\stt const char* (*make\_name\_of\_child)(struct varobj* parent,int index);} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt char* (*path\_expr\_of\_child)(struct varobj* parent,int index);} &\\
\hspace*{0.2in}{\stt struct value* (*value\_of\_root)(struct varobj** root\_handle,enum varobj\_type\_change* type\_changed);} &\\
\hspace*{0.2in}{\stt struct value* (*value\_of\_child)(struct varobj* parent,int index,int* lookup\_dynamic\_type);} &\\
\hspace*{0.2in}{\stt struct type* (*type\_of\_child)(struct varobj* parent,int index);} &\\
\hspace*{0.2in}{\stt int (*variable\_editable)(struct varobj* var);} &\\
\hspace*{0.2in}{\stt char* (*value\_of\_variable)(struct varobj* var);} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum vsections}
\label{type_enum_vsections_varobj.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum vsections} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt v\_public;} &\\
\hspace*{0.2in}{\stt v\_private;} &\\
\hspace*{0.2in}{\stt v\_protected;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable varobj\_format\_string}
\label{var_varobj_format_string_varobj.c}

{\stt const char* varobj\_format\_string[]}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & gdbtypes.c & \ & \cxreffile{gdbtypes.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & varobj.c & \ & \cxreffile{varobj.c}\\
\ & wrapper.c & \ & \cxreffile{wrapper.c}\\
\end{cxreftabiii}


\subsubsection{Variable varobj\_language\_string}
\label{var_varobj_language_string_varobj.c}

{\stt const char* varobj\_language\_string[]}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & gdbtypes.c & \ & \cxreffile{gdbtypes.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & varobj.c & \ & \cxreffile{varobj.c}\\
\ & wrapper.c & \ & \cxreffile{wrapper.c}\\
\end{cxreftabiii}


\subsubsection{Variable varobjdebug}
\label{var_varobjdebug_varobj.c}

{\stt int varobjdebug}

\smallskip
\begin{cxreftabiii}
Visible in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Used in:\ & \_initialize\_varobj() & varobj.c & \cxreffunc{_initialize_varobj}{varobj.c}\\
\ & uninstall\_variable() & varobj.c & \cxreffunc{uninstall_variable}{varobj.c}\\
\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Variable varobj\_runs\_all\_threads}
\label{var_varobj_runs_all_threads_varobj.c}

{\stt int varobj\_runs\_all\_threads}

\smallskip
\begin{cxreftabiii}
Visible in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Used in:\ & \_initialize\_varobj() & varobj.c & \cxreffunc{_initialize_varobj}{varobj.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf varobj\_use\_dynamic\_type}
\label{var_varobj_use_dynamic_type_varobj.c}

{\stt static int varobj\_use\_dynamic\_type}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_varobj() & \ & \cxreffunc{_initialize_varobj}{varobj.c}\\
\ & c\_value\_of\_root() & \ & \cxreffunc{c_value_of_root}{varobj.c}\\
\ & cplus\_path\_expr\_of\_child() & \ & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
\ & get\_type() & \ & \cxreffunc{get_type}{varobj.c}\\
\ & path\_expr\_of\_root() & \ & \cxreffunc{path_expr_of_root}{varobj.c}\\
\ & value\_of\_child() & \ & \cxreffunc{value_of_child}{varobj.c}\\
\ & varobj\_create() & \ & \cxreffunc{varobj_create}{varobj.c}\\
\end{cxreftabiii}

\medskip
{\bf languages}
\label{var_languages_varobj.c}

{\stt static struct language\_specific languages[vlang\_end][sizeof(struct language\_specific)]}

\smallskip
\begin{cxreftabiii}
Used in:\ & varobj\_create() & \ & \cxreffunc{varobj_create}{varobj.c}\\
\end{cxreftabiii}

\medskip
{\bf format\_code}
\label{var_format_code_varobj.c}

{\stt static int format\_code[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & c\_value\_of\_variable() & \ & \cxreffunc{c_value_of_variable}{varobj.c}\\
\end{cxreftabiii}

\medskip
{\bf rootlist}
\label{var_rootlist_varobj.c}

{\stt static struct varobj\_root* rootlist}

\smallskip
\begin{cxreftabiii}
Used in:\ & install\_variable() & \ & \cxreffunc{install_variable}{varobj.c}\\
\ & uninstall\_variable() & \ & \cxreffunc{uninstall_variable}{varobj.c}\\
\ & varobj\_list() & \ & \cxreffunc{varobj_list}{varobj.c}\\
\end{cxreftabiii}

\medskip
{\bf rootcount}
\label{var_rootcount_varobj.c}

{\stt static int rootcount}

\smallskip
\begin{cxreftabiii}
Used in:\ & install\_variable() & \ & \cxreffunc{install_variable}{varobj.c}\\
\ & uninstall\_variable() & \ & \cxreffunc{uninstall_variable}{varobj.c}\\
\ & varobj\_list() & \ & \cxreffunc{varobj_list}{varobj.c}\\
\end{cxreftabiii}

\medskip
{\bf varobj\_table}
\label{var_varobj_table_varobj.c}

{\stt static struct vlist** varobj\_table}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_varobj() & \ & \cxreffunc{_initialize_varobj}{varobj.c}\\
\ & install\_variable() & \ & \cxreffunc{install_variable}{varobj.c}\\
\ & uninstall\_variable() & \ & \cxreffunc{uninstall_variable}{varobj.c}\\
\ & varobj\_get\_handle() & \ & \cxreffunc{varobj_get_handle}{varobj.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_varobj()}
\label{func__initialize_varobj_varobj.c}

{\stt void \_initialize\_varobj ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), add\_setshow\_boolean\_cmd(), add\_setshow\_zinteger\_cmd()} &\\
Refs Func:\ & show\_varobjdebug() & varobj.c & \cxreffunc{show_varobjdebug}{varobj.c}\\
Refs Var:\ & varobj\_runs\_all\_threads & varobj.c & \cxrefvar{varobj_runs_all_threads}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_table & varobj.c & \cxrefvar{varobj_table}{varobj.c}\\
\ & varobj\_use\_dynamic\_type & varobj.c & \cxrefvar{varobj_use_dynamic_type}{varobj.c}\\
\ & varobjdebug & varobj.c & \cxrefvar{varobjdebug}{varobj.c}\\
\ & \cxreftabiiispan{ setdebuglist, setlist, showdebuglist, showlist} &\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_changelist\_pop()}
\label{func_varobj_changelist_pop_varobj.c}

{\stt struct varobj* varobj\_changelist\_pop ( struct varobj\_changelist* changelist, enum varobj\_type\_change* type\_changed )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_create()}
\label{func_varobj_create_varobj.c}

{\stt struct varobj* varobj\_create ( char* objname, const char* expression, CORE\_ADDR frame, struct block* block, enum varobj\_type type )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & discard\_cleanups() & utils.c & \cxreffunc{discard_cleanups}{utils.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & find\_frame\_addr\_in\_frame\_chain() & varobj.c & \cxreffunc{find_frame_addr_in_frame_chain}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & frame\_id\_p() & frame.c & \cxreffunc{frame_id_p}{frame.c}\\
\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
\ & gdb\_value\_fetch\_lazy() & wrapper.c & \cxreffunc{gdb_value_fetch_lazy}{wrapper.c}\\
\ & get\_frame\_block() & blockframe.c & \cxreffunc{get_frame_block}{blockframe.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_frame\_pc() & frame.c & \cxreffunc{get_frame_pc}{frame.c}\\
\ & get\_join\_type() & varobj.c & \cxreffunc{get_join_type}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_selected\_frame() & frame.c & \cxreffunc{get_selected_frame}{frame.c}\\
\ & install\_variable() & varobj.c & \cxreffunc{install_variable}{varobj.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_free\_variable() & varobj.c & \cxreffunc{make_cleanup_free_variable}{varobj.c}\\
\ & make\_cleanup\_objfile\_init\_clear\_hitlist() & objfiles.c & \cxreffunc{make_cleanup_objfile_init_clear_hitlist}{objfiles.c}\\
\ & make\_cleanup\_set\_restore\_scheduler\_locking\_mode() & utils.c & \cxreffunc{make_cleanup_set_restore_scheduler_locking_mode}{utils.c}\\
\ & new\_root\_variable() & varobj.c & \cxreffunc{new_root_variable}{varobj.c}\\
\ & objfile\_detach\_hitlist() & objfiles.c & \cxreffunc{objfile_detach_hitlist}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & variable\_default\_display() & varobj.c & \cxreffunc{variable_default_display}{varobj.c}\\
\ & variable\_language() & varobj.c & \cxreffunc{variable_language}{varobj.c}\\
\ & varobj\_evaluate\_expression() & varobj.c & \cxreffunc{varobj_evaluate_expression}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_evaluate\_type() & varobj.c & \cxreffunc{varobj_evaluate_type}{varobj.c}\\
\ & varobj\_fixup\_value() & varobj.c & \cxreffunc{varobj_fixup_value}{varobj.c}\\
\ & varobj\_parse\_exp\_1() & varobj.c & \cxreffunc{varobj_parse_exp_1}{varobj.c}\\
\ & varobj\_pc\_in\_valid\_block\_p() & varobj.c & \cxreffunc{varobj_pc_in_valid_block_p}{varobj.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
Refs Func:\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
Refs Var:\ & block\_found & symtab.c & \cxrefvar{block_found}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_selected\_frame & frame.c & \cxrefvar{deprecated_selected_frame}{frame.c}\\
\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\ & languages & varobj.c & \cxrefvar{languages}{varobj.c}\\
\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\ & varobj\_runs\_all\_threads & varobj.c & \cxrefvar{varobj_runs_all_threads}{varobj.c}\\
\ & varobj\_use\_dynamic\_type & varobj.c & \cxrefvar{varobj_use_dynamic_type}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_delete()}
\label{func_varobj_delete_varobj.c}

{\stt int varobj\_delete ( struct varobj* var, char*** dellist, int only\_children )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & cppop() & varobj.c & \cxreffunc{cppop}{varobj.c}\\
\ & cppush() & varobj.c & \cxreffunc{cppush}{varobj.c}\\
\ & delete\_variable() & varobj.c & \cxreffunc{delete_variable}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & c\_value\_of\_root() & varobj.c & \cxreffunc{c_value_of_root}{varobj.c}\\
\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
\ & varobj\_delete\_objfiles\_vars() & varobj.c & \cxreffunc{varobj_delete_objfiles_vars}{varobj.c}\\
\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_delete\_objfiles\_vars()}
\label{func_varobj_delete_objfiles_vars_varobj.c}

{\stt void varobj\_delete\_objfiles\_vars ( struct objfile* ofile )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup\_ui\_out\_notify\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_notify_begin_end}{ui-out.c}\\
\ & objfile\_on\_hitlist\_p() & objfiles.c & \cxreffunc{objfile_on_hitlist_p}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\ & varobj\_delete() & varobj.c & \cxreffunc{varobj_delete}{varobj.c}\\
\ & varobj\_list() & varobj.c & \cxreffunc{varobj_list}{varobj.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & free\_objfile\_internal() & objfiles.c & \cxreffunc{free_objfile_internal}{objfiles.c}\\
Refs Var:\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_evaluate\_type()}
\label{func_varobj_evaluate_type_varobj.c}

{\stt int varobj\_evaluate\_type ( struct expression* exp, struct value** value )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & gdb\_evaluate\_type() & wrapper.c & \cxreffunc{gdb_evaluate_type}{wrapper.c}\\
\ & make\_cleanup\_set\_restore\_print\_closure() & eval.c & \cxreffunc{make_cleanup_set_restore_print_closure}{eval.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_gen\_name()}
\label{func_varobj_gen_name_varobj.c}

{\stt char* varobj\_gen\_name ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_attributes()}
\label{func_varobj_get_attributes_varobj.c}

{\stt int varobj\_get\_attributes ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & variable\_editable() & varobj.c & \cxreffunc{variable_editable}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_display\_format()}
\label{func_varobj_get_display_format_varobj.c}

{\stt enum varobj\_display\_formats varobj\_get\_display\_format ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_dynamic\_type()}
\label{func_varobj_get_dynamic_type_varobj.c}

{\stt char* varobj\_get\_dynamic\_type ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & type\_sprint() & typeprint.c & \cxreffunc{type_sprint}{typeprint.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ xstrdup()} &\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_expression()}
\label{func_varobj_get_expression_varobj.c}

{\stt char* varobj\_get\_expression ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & name\_of\_variable() & varobj.c & \cxreffunc{name_of_variable}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_gdb\_type()}
\label{func_varobj_get_gdb_type_varobj.c}

{\stt struct type* varobj\_get\_gdb\_type ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_handle()}
\label{func_varobj_get_handle_varobj.c}

{\stt struct varobj* varobj\_get\_handle ( char* objname )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Refs Var:\ & varobj\_table & varobj.c & \cxrefvar{varobj_table}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_language()}
\label{func_varobj_get_language_varobj.c}

{\stt enum varobj\_languages varobj\_get\_language ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & variable\_language() & varobj.c & \cxreffunc{variable_language}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_num\_children()}
\label{func_varobj_get_num_children_varobj.c}

{\stt int varobj\_get\_num\_children ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & number\_of\_children() & varobj.c & \cxreffunc{number_of_children}{varobj.c}\\
Called by:\ & c\_value\_of\_variable() & varobj.c & \cxreffunc{c_value_of_variable}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_objname()}
\label{func_varobj_get_objname_varobj.c}

{\stt char* varobj\_get\_objname ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_path\_expr()}
\label{func_varobj_get_path_expr_varobj.c}

{\stt char* varobj\_get\_path\_expr ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & path\_expr\_of\_variable() & varobj.c & \cxreffunc{path_expr_of_variable}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_resolved\_type()}
\label{func_varobj_get_resolved_type_varobj.c}

{\stt char* varobj\_get\_resolved\_type ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & varobj\_get\_type\_internal() & varobj.c & \cxreffunc{varobj_get_type_internal}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_type()}
\label{func_varobj_get_type_varobj.c}

{\stt char* varobj\_get\_type ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & varobj\_get\_type\_internal() & varobj.c & \cxreffunc{varobj_get_type_internal}{varobj.c}\\
Called by:\ & varobj\_type\_is\_equal\_p() & varobj.c & \cxreffunc{varobj_type_is_equal_p}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_type\_internal()}
\label{func_varobj_get_type_internal_varobj.c}

{\stt char* varobj\_get\_type\_internal ( struct varobj* var, int check\_typedef\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & remove\_all\_typedefs() & gdbtypes.c & \cxreffunc{remove_all_typedefs}{gdbtypes.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & type\_sprint() & typeprint.c & \cxreffunc{type_sprint}{typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & varobj\_get\_resolved\_type() & varobj.c & \cxreffunc{varobj_get_resolved_type}{varobj.c}\\
\ & varobj\_get\_type() & varobj.c & \cxreffunc{varobj_get_type}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_type\_struct()}
\label{func_varobj_get_type_struct_varobj.c}

{\stt struct type* varobj\_get\_type\_struct ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_valid\_block()}
\label{func_varobj_get_valid_block_varobj.c}

{\stt void varobj\_get\_valid\_block ( struct varobj* var, CORE\_ADDR* start, CORE\_ADDR* end )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_get\_value()}
\label{func_varobj_get_value_varobj.c}

{\stt char* varobj\_get\_value ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & my\_value\_of\_variable() & varobj.c & \cxreffunc{my_value_of_variable}{varobj.c}\\
Called by:\ & gdb\_varobj\_get\_value() & wrapper.c & \cxreffunc{gdb_varobj_get_value}{wrapper.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_in\_scope\_p()}
\label{func_varobj_in_scope_p_varobj.c}

{\stt int varobj\_in\_scope\_p ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_is\_fake\_child()}
\label{func_varobj_is_fake_child_varobj.c}

{\stt int varobj\_is\_fake\_child ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_list()}
\label{func_varobj_list_varobj.c}

{\stt int varobj\_list ( struct varobj*** varlist )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & varobj\_delete\_objfiles\_vars() & varobj.c & \cxreffunc{varobj_delete_objfiles_vars}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & rootcount & varobj.c & \cxrefvar{rootcount}{varobj.c}\\
\ & rootlist & varobj.c & \cxrefvar{rootlist}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_list\_children()}
\label{func_varobj_list_children_varobj.c}

{\stt int varobj\_list\_children ( struct varobj* var, struct varobj*** childlist )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & child\_exists() & varobj.c & \cxreffunc{child_exists}{varobj.c}\\
\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\ & make\_name\_of\_child() & varobj.c & \cxreffunc{make_name_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & number\_of\_children() & varobj.c & \cxreffunc{number_of_children}{varobj.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_parse\_exp\_1()}
\label{func_varobj_parse_exp_1_varobj.c}

{\stt int varobj\_parse\_exp\_1 ( const char** stringptr, struct block* block, int comma, struct expression** expression )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & gdb\_parse\_exp\_1() & wrapper.c & \cxreffunc{gdb_parse_exp_1}{wrapper.c}\\
\ & make\_cleanup\_set\_restore\_print\_closure() & eval.c & \cxreffunc{make_cleanup_set_restore_print_closure}{eval.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\ & varobj\_set\_value() & varobj.c & \cxreffunc{varobj_set_value}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_pc\_in\_valid\_block\_p()}
\label{func_varobj_pc_in_valid_block_p_varobj.c}

{\stt int varobj\_pc\_in\_valid\_block\_p ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & block\_contains\_pc() & block.c & \cxreffunc{block_contains_pc}{block.c}\\
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & frame\_relative\_level() & frame.c & \cxreffunc{frame_relative_level}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_frame\_pc() & frame.c & \cxreffunc{get_frame_pc}{frame.c}\\
Called by:\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_set\_display\_format()}
\label{func_varobj_set_display_format_varobj.c}

{\stt enum varobj\_display\_formats varobj\_set\_display\_format ( struct varobj* var, enum varobj\_display\_formats format )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & variable\_default\_display() & varobj.c & \cxreffunc{variable_default_display}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function varobj\_set\_value()}
\label{func_varobj_set_value_varobj.c}

{\stt int varobj\_set\_value ( struct varobj* var, char* expression )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & gdb\_value\_assign() & wrapper.c & \cxreffunc{gdb_value_assign}{wrapper.c}\\
\ & make\_cleanup\_set\_restore\_scheduler\_locking\_mode() & utils.c & \cxreffunc{make_cleanup_set_restore_scheduler_locking_mode}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & my\_value\_equal() & varobj.c & \cxreffunc{my_value_equal}{varobj.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & variable\_editable() & varobj.c & \cxreffunc{variable_editable}{varobj.c}\\
\ & varobj\_evaluate\_expression() & varobj.c & \cxreffunc{varobj_evaluate_expression}{varobj.c}\\
\ & varobj\_parse\_exp\_1() & varobj.c & \cxreffunc{varobj_parse_exp_1}{varobj.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & input\_radix & valprint.c & \cxrefvar{input_radix}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function varobj\_type\_is\_equal\_p()}
\label{func_varobj_type_is_equal_p_varobj.c}

{\stt int varobj\_type\_is\_equal\_p ( struct varobj* old\_var, struct varobj* new\_var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & varobj\_get\_type() & varobj.c & \cxreffunc{varobj_get_type}{varobj.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function varobj\_update()}
\label{func_varobj_update_varobj.c}

{\stt int varobj\_update ( struct varobj** varp, struct varobj\_changelist** changelist )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.h & \ & \cxreffile{varobj.h}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & gdb\_value\_fetch\_lazy() & wrapper.c & \cxreffunc{gdb_value_fetch_lazy}{wrapper.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & my\_value\_equal() & varobj.c & \cxreffunc{my_value_equal}{varobj.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_of\_child() & varobj.c & \cxreffunc{value_of_child}{varobj.c}\\
\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
\ & varobj\_add\_to\_changelist() & varobj.c & \cxreffunc{varobj_add_to_changelist}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_changelist\_init() & varobj.c & \cxreffunc{varobj_changelist_init}{varobj.c}\\
\ & varobj\_delete() & varobj.c & \cxreffunc{varobj_delete}{varobj.c}\\
\ & varobj\_value\_is\_changeable\_p() & varobj.c & \cxreffunc{varobj_value_is_changeable_p}{varobj.c}\\
\ & vpop() & varobj.c & \cxreffunc{vpop}{varobj.c}\\
\ & vpush() & varobj.c & \cxreffunc{vpush}{varobj.c}\\
Refs Var:\ & deprecated\_selected\_frame & frame.c & \cxrefvar{deprecated_selected_frame}{frame.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & varobjdebug & varobj.c & \cxrefvar{varobjdebug}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function c\_make\_name\_of\_child()}
\label{func_c_make_name_of_child_varobj.c}

{\stt static const char* c\_make\_name\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & get\_target\_type() & varobj.c & \cxreffunc{get_target_type}{varobj.c}\\
\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ strlen(), xstrdup()} &\\
Called by:\ & cplus\_make\_name\_of\_child() & varobj.c & \cxreffunc{cplus_make_name_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function c\_number\_of\_children()}
\label{func_c_number_of_children_varobj.c}

{\stt static int c\_number\_of\_children ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & get\_target\_type() & varobj.c & \cxreffunc{get_target_type}{varobj.c}\\
\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
Called by:\ & cplus\_number\_of\_children() & varobj.c & \cxreffunc{cplus_number_of_children}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function c\_path\_expr\_of\_child()}
\label{func_c_path_expr_of_child_varobj.c}

{\stt static char* c\_path\_expr\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & child\_exists() & varobj.c & \cxreffunc{child_exists}{varobj.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & name\_of\_variable() & varobj.c & \cxreffunc{name_of_variable}{varobj.c}\\
\ & path\_expr\_of\_variable() & varobj.c & \cxreffunc{path_expr_of_variable}{varobj.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), strlen()} &\\
Called by:\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function c\_type\_of\_child()}
\label{func_c_type_of_child_varobj.c}

{\stt static struct type* c\_type\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & child\_exists() & varobj.c & \cxreffunc{child_exists}{varobj.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_target\_type() & varobj.c & \cxreffunc{get_target_type}{varobj.c}\\
\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & name\_of\_variable() & varobj.c & \cxreffunc{name_of_variable}{varobj.c}\\
\ & varobj\_lookup\_struct\_elt\_type\_by\_index() & varobj.c & \cxreffunc{varobj_lookup_struct_elt_type_by_index}{varobj.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & cplus\_type\_of\_child() & varobj.c & \cxreffunc{cplus_type_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function c\_value\_of\_child()}
\label{func_c_value_of_child_varobj.c}

{\stt static struct value* c\_value\_of\_child ( struct varobj* parent, int index, int* lookup\_dynamic\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & child\_exists() & varobj.c & \cxreffunc{child_exists}{varobj.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_value\_ind() & wrapper.c & \cxreffunc{gdb_value_ind}{wrapper.c}\\
\ & gdb\_value\_subscript() & wrapper.c & \cxreffunc{gdb_value_subscript}{wrapper.c}\\
\ & get\_target\_type() & varobj.c & \cxreffunc{get_target_type}{varobj.c}\\
\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & name\_of\_variable() & varobj.c & \cxreffunc{name_of_variable}{varobj.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & varobj\_value\_struct\_elt\_by\_index() & varobj.c & \cxreffunc{varobj_value_struct_elt_by_index}{varobj.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function c\_value\_of\_root()}
\label{func_c_value_of_root_varobj.c}

{\stt static struct value* c\_value\_of\_root ( struct varobj** var\_handle, enum varobj\_type\_change* type\_changed )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & gdb\_value\_fetch\_lazy() & wrapper.c & \cxreffunc{gdb_value_fetch_lazy}{wrapper.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup\_set\_restore\_scheduler\_locking\_mode() & utils.c & \cxreffunc{make_cleanup_set_restore_scheduler_locking_mode}{utils.c}\\
\ & number\_of\_children() & varobj.c & \cxreffunc{number_of_children}{varobj.c}\\
\ & reinit\_frame\_cache() & frame.c & \cxreffunc{reinit_frame_cache}{frame.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & varobj\_delete() & varobj.c & \cxreffunc{varobj_delete}{varobj.c}\\
\ & varobj\_evaluate\_expression() & varobj.c & \cxreffunc{varobj_evaluate_expression}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_fixup\_value() & varobj.c & \cxreffunc{varobj_fixup_value}{varobj.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & cplus\_value\_of\_root() & varobj.c & \cxreffunc{cplus_value_of_root}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Refs Var:\ & varobj\_use\_dynamic\_type & varobj.c & \cxrefvar{varobj_use_dynamic_type}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function c\_value\_of\_variable()}
\label{func_c_value_of_variable_varobj.c}

{\stt static char* c\_value\_of\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & common\_val\_print() & valprint.c & \cxreffunc{common_val_print}{valprint.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & gdb\_value\_fetch\_lazy() & wrapper.c & \cxreffunc{gdb_value_fetch_lazy}{wrapper.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup\_ui\_file\_delete() & utils.c & \cxreffunc{make_cleanup_ui_file_delete}{utils.c}\\
\ & mem\_fileopen() & ui-file.c & \cxreffunc{mem_fileopen}{ui-file.c}\\
\ & ui\_file\_xstrdup() & ui-file.c & \cxreffunc{ui_file_xstrdup}{ui-file.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & varobj\_get\_num\_children() & varobj.c & \cxreffunc{varobj_get_num_children}{varobj.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & cplus\_value\_of\_variable() & varobj.c & \cxreffunc{cplus_value_of_variable}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Refs Var:\ & format\_code & varobj.c & \cxrefvar{format_code}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function c\_variable\_editable()}
\label{func_c_variable_editable_varobj.c}

{\stt static int c\_variable\_editable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & cplus\_variable\_editable() & varobj.c & \cxreffunc{cplus_variable_editable}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function child\_exists()}
\label{func_child_exists_varobj.c}

{\stt static struct varobj* child\_exists ( struct varobj* var, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & c\_path\_expr\_of\_child() & varobj.c & \cxreffunc{c_path_expr_of_child}{varobj.c}\\
\ & c\_type\_of\_child() & varobj.c & \cxreffunc{c_type_of_child}{varobj.c}\\
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
\ & value\_of\_child() & varobj.c & \cxreffunc{value_of_child}{varobj.c}\\
\ & varobj\_list\_children() & varobj.c & \cxreffunc{varobj_list_children}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cplus\_class\_num\_children()}
\label{func_cplus_class_num_children_varobj.c}

{\stt static void cplus\_class\_num\_children ( struct type* type, int children[3] )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & cplus\_make\_name\_of\_child() & varobj.c & \cxreffunc{cplus_make_name_of_child}{varobj.c}\\
\ & cplus\_number\_of\_children() & varobj.c & \cxreffunc{cplus_number_of_children}{varobj.c}\\
\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cplus\_make\_name\_of\_child()}
\label{func_cplus_make_name_of_child_varobj.c}

{\stt static const char* cplus\_make\_name\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & c\_make\_name\_of\_child() & varobj.c & \cxreffunc{c_make_name_of_child}{varobj.c}\\
\ & cplus\_class\_num\_children() & varobj.c & \cxreffunc{cplus_class_num_children}{varobj.c}\\
\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & varobj\_get\_type\_index\_from\_fake\_child() & varobj.c & \cxreffunc{varobj_get_type_index_from_fake_child}{varobj.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & java\_make\_name\_of\_child() & varobj.c & \cxreffunc{java_make_name_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cplus\_number\_of\_children()}
\label{func_cplus_number_of_children_varobj.c}

{\stt static int cplus\_number\_of\_children ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & c\_number\_of\_children() & varobj.c & \cxreffunc{c_number_of_children}{varobj.c}\\
\ & cplus\_class\_num\_children() & varobj.c & \cxreffunc{cplus_class_num_children}{varobj.c}\\
\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & name\_of\_variable() & varobj.c & \cxreffunc{name_of_variable}{varobj.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & java\_number\_of\_children() & varobj.c & \cxreffunc{java_number_of_children}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cplus\_path\_expr\_of\_child()}
\label{func_cplus_path_expr_of_child_varobj.c}

{\stt static char* cplus\_path\_expr\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & c\_path\_expr\_of\_child() & varobj.c & \cxreffunc{c_path_expr_of_child}{varobj.c}\\
\ & child\_exists() & varobj.c & \cxreffunc{child_exists}{varobj.c}\\
\ & cplus\_class\_num\_children() & varobj.c & \cxreffunc{cplus_class_num_children}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & cplus\_real\_type\_index\_for\_fake\_child\_index() & varobj.c & \cxreffunc{cplus_real_type_index_for_fake_child_index}{varobj.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\ & name\_of\_variable() & varobj.c & \cxreffunc{name_of_variable}{varobj.c}\\
\ & path\_expr\_of\_variable() & varobj.c & \cxreffunc{path_expr_of_variable}{varobj.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), strcmp(), strlen()} &\\
Called by:\ & java\_path\_expr\_of\_child() & varobj.c & \cxreffunc{java_path_expr_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\ & varobj\_use\_dynamic\_type & varobj.c & \cxrefvar{varobj_use_dynamic_type}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cplus\_real\_type\_index\_for\_fake\_child\_index()}
\label{func_cplus_real_type_index_for_fake_child_index_varobj.c}

{\stt static int cplus\_real\_type\_index\_for\_fake\_child\_index ( struct type* type, enum vsections prot, int num )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function cplus\_type\_of\_child()}
\label{func_cplus_type_of_child_varobj.c}

{\stt static struct type* cplus\_type\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & c\_type\_of\_child() & varobj.c & \cxreffunc{c_type_of_child}{varobj.c}\\
\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\ & varobj\_lookup\_struct\_elt\_type\_by\_index() & varobj.c & \cxreffunc{varobj_lookup_struct_elt_type_by_index}{varobj.c}\\
Called by:\ & java\_type\_of\_child() & varobj.c & \cxreffunc{java_type_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cplus\_value\_of\_child()}
\label{func_cplus_value_of_child_varobj.c}

{\stt static struct value* cplus\_value\_of\_child ( struct varobj* parent, int index, int* lookup\_dynamic\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\ & child\_exists() & varobj.c & \cxreffunc{child_exists}{varobj.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_value\_struct\_elt\_by\_index() & varobj.c & \cxreffunc{varobj_value_struct_elt_by_index}{varobj.c}\\
Called by:\ & java\_value\_of\_child() & varobj.c & \cxreffunc{java_value_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cplus\_value\_of\_root()}
\label{func_cplus_value_of_root_varobj.c}

{\stt static struct value* cplus\_value\_of\_root ( struct varobj** var\_handle, enum varobj\_type\_change* type\_changed )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & c\_value\_of\_root() & varobj.c & \cxreffunc{c_value_of_root}{varobj.c}\\
Called by:\ & java\_value\_of\_root() & varobj.c & \cxreffunc{java_value_of_root}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function cplus\_value\_of\_variable()}
\label{func_cplus_value_of_variable_varobj.c}

{\stt static char* cplus\_value\_of\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & c\_value\_of\_variable() & varobj.c & \cxreffunc{c_value_of_variable}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & java\_value\_of\_variable() & varobj.c & \cxreffunc{java_value_of_variable}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cplus\_variable\_editable()}
\label{func_cplus_variable_editable_varobj.c}

{\stt static int cplus\_variable\_editable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & c\_variable\_editable() & varobj.c & \cxreffunc{c_variable_editable}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & java\_variable\_editable() & varobj.c & \cxreffunc{java_variable_editable}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cppop()}
\label{func_cppop_varobj.c}

{\stt static char* cppop ( struct cpstack** pstack )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & varobj\_delete() & varobj.c & \cxreffunc{varobj_delete}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cppush()}
\label{func_cppush_varobj.c}

{\stt static void cppush ( struct cpstack** pstack, char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & delete\_variable\_1() & varobj.c & \cxreffunc{delete_variable_1}{varobj.c}\\
\ & varobj\_delete() & varobj.c & \cxreffunc{varobj_delete}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function create\_child()}
\label{func_create_child_varobj.c}

{\stt static struct varobj* create\_child ( struct varobj* parent, int index, const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & get\_join\_type() & varobj.c & \cxreffunc{get_join_type}{varobj.c}\\
\ & get\_target\_type() & varobj.c & \cxreffunc{get_target_type}{varobj.c}\\
\ & install\_variable() & varobj.c & \cxreffunc{install_variable}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & new\_variable() & varobj.c & \cxreffunc{new_variable}{varobj.c}\\
\ & save\_child\_in\_parent() & varobj.c & \cxreffunc{save_child_in_parent}{varobj.c}\\
\ & type\_of\_child() & varobj.c & \cxreffunc{type_of_child}{varobj.c}\\
\ & value\_of\_child() & varobj.c & \cxreffunc{value_of_child}{varobj.c}\\
\ & variable\_language() & varobj.c & \cxreffunc{variable_language}{varobj.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & varobj\_list\_children() & varobj.c & \cxreffunc{varobj_list_children}{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function delete\_variable()}
\label{func_delete_variable_varobj.c}

{\stt static int delete\_variable ( struct cpstack** resultp, struct varobj* var, int only\_children\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & delete\_variable\_1() & varobj.c & \cxreffunc{delete_variable_1}{varobj.c}\\
Called by:\ & varobj\_delete() & varobj.c & \cxreffunc{varobj_delete}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function delete\_variable\_1()}
\label{func_delete_variable_1_varobj.c}

{\stt static void delete\_variable\_1 ( struct cpstack** resultp, int* delcountp, struct varobj* var, int only\_children\_p, int remove\_from\_parent\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cppush() & varobj.c & \cxreffunc{cppush}{varobj.c}\\
\ & delete\_variable\_1() & varobj.c & \cxreffunc{delete_variable_1}{varobj.c}\\
\ & free\_variable() & varobj.c & \cxreffunc{free_variable}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & remove\_child\_from\_parent() & varobj.c & \cxreffunc{remove_child_from_parent}{varobj.c}\\
\ & uninstall\_variable() & varobj.c & \cxreffunc{uninstall_variable}{varobj.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & delete\_variable() & varobj.c & \cxreffunc{delete_variable}{varobj.c}\\
\ & delete\_variable\_1() & varobj.c & \cxreffunc{delete_variable_1}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_free\_variable\_cleanup()}
\label{func_do_free_variable_cleanup_varobj.c}

{\stt static void do\_free\_variable\_cleanup ( void* var )}

\smallskip
\begin{cxreftabiii}
Calls:\ & free\_variable() & varobj.c & \cxreffunc{free_variable}{varobj.c}\\
Used in:\ & make\_cleanup\_free\_variable() & varobj.c & \cxreffunc{make_cleanup_free_variable}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_frame\_addr\_in\_frame\_chain()}
\label{func_find_frame_addr_in_frame_chain_varobj.c}

{\stt static struct frame\_info* find\_frame\_addr\_in\_frame\_chain ( CORE\_ADDR frame\_addr )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_frame\_base\_address() & frame.c & \cxreffunc{get_frame_base_address}{frame.c}\\
\ & get\_prev\_frame() & frame.c & \cxreffunc{get_prev_frame}{frame.c}\\
Called by:\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_variable()}
\label{func_free_variable_varobj.c}

{\stt static void free\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & free\_current\_contents() & utils.c & \cxreffunc{free_current_contents}{utils.c}\\
\ & is\_root\_p() & varobj.c & \cxreffunc{is_root_p}{varobj.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & delete\_variable\_1() & varobj.c & \cxreffunc{delete_variable_1}{varobj.c}\\
\ & do\_free\_variable\_cleanup() & varobj.c & \cxreffunc{do_free_variable_cleanup}{varobj.c}\\
\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_join\_type()}
\label{func_get_join_type_varobj.c}

{\stt static enum varobj\_join\_type get\_join\_type ( struct type* in\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & get\_target\_type() & varobj.c & \cxreffunc{get_target_type}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_target\_type()}
\label{func_get_target_type_varobj.c}

{\stt static struct type* get\_target\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
Called by:\ & c\_make\_name\_of\_child() & varobj.c & \cxreffunc{c_make_name_of_child}{varobj.c}\\
\ & c\_number\_of\_children() & varobj.c & \cxreffunc{c_number_of_children}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & c\_type\_of\_child() & varobj.c & \cxreffunc{c_type_of_child}{varobj.c}\\
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\ & get\_join\_type() & varobj.c & \cxreffunc{get_join_type}{varobj.c}\\
\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\ & varobj\_fixup\_value() & varobj.c & \cxreffunc{varobj_fixup_value}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_type()}
\label{func_get_type_varobj.c}

{\stt static struct type* get\_type ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
Called by:\ & c\_make\_name\_of\_child() & varobj.c & \cxreffunc{c_make_name_of_child}{varobj.c}\\
\ & c\_number\_of\_children() & varobj.c & \cxreffunc{c_number_of_children}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & c\_type\_of\_child() & varobj.c & \cxreffunc{c_type_of_child}{varobj.c}\\
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\ & c\_value\_of\_variable() & varobj.c & \cxreffunc{c_value_of_variable}{varobj.c}\\
\ & c\_variable\_editable() & varobj.c & \cxreffunc{c_variable_editable}{varobj.c}\\
\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
\ & varobj\_get\_type\_struct() & varobj.c & \cxreffunc{varobj_get_type_struct}{varobj.c}\\
\ & varobj\_lookup\_struct\_elt\_type\_by\_index() & varobj.c & \cxreffunc{varobj_lookup_struct_elt_type_by_index}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_value\_is\_changeable\_p() & varobj.c & \cxreffunc{varobj_value_is_changeable_p}{varobj.c}\\
Refs Var:\ & varobj\_use\_dynamic\_type & varobj.c & \cxrefvar{varobj_use_dynamic_type}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_type\_deref()}
\label{func_get_type_deref_varobj.c}

{\stt static struct type* get\_type\_deref ( struct varobj* var, int* was\_ptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & get\_target\_type() & varobj.c & \cxreffunc{get_target_type}{varobj.c}\\
\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & cplus\_make\_name\_of\_child() & varobj.c & \cxreffunc{cplus_make_name_of_child}{varobj.c}\\
\ & cplus\_number\_of\_children() & varobj.c & \cxreffunc{cplus_number_of_children}{varobj.c}\\
\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
\ & cplus\_type\_of\_child() & varobj.c & \cxreffunc{cplus_type_of_child}{varobj.c}\\
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
\ & path\_expr\_of\_root() & varobj.c & \cxreffunc{path_expr_of_root}{varobj.c}\\
\ & varobj\_get\_type\_index\_from\_fake\_child() & varobj.c & \cxreffunc{varobj_get_type_index_from_fake_child}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function install\_variable()}
\label{func_install_variable_varobj.c}

{\stt static int install\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & is\_root\_p() & varobj.c & \cxreffunc{is_root_p}{varobj.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
Refs Var:\ & rootcount & varobj.c & \cxrefvar{rootcount}{varobj.c}\\
\ & rootlist & varobj.c & \cxrefvar{rootlist}{varobj.c}\\
\ & varobj\_table & varobj.c & \cxrefvar{varobj_table}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_root\_p()}
\label{func_is_root_p_varobj.c}

{\stt static int is\_root\_p ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & free\_variable() & varobj.c & \cxreffunc{free_variable}{varobj.c}\\
\ & install\_variable() & varobj.c & \cxreffunc{install_variable}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & path\_expr\_of\_variable() & varobj.c & \cxreffunc{path_expr_of_variable}{varobj.c}\\
\ & uninstall\_variable() & varobj.c & \cxreffunc{uninstall_variable}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function java\_make\_name\_of\_child()}
\label{func_java_make_name_of_child_varobj.c}

{\stt static const char* java\_make\_name\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cplus\_make\_name\_of\_child() & varobj.c & \cxreffunc{cplus_make_name_of_child}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function java\_number\_of\_children()}
\label{func_java_number_of_children_varobj.c}

{\stt static int java\_number\_of\_children ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cplus\_number\_of\_children() & varobj.c & \cxreffunc{cplus_number_of_children}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function java\_path\_expr\_of\_child()}
\label{func_java_path_expr_of_child_varobj.c}

{\stt static char* java\_path\_expr\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function java\_type\_of\_child()}
\label{func_java_type_of_child_varobj.c}

{\stt static struct type* java\_type\_of\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cplus\_type\_of\_child() & varobj.c & \cxreffunc{cplus_type_of_child}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function java\_value\_of\_child()}
\label{func_java_value_of_child_varobj.c}

{\stt static struct value* java\_value\_of\_child ( struct varobj* parent, int index, int* lookup\_dynamic\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function java\_value\_of\_root()}
\label{func_java_value_of_root_varobj.c}

{\stt static struct value* java\_value\_of\_root ( struct varobj** var\_handle, enum varobj\_type\_change* type\_changed )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cplus\_value\_of\_root() & varobj.c & \cxreffunc{cplus_value_of_root}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function java\_value\_of\_variable()}
\label{func_java_value_of_variable_varobj.c}

{\stt static char* java\_value\_of\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cplus\_value\_of\_variable() & varobj.c & \cxreffunc{cplus_value_of_variable}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function java\_variable\_editable()}
\label{func_java_variable_editable_varobj.c}

{\stt static int java\_variable\_editable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & cplus\_variable\_editable() & varobj.c & \cxreffunc{cplus_variable_editable}{varobj.c}\\
Used in:\ & varobj.c & \ & \cxreffile{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function make\_cleanup\_free\_variable()}
\label{func_make_cleanup_free_variable_varobj.c}

{\stt static struct cleanup* make\_cleanup\_free\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
Called by:\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
Refs Func:\ & do\_free\_variable\_cleanup() & varobj.c & \cxreffunc{do_free_variable_cleanup}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function make\_name\_of\_child()}
\label{func_make_name_of_child_varobj.c}

{\stt static const char* make\_name\_of\_child ( struct varobj* var, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & varobj\_list\_children() & varobj.c & \cxreffunc{varobj_list_children}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function my\_value\_equal()}
\label{func_my_value_equal_varobj.c}

{\stt static int my\_value\_equal ( struct value* val1, struct value* volatile val2, int* error2 )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & gdb\_value\_equal() & wrapper.c & \cxreffunc{gdb_value_equal}{wrapper.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & varobj\_set\_value() & varobj.c & \cxreffunc{varobj_set_value}{varobj.c}\\
\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function my\_value\_of\_variable()}
\label{func_my_value_of_variable_varobj.c}

{\stt static char* my\_value\_of\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & varobj\_get\_value() & varobj.c & \cxreffunc{varobj_get_value}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function name\_of\_variable()}
\label{func_name_of_variable_varobj.c}

{\stt static char* name\_of\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & c\_path\_expr\_of\_child() & varobj.c & \cxreffunc{c_path_expr_of_child}{varobj.c}\\
\ & c\_type\_of\_child() & varobj.c & \cxreffunc{c_type_of_child}{varobj.c}\\
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & cplus\_number\_of\_children() & varobj.c & \cxreffunc{cplus_number_of_children}{varobj.c}\\
\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
\ & value\_of\_root() & varobj.c & \cxreffunc{value_of_root}{varobj.c}\\
\ & varobj\_get\_expression() & varobj.c & \cxreffunc{varobj_get_expression}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_root\_variable()}
\label{func_new_root_variable_varobj.c}

{\stt static struct varobj* new\_root\_variable ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & new\_variable() & varobj.c & \cxreffunc{new_variable}{varobj.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_variable()}
\label{func_new_variable_varobj.c}

{\stt static struct varobj* new\_variable ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\ & new\_root\_variable() & varobj.c & \cxreffunc{new_root_variable}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function number\_of\_children()}
\label{func_number_of_children_varobj.c}

{\stt static int number\_of\_children ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & c\_value\_of\_root() & varobj.c & \cxreffunc{c_value_of_root}{varobj.c}\\
\ & varobj\_get\_num\_children() & varobj.c & \cxreffunc{varobj_get_num_children}{varobj.c}\\
\ & varobj\_list\_children() & varobj.c & \cxreffunc{varobj_list_children}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function path\_expr\_of\_child()}
\label{func_path_expr_of_child_varobj.c}

{\stt static char* path\_expr\_of\_child ( struct varobj* var, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & path\_expr\_of\_variable() & varobj.c & \cxreffunc{path_expr_of_variable}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function path\_expr\_of\_root()}
\label{func_path_expr_of_root_varobj.c}

{\stt static char* path\_expr\_of\_root ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), strlen()} &\\
Called by:\ & path\_expr\_of\_variable() & varobj.c & \cxreffunc{path_expr_of_variable}{varobj.c}\\
Refs Var:\ & varobj\_use\_dynamic\_type & varobj.c & \cxrefvar{varobj_use_dynamic_type}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function path\_expr\_of\_variable()}
\label{func_path_expr_of_variable_varobj.c}

{\stt static char* path\_expr\_of\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & is\_root\_p() & varobj.c & \cxreffunc{is_root_p}{varobj.c}\\
\ & path\_expr\_of\_child() & varobj.c & \cxreffunc{path_expr_of_child}{varobj.c}\\
\ & path\_expr\_of\_root() & varobj.c & \cxreffunc{path_expr_of_root}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & path\_expr\_of\_variable() & varobj.c & \cxreffunc{path_expr_of_variable}{varobj.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & c\_path\_expr\_of\_child() & varobj.c & \cxreffunc{c_path_expr_of_child}{varobj.c}\\
\ & cplus\_path\_expr\_of\_child() & varobj.c & \cxreffunc{cplus_path_expr_of_child}{varobj.c}\\
\ & path\_expr\_of\_variable() & varobj.c & \cxreffunc{path_expr_of_variable}{varobj.c}\\
\ & varobj\_get\_path\_expr() & varobj.c & \cxreffunc{varobj_get_path_expr}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remove\_child\_from\_parent()}
\label{func_remove_child_from_parent_varobj.c}

{\stt static void remove\_child\_from\_parent ( struct varobj* parent, struct varobj* child )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & delete\_variable\_1() & varobj.c & \cxreffunc{delete_variable_1}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function safe\_value\_rtti\_target\_type()}
\label{func_safe_value_rtti_target_type_varobj.c}

{\stt static struct type* safe\_value\_rtti\_target\_type ( struct value* val, int* full, int* top, int* using\_enc )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ui\_file\_new() & ui-file.c & \cxreffunc{ui_file_new}{ui-file.c}\\
\ & value\_rtti\_target\_type() & valops.c & \cxreffunc{value_rtti_target_type}{valops.c}\\
\ & \cxreftabiiispan{ exceptions\_state\_mc\_action\_iter(), exceptions\_state\_mc\_action\_iter\_1(), exceptions\_state\_mc\_init(), sigsetjmp()} &\\
Called by:\ & varobj\_fixup\_value() & varobj.c & \cxreffunc{varobj_fixup_value}{varobj.c}\\
Refs Var:\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\cxreftabbreak{cxreftabiii}
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function save\_child\_in\_parent()}
\label{func_save_child_in_parent_varobj.c}

{\stt static void save\_child\_in\_parent ( struct varobj* parent, struct varobj* child )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_varobjdebug()}
\label{func_show_varobjdebug_varobj.c}

{\stt static void show\_varobjdebug ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_varobj() & varobj.c & \cxreffunc{_initialize_varobj}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function type\_of\_child()}
\label{func_type_of_child_varobj.c}

{\stt static struct type* type\_of\_child ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function uninstall\_variable()}
\label{func_uninstall_variable_varobj.c}

{\stt static void uninstall\_variable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & is\_root\_p() & varobj.c & \cxreffunc{is_root_p}{varobj.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & delete\_variable\_1() & varobj.c & \cxreffunc{delete_variable_1}{varobj.c}\\
Refs Var:\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & rootcount & varobj.c & \cxrefvar{rootcount}{varobj.c}\\
\ & rootlist & varobj.c & \cxrefvar{rootlist}{varobj.c}\\
\ & varobj\_table & varobj.c & \cxrefvar{varobj_table}{varobj.c}\\
\ & varobjdebug & varobj.c & \cxrefvar{varobjdebug}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function value\_of\_child()}
\label{func_value_of_child_varobj.c}

{\stt static struct value* value\_of\_child ( struct varobj* parent, int index, enum varobj\_type\_change* type\_changed )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & child\_exists() & varobj.c & \cxreffunc{child_exists}{varobj.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdb\_value\_fetch\_lazy() & wrapper.c & \cxreffunc{gdb_value_fetch_lazy}{wrapper.c}\\
\cxreftabbreak{cxreftabiii}
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & varobj\_fixup\_value() & varobj.c & \cxreffunc{varobj_fixup_value}{varobj.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
Refs Var:\ & varobj\_use\_dynamic\_type & varobj.c & \cxrefvar{varobj_use_dynamic_type}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function value\_of\_root()}
\label{func_value_of_root_varobj.c}

{\stt static struct value* value\_of\_root ( struct varobj** var\_handle, enum varobj\_type\_change* type\_changed )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & frame\_id\_eq() & frame.c & \cxreffunc{frame_id_eq}{frame.c}\\
\ & free\_variable() & varobj.c & \cxreffunc{free_variable}{varobj.c}\\
\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & install\_variable() & varobj.c & \cxreffunc{install_variable}{varobj.c}\\
\ & name\_of\_variable() & varobj.c & \cxreffunc{name_of_variable}{varobj.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\ & varobj\_delete() & varobj.c & \cxreffunc{varobj_delete}{varobj.c}\\
\ & varobj\_pc\_in\_valid\_block\_p() & varobj.c & \cxreffunc{varobj_pc_in_valid_block_p}{varobj.c}\\
\ & varobj\_type\_is\_equal\_p() & varobj.c & \cxreffunc{varobj_type_is_equal_p}{varobj.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function variable\_default\_display()}
\label{func_variable_default_display_varobj.c}

{\stt static enum varobj\_display\_formats variable\_default\_display ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\ & varobj\_set\_display\_format() & varobj.c & \cxreffunc{varobj_set_display_format}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function variable\_editable()}
\label{func_variable_editable_varobj.c}

{\stt static int variable\_editable ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & varobj\_get\_attributes() & varobj.c & \cxreffunc{varobj_get_attributes}{varobj.c}\\
\ & varobj\_set\_value() & varobj.c & \cxreffunc{varobj_set_value}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function variable\_language()}
\label{func_variable_language_varobj.c}

{\stt static enum varobj\_languages variable\_language ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Called by:\ & create\_child() & varobj.c & \cxreffunc{create_child}{varobj.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\ & varobj\_get\_language() & varobj.c & \cxreffunc{varobj_get_language}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function varobj\_add\_to\_changelist()}
\label{func_varobj_add_to_changelist_varobj.c}

{\stt static void varobj\_add\_to\_changelist ( struct varobj\_changelist* changelist, struct varobj* var, enum varobj\_type\_change type\_changed )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function varobj\_changelist\_init()}
\label{func_varobj_changelist_init_varobj.c}

{\stt static struct varobj\_changelist* varobj\_changelist\_init ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function varobj\_evaluate\_expression()}
\label{func_varobj_evaluate_expression_varobj.c}

{\stt static int varobj\_evaluate\_expression ( struct expression* exp, struct value** value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & gdb\_evaluate\_expression() & wrapper.c & \cxreffunc{gdb_evaluate_expression}{wrapper.c}\\
\ & make\_cleanup\_set\_restore\_print\_closure() & eval.c & \cxreffunc{make_cleanup_set_restore_print_closure}{eval.c}\\
Called by:\ & c\_value\_of\_root() & varobj.c & \cxreffunc{c_value_of_root}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\ & varobj\_set\_value() & varobj.c & \cxreffunc{varobj_set_value}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function varobj\_fixup\_value()}
\label{func_varobj_fixup_value_varobj.c}

{\stt static struct value* varobj\_fixup\_value ( struct value* in\_value, int use\_dynamic\_type, struct block* block, struct type** dynamic\_type\_handle, char** dynamic\_type\_name )}

\smallskip
\begin{cxreftabiii}
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & gdb\_value\_cast() & wrapper.c & \cxreffunc{gdb_value_cast}{wrapper.c}\\
\ & get\_closure\_dynamic\_type() & gdbtypes.c & \cxreffunc{get_closure_dynamic_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_target\_type() & varobj.c & \cxreffunc{get_target_type}{varobj.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\ & safe\_value\_objc\_target\_type() & wrapper.c & \cxreffunc{safe_value_objc_target_type}{wrapper.c}\\
\ & safe\_value\_rtti\_target\_type() & varobj.c & \cxreffunc{safe_value_rtti_target_type}{varobj.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memmove\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memmove\_chk(), \_\_inline\_strcpy\_chk(), strlen()} &\\
Called by:\ & c\_value\_of\_root() & varobj.c & \cxreffunc{c_value_of_root}{varobj.c}\\
\ & value\_of\_child() & varobj.c & \cxreffunc{value_of_child}{varobj.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function varobj\_get\_type\_index\_from\_fake\_child()}
\label{func_varobj_get_type_index_from_fake_child_varobj.c}

{\stt static int varobj\_get\_type\_index\_from\_fake\_child ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & get\_type\_deref() & varobj.c & \cxreffunc{get_type_deref}{varobj.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & cplus\_make\_name\_of\_child() & varobj.c & \cxreffunc{cplus_make_name_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_lookup\_struct\_elt\_type\_by\_index() & varobj.c & \cxreffunc{varobj_lookup_struct_elt_type_by_index}{varobj.c}\\
\ & varobj\_value\_struct\_elt\_by\_index() & varobj.c & \cxreffunc{varobj_value_struct_elt_by_index}{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function varobj\_lookup\_struct\_elt\_type\_by\_index()}
\label{func_varobj_lookup_struct_elt_type_by_index_varobj.c}

{\stt static struct type* varobj\_lookup\_struct\_elt\_type\_by\_index ( struct varobj* parent, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & type\_sprint() & typeprint.c & \cxreffunc{type_sprint}{typeprint.c}\\
\ & varobj\_get\_type\_index\_from\_fake\_child() & varobj.c & \cxreffunc{varobj_get_type_index_from_fake_child}{varobj.c}\\
Called by:\ & c\_type\_of\_child() & varobj.c & \cxreffunc{c_type_of_child}{varobj.c}\\
\ & cplus\_type\_of\_child() & varobj.c & \cxreffunc{cplus_type_of_child}{varobj.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function varobj\_value\_is\_changeable\_p()}
\label{func_varobj_value_is_changeable_p_varobj.c}

{\stt static int varobj\_value\_is\_changeable\_p ( struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & get\_type() & varobj.c & \cxreffunc{get_type}{varobj.c}\\
Called by:\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function varobj\_value\_struct\_elt\_by\_index()}
\label{func_varobj_value_struct_elt_by_index_varobj.c}

{\stt static int varobj\_value\_struct\_elt\_by\_index ( struct varobj* parent, volatile int iindex, struct value** ret\_val )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_static\_field() & value.c & \cxreffunc{value_static_field}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & varobj\_get\_type\_index\_from\_fake\_child() & varobj.c & \cxreffunc{varobj_get_type_index_from_fake_child}{varobj.c}\\
\ & \cxreftabiiispan{ exceptions\_state\_mc\_action\_iter(), exceptions\_state\_mc\_action\_iter\_1(), exceptions\_state\_mc\_init(), sigsetjmp()} &\\
Called by:\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
Refs Var:\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function vpop()}
\label{func_vpop_varobj.c}

{\stt static struct varobj* vpop ( struct vstack** pstack )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function vpush()}
\label{func_vpush_varobj.c}

{\stt static void vpush ( struct vstack** pstack, struct varobj* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& varobj.c & \ & \cxreffile{varobj.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\end{cxreftabiii}

