% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF mdebugread.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File mdebugread.c}{File mdebugread.c}
\section{File mdebugread.c}
\label{file_mdebugread.c}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcore.h"} &\cxreffile{gdbcore.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <uuid/uuid.h>} &\\
\hspace*{0.2in}{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/obstack.h"} &\cxreffile{../include/obstack.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.8in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{1.0in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{1.0in}{\stt \#include <regex.h>} &\\
\hspace*{0.8in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.8in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.8in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{1.0in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "buildsym.h"} &\cxreffile{buildsym.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "stabsread.h"} &\cxreffile{stabsread.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "complaints.h"} &\cxreffile{complaints.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/demangle.h"} &\cxreffile{../include/demangle.h}\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "block.h"} &\cxreffile{block.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "dictionary.h"} &\cxreffile{dictionary.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "mdebugread.h"} &\cxreffile{mdebugread.h}\\
\hspace*{0.2in}{\stt \#include "../include/coff/sym.h"} &\cxreffile{../include/coff/sym.h}\\
\hspace*{0.2in}{\stt \#include "../include/coff/symconst.h"} &\cxreffile{../include/coff/symconst.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_stat.h"} &\cxreffile{gdb_stat.h}\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/stat.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/coff/ecoff.h"} &\cxreffile{../include/coff/ecoff.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../bfd/libaout.h"} &\cxreffile{../bfd/libaout.h}\\
\hspace*{0.2in}{\stt \#include "../include/bfdlink.h"} &\cxreffile{../include/bfdlink.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/aout/aout64.h"} &\cxreffile{../include/aout/aout64.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/aout/stab\_gnu.h"} &\cxreffile{../include/aout/stab_gnu.h}\\
\hspace*{0.2in}{\stt \#include "../include/aout/stab.def"} &\cxreffile{../include/aout/stab.def}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define ECOFF\_IN\_ELF( bfd )}

\medskip
{\stt \#define PST\_PRIVATE( p )}

\medskip
{\stt \#define FDR\_IDX( p )}

\medskip
{\stt \#define CUR\_BFD( p )}

\medskip
{\stt \#define DEBUG\_SWAP( p )}

\medskip
{\stt \#define DEBUG\_INFO( p )}

\medskip
{\stt \#define PENDING\_LIST( p )}

\medskip
{\stt \#define SC\_IS\_TEXT( sc )}

\medskip
{\stt \#define SC\_IS\_DATA( sc )}

\medskip
{\stt \#define SC\_IS\_COMMON( sc )}

\medskip
{\stt \#define SC\_IS\_BSS( sc )}

\medskip
{\stt \#define SC\_IS\_SBSS( sc )}

\medskip
{\stt \#define SC\_IS\_UNDEF( sc )}

\medskip
{\stt \#define MIN\_GLEVEL GLEVEL\_0}

\medskip
{\stt \#define compare\_glevel( a, b )}

\medskip
{\stt \#define mdebug\_type\_int mdebug\_type\_int\_32}

\medskip
{\stt \#define PARSE\_TQ( tq )}


\subsection{Type definitions}


\subsubsection{Type struct symloc}
\label{type_struct_symloc_mdebugread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct symloc} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt int fdr\_idx;} &\\
\hspace*{0.2in}{\stt bfd* cur\_bfd;} &\\
\hspace*{0.2in}{\stt const struct ecoff\_debug\_swap* debug\_swap;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct ecoff\_debug\_info* debug\_info;} &\\
\hspace*{0.2in}{\stt struct mdebug\_pending** pending\_list;} &\\
\hspace*{0.2in}{\stt EXTR* extern\_tab;} &\\
\hspace*{0.2in}{\stt int extern\_count;} &\\
\hspace*{0.2in}{\stt enum language pst\_language;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum block\_type}
\label{type_enum_block_type_mdebugread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum block\_type} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt FUNCTION\_BLOCK;} &\\
\hspace*{0.2in}{\stt NON\_FUNCTION\_BLOCK;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct pst\_map}
\label{type_struct_pst_map_mdebugread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct pst\_map} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct partial\_symtab* pst;} &\\
\hspace*{0.2in}{\stt long n\_globals;} &\\
\hspace*{0.2in}{\stt long globals\_offset;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct parse\_stack}
\label{type_struct_parse_stack_mdebugread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct parse\_stack} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct parse\_stack* next;} &\\
\hspace*{0.2in}{\stt struct parse\_stack* prev;} &\\
\hspace*{0.2in}{\stt struct symtab* cur\_st;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct block* cur\_block;} &\\
\hspace*{0.2in}{\stt int blocktype;} &\\
\hspace*{0.2in}{\stt struct type* cur\_type;} &\\
\hspace*{0.2in}{\stt int cur\_field;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR procadr;} &\\
\hspace*{0.2in}{\stt int numargs;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct mdebug\_pending}
\label{type_struct_mdebug_pending_mdebugread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct mdebug\_pending} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct mdebug\_pending* next;} &\\
\hspace*{0.2in}{\stt char* s;} &\\
\hspace*{0.2in}{\stt struct type* t;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Local Variables}

{\bf psymtab\_language}
\label{var_psymtab_language_mdebugread.c}

{\stt static enum language psymtab\_language}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_psymbol\_enumerators() & \ & \cxreffunc{handle_psymbol_enumerators}{mdebugread.c}\\
\ & new\_symbol() & \ & \cxreffunc{new_symbol}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf cur\_bfd}
\label{var_cur_bfd_mdebugread.c}

{\stt static bfd* cur\_bfd}

\smallskip
\begin{cxreftabiii}
Used in:\ & cross\_ref() & \ & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & get\_rfd() & \ & \cxreffunc{get_rfd}{mdebugread.c}\\
\ & handle\_psymbol\_enumerators() & \ & \cxreffunc{handle_psymbol_enumerators}{mdebugread.c}\\
\ & mdebug\_build\_psymtabs() & \ & \cxreffunc{mdebug_build_psymtabs}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_next\_symbol\_text() & \ & \cxreffunc{mdebug_next_symbol_text}{mdebugread.c}\\
\ & new\_psymtab() & \ & \cxreffunc{new_psymtab}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_procedure() & \ & \cxreffunc{parse_procedure}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\ & record\_minimal\_symbol() & \ & \cxreffunc{record_minimal_symbol}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf debug\_swap}
\label{var_debug_swap_mdebugread.c}

{\stt static const struct ecoff\_debug\_swap* debug\_swap}

\smallskip
\begin{cxreftabiii}
Used in:\ & cross\_ref() & \ & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & get\_rfd() & \ & \cxreffunc{get_rfd}{mdebugread.c}\\
\ & handle\_psymbol\_enumerators() & \ & \cxreffunc{handle_psymbol_enumerators}{mdebugread.c}\\
\ & has\_opaque\_xref() & \ & \cxreffunc{has_opaque_xref}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_build\_psymtabs() & \ & \cxreffunc{mdebug_build_psymtabs}{mdebugread.c}\\
\ & mdebug\_next\_symbol\_text() & \ & \cxreffunc{mdebug_next_symbol_text}{mdebugread.c}\\
\ & new\_psymtab() & \ & \cxreffunc{new_psymtab}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & parse\_procedure() & \ & \cxreffunc{parse_procedure}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\ & upgrade\_type() & \ & \cxreffunc{upgrade_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf debug\_info}
\label{var_debug_info_mdebugread.c}

{\stt static struct ecoff\_debug\_info* debug\_info}

\smallskip
\begin{cxreftabiii}
Used in:\ & add\_pending() & \ & \cxreffunc{add_pending}{mdebugread.c}\\
\ & cross\_ref() & \ & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & fdr\_name() & \ & \cxreffunc{fdr_name}{mdebugread.c}\\
\ & get\_rfd() & \ & \cxreffunc{get_rfd}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & handle\_psymbol\_enumerators() & \ & \cxreffunc{handle_psymbol_enumerators}{mdebugread.c}\\
\ & has\_opaque\_xref() & \ & \cxreffunc{has_opaque_xref}{mdebugread.c}\\
\ & is\_pending\_symbol() & \ & \cxreffunc{is_pending_symbol}{mdebugread.c}\\
\ & mdebug\_build\_psymtabs() & \ & \cxreffunc{mdebug_build_psymtabs}{mdebugread.c}\\
\ & mdebug\_next\_symbol\_text() & \ & \cxreffunc{mdebug_next_symbol_text}{mdebugread.c}\\
\ & new\_psymtab() & \ & \cxreffunc{new_psymtab}{mdebugread.c}\\
\ & parse\_external() & \ & \cxreffunc{parse_external}{mdebugread.c}\\
\ & parse\_lines() & \ & \cxreffunc{parse_lines}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & parse\_procedure() & \ & \cxreffunc{parse_procedure}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\ & upgrade\_type() & \ & \cxreffunc{upgrade_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf cur\_fdr}
\label{var_cur_fdr_mdebugread.c}

{\stt static FDR* cur\_fdr}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_psymbol\_enumerators() & \ & \cxreffunc{handle_psymbol_enumerators}{mdebugread.c}\\
\ & mdebug\_next\_symbol\_text() & \ & \cxreffunc{mdebug_next_symbol_text}{mdebugread.c}\\
\ & parse\_external() & \ & \cxreffunc{parse_external}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & parse\_procedure() & \ & \cxreffunc{parse_procedure}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf cur\_fd}
\label{var_cur_fd_mdebugread.c}

{\stt static int cur\_fd}

\smallskip
\begin{cxreftabiii}
Used in:\ & parse\_external() & \ & \cxreffunc{parse_external}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf cur\_sdx}
\label{var_cur_sdx_mdebugread.c}

{\stt static int cur\_sdx}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_psymbol\_enumerators() & \ & \cxreffunc{handle_psymbol_enumerators}{mdebugread.c}\\
\ & mdebug\_next\_symbol\_text() & \ & \cxreffunc{mdebug_next_symbol_text}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf max\_gdbinfo}
\label{var_max_gdbinfo_mdebugread.c}

{\stt static int max\_gdbinfo}

\smallskip
\begin{cxreftabiii}
Used in:\ & mdebug\_build\_psymtabs() & \ & \cxreffunc{mdebug_build_psymtabs}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf max\_glevel}
\label{var_max_glevel_mdebugread.c}

{\stt static int max\_glevel}

\smallskip
\begin{cxreftabiii}
Used in:\ & mdebug\_build\_psymtabs() & \ & \cxreffunc{mdebug_build_psymtabs}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf n\_undef\_symbols}
\label{var_n_undef_symbols_mdebugread.c}

{\stt static int n\_undef\_symbols}

\smallskip
\begin{cxreftabiii}
Used in:\ & parse\_external() & \ & \cxreffunc{parse_external}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf n\_undef\_labels}
\label{var_n_undef_labels_mdebugread.c}

{\stt static int n\_undef\_labels}

\smallskip
\begin{cxreftabiii}
Used in:\ & parse\_external() & \ & \cxreffunc{parse_external}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf n\_undef\_vars}
\label{var_n_undef_vars_mdebugread.c}

{\stt static int n\_undef\_vars}

\smallskip
\begin{cxreftabiii}
Used in:\ & parse\_external() & \ & \cxreffunc{parse_external}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf n\_undef\_procs}
\label{var_n_undef_procs_mdebugread.c}

{\stt static int n\_undef\_procs}

\smallskip
\begin{cxreftabiii}
Used in:\ & parse\_external() & \ & \cxreffunc{parse_external}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf stabs\_symbol}
\label{var_stabs_symbol_mdebugread.c}

{\stt static char stabs\_symbol[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_void}
\label{var_mdebug_type_void_mdebugread.c}

{\stt static struct type* mdebug\_type\_void}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_char}
\label{var_mdebug_type_char_mdebugread.c}

{\stt static struct type* mdebug\_type\_char}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_short}
\label{var_mdebug_type_short_mdebugread.c}

{\stt static struct type* mdebug\_type\_short}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_int\_32}
\label{var_mdebug_type_int_32_mdebugread.c}

{\stt static struct type* mdebug\_type\_int\_32}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\ & upgrade\_type() & \ & \cxreffunc{upgrade_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_int\_64}
\label{var_mdebug_type_int_64_mdebugread.c}

{\stt static struct type* mdebug\_type\_int\_64}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_long\_32}
\label{var_mdebug_type_long_32_mdebugread.c}

{\stt static struct type* mdebug\_type\_long\_32}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_long\_64}
\label{var_mdebug_type_long_64_mdebugread.c}

{\stt static struct type* mdebug\_type\_long\_64}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_long\_long\_64}
\label{var_mdebug_type_long_long_64_mdebugread.c}

{\stt static struct type* mdebug\_type\_long\_long\_64}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_unsigned\_char}
\label{var_mdebug_type_unsigned_char_mdebugread.c}

{\stt static struct type* mdebug\_type\_unsigned\_char}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_unsigned\_short}
\label{var_mdebug_type_unsigned_short_mdebugread.c}

{\stt static struct type* mdebug\_type\_unsigned\_short}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_unsigned\_int\_32}
\label{var_mdebug_type_unsigned_int_32_mdebugread.c}

{\stt static struct type* mdebug\_type\_unsigned\_int\_32}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_unsigned\_int\_64}
\label{var_mdebug_type_unsigned_int_64_mdebugread.c}

{\stt static struct type* mdebug\_type\_unsigned\_int\_64}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_unsigned\_long\_32}
\label{var_mdebug_type_unsigned_long_32_mdebugread.c}

{\stt static struct type* mdebug\_type\_unsigned\_long\_32}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_unsigned\_long\_64}
\label{var_mdebug_type_unsigned_long_64_mdebugread.c}

{\stt static struct type* mdebug\_type\_unsigned\_long\_64}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_unsigned\_long\_long\_64}
\label{var_mdebug_type_unsigned_long_long_64_mdebugread.c}

{\stt static struct type* mdebug\_type\_unsigned\_long\_long\_64}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_adr\_32}
\label{var_mdebug_type_adr_32_mdebugread.c}

{\stt static struct type* mdebug\_type\_adr\_32}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_adr\_64}
\label{var_mdebug_type_adr_64_mdebugread.c}

{\stt static struct type* mdebug\_type\_adr\_64}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_float}
\label{var_mdebug_type_float_mdebugread.c}

{\stt static struct type* mdebug\_type\_float}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_double}
\label{var_mdebug_type_double_mdebugread.c}

{\stt static struct type* mdebug\_type\_double}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_complex}
\label{var_mdebug_type_complex_mdebugread.c}

{\stt static struct type* mdebug\_type\_complex}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_double\_complex}
\label{var_mdebug_type_double_complex_mdebugread.c}

{\stt static struct type* mdebug\_type\_double\_complex}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_fixed\_dec}
\label{var_mdebug_type_fixed_dec_mdebugread.c}

{\stt static struct type* mdebug\_type\_fixed\_dec}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_float\_dec}
\label{var_mdebug_type_float_dec_mdebugread.c}

{\stt static struct type* mdebug\_type\_float\_dec}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf mdebug\_type\_string}
\label{var_mdebug_type_string_mdebugread.c}

{\stt static struct type* mdebug\_type\_string}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_type() & \ & \cxreffunc{parse_type}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf nodebug\_func\_symbol\_type}
\label{var_nodebug_func_symbol_type_mdebugread.c}

{\stt static struct type* nodebug\_func\_symbol\_type}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_procedure() & \ & \cxreffunc{parse_procedure}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf nodebug\_var\_symbol\_type}
\label{var_nodebug_var_symbol_type_mdebugread.c}

{\stt static struct type* nodebug\_var\_symbol\_type}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_mdebugread() & \ & \cxreffunc{_initialize_mdebugread}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf found\_ecoff\_debugging\_info}
\label{var_found_ecoff_debugging_info_mdebugread.c}

{\stt static int found\_ecoff\_debugging\_info}

\smallskip
\begin{cxreftabiii}
Used in:\ & parse\_procedure() & \ & \cxreffunc{parse_procedure}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf top\_stack}
\label{var_top_stack_mdebugread.c}

{\stt static struct parse\_stack* top\_stack}

\smallskip
\begin{cxreftabiii}
Used in:\ & parse\_procedure() & \ & \cxreffunc{parse_procedure}{mdebugread.c}\\
\ & parse\_symbol() & \ & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & pop\_parse\_stack() & \ & \cxreffunc{pop_parse_stack}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\ & push\_parse\_stack() & \ & \cxreffunc{push_parse_stack}{mdebugread.c}\\
\end{cxreftabiii}

\medskip
{\bf pending\_list}
\label{var_pending_list_mdebugread.c}

{\stt static struct mdebug\_pending** pending\_list}

\smallskip
\begin{cxreftabiii}
Used in:\ & add\_pending() & \ & \cxreffunc{add_pending}{mdebugread.c}\\
\ & is\_pending\_symbol() & \ & \cxreffunc{is_pending_symbol}{mdebugread.c}\\
\ & new\_psymtab() & \ & \cxreffunc{new_psymtab}{mdebugread.c}\\
\ & parse\_partial\_symbols() & \ & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_mdebugread()}
\label{func__initialize_mdebugread_mdebugread.c}

{\stt void \_initialize\_mdebugread ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & gdbarch\_double\_bit() & gdbarch.c & \cxreffunc{gdbarch_double_bit}{gdbarch.c}\\
\ & gdbarch\_float\_bit() & gdbarch.c & \cxreffunc{gdbarch_float_bit}{gdbarch.c}\\
\ & gdbarch\_int\_bit() & gdbarch.c & \cxreffunc{gdbarch_int_bit}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & mdebug\_type\_adr\_32 & mdebugread.c & \cxrefvar{mdebug_type_adr_32}{mdebugread.c}\\
\ & mdebug\_type\_adr\_64 & mdebugread.c & \cxrefvar{mdebug_type_adr_64}{mdebugread.c}\\
\ & mdebug\_type\_char & mdebugread.c & \cxrefvar{mdebug_type_char}{mdebugread.c}\\
\ & mdebug\_type\_complex & mdebugread.c & \cxrefvar{mdebug_type_complex}{mdebugread.c}\\
\ & mdebug\_type\_double & mdebugread.c & \cxrefvar{mdebug_type_double}{mdebugread.c}\\
\ & mdebug\_type\_double\_complex & mdebugread.c & \cxrefvar{mdebug_type_double_complex}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_type\_fixed\_dec & mdebugread.c & \cxrefvar{mdebug_type_fixed_dec}{mdebugread.c}\\
\ & mdebug\_type\_float & mdebugread.c & \cxrefvar{mdebug_type_float}{mdebugread.c}\\
\ & mdebug\_type\_float\_dec & mdebugread.c & \cxrefvar{mdebug_type_float_dec}{mdebugread.c}\\
\ & mdebug\_type\_int\_32 & mdebugread.c & \cxrefvar{mdebug_type_int_32}{mdebugread.c}\\
\ & mdebug\_type\_int\_64 & mdebugread.c & \cxrefvar{mdebug_type_int_64}{mdebugread.c}\\
\ & mdebug\_type\_long\_32 & mdebugread.c & \cxrefvar{mdebug_type_long_32}{mdebugread.c}\\
\ & mdebug\_type\_long\_64 & mdebugread.c & \cxrefvar{mdebug_type_long_64}{mdebugread.c}\\
\ & mdebug\_type\_long\_long\_64 & mdebugread.c & \cxrefvar{mdebug_type_long_long_64}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_type\_short & mdebugread.c & \cxrefvar{mdebug_type_short}{mdebugread.c}\\
\ & mdebug\_type\_string & mdebugread.c & \cxrefvar{mdebug_type_string}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_char & mdebugread.c & \cxrefvar{mdebug_type_unsigned_char}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_int\_32 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_int_32}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_int\_64 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_int_64}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_long\_32 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_long_32}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_long\_64 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_long_64}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_long\_long\_64 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_long_long_64}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_type\_unsigned\_short & mdebugread.c & \cxrefvar{mdebug_type_unsigned_short}{mdebugread.c}\\
\ & mdebug\_type\_void & mdebugread.c & \cxrefvar{mdebug_type_void}{mdebugread.c}\\
\ & nodebug\_func\_symbol\_type & mdebugread.c & \cxrefvar{nodebug_func_symbol_type}{mdebugread.c}\\
\ & nodebug\_var\_symbol\_type & mdebugread.c & \cxrefvar{nodebug_var_symbol_type}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function elfmdebug\_build\_psymtabs()}
\label{func_elfmdebug_build_psymtabs_mdebugread.c}

{\stt void elfmdebug\_build\_psymtabs ( struct objfile* objfile, const struct ecoff\_debug\_swap* swap, asection* sec )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & init\_minimal\_symbol\_collection() & minsyms.c & \cxreffunc{init_minimal_symbol_collection}{minsyms.c}\\
\cxreftabbreak{cxreftabiii}
\ & install\_minimal\_symbols() & minsyms.c & \cxreffunc{install_minimal_symbols}{minsyms.c}\\
\ & make\_cleanup\_discard\_minimal\_symbols() & minsyms.c & \cxreffunc{make_cleanup_discard_minimal_symbols}{minsyms.c}\\
\ & mdebug\_build\_psymtabs() & mdebugread.c & \cxreffunc{mdebug_build_psymtabs}{mdebugread.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk(), bfd\_errmsg(), bfd\_get\_error()} &\\
Called by:\ & elf\_symfile\_read() & elfread.c & \cxreffunc{elf_symfile_read}{elfread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function mdebug\_build\_psymtabs()}
\label{func_mdebug_build_psymtabs_mdebugread.c}

{\stt void mdebug\_build\_psymtabs ( struct objfile* objfile, const struct ecoff\_debug\_swap* swap, struct ecoff\_debug\_info* info )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & buildsym\_new\_init() & buildsym.c & \cxreffunc{buildsym_new_init}{buildsym.c}\\
\ & free\_header\_files() & dbxread.c & \cxreffunc{free_header_files}{dbxread.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_header\_files() & dbxread.c & \cxreffunc{init_header_files}{dbxread.c}\\
\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & stabsread\_new\_init() & stabsread.c & \cxreffunc{stabsread_new_init}{stabsread.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & elfmdebug\_build\_psymtabs() & mdebugread.c & \cxreffunc{elfmdebug_build_psymtabs}{mdebugread.c}\\
\ & mipscoff\_symfile\_read() & mipsread.c & \cxreffunc{mipscoff_symfile_read}{mipsread.c}\\
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & max\_gdbinfo & mdebugread.c & \cxrefvar{max_gdbinfo}{mdebugread.c}\\
\ & max\_glevel & mdebugread.c & \cxrefvar{max_glevel}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_block()}
\label{func_add_block_mdebugread.c}

{\stt static void add\_block ( struct block* b, struct symtab* s )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
Called by:\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_line()}
\label{func_add_line_mdebugread.c}

{\stt static int add\_line ( struct linetable* lt, int lineno, CORE\_ADDR adr, int last )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Called by:\ & parse\_lines() & mdebugread.c & \cxreffunc{parse_lines}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_pending()}
\label{func_add_pending_mdebugread.c}

{\stt static void add\_pending ( FDR* fh, char* sh, struct type* t )}

\smallskip
\begin{cxreftabiii}
Calls:\ & is\_pending\_symbol() & mdebugread.c & \cxreffunc{is_pending_symbol}{mdebugread.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & cross\_ref() & mdebugread.c & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
Refs Var:\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & pending\_list & mdebugread.c & \cxrefvar{pending_list}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_symbol()}
\label{func_add_symbol_mdebugread.c}

{\stt static void add\_symbol ( struct symbol* s, struct block* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & dict\_add\_symbol() & dictionary.c & \cxreffunc{dict_add_symbol}{dictionary.c}\\
Called by:\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function bad\_rfd\_entry\_complaint()}
\label{func_bad_rfd_entry_complaint_mdebugread.c}

{\stt static void bad\_rfd\_entry\_complaint ( const char* arg1, int arg2, int arg3 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & cross\_ref() & mdebugread.c & \cxreffunc{cross_ref}{mdebugread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function bad\_tag\_guess\_complaint()}
\label{func_bad_tag_guess_complaint_mdebugread.c}

{\stt static void bad\_tag\_guess\_complaint ( const char* arg1 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function basic\_type\_complaint()}
\label{func_basic_type_complaint_mdebugread.c}

{\stt static void basic\_type\_complaint ( int arg1, const char* arg2 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_blocks()}
\label{func_compare_blocks_mdebugread.c}

{\stt static int compare\_blocks ( const void* arg1, const void* arg2 )}

\smallskip
\begin{cxreftabiii}
Used in:\ & sort\_blocks() & mdebugread.c & \cxreffunc{sort_blocks}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cross\_ref()}
\label{func_cross_ref_mdebugread.c}

{\stt static int cross\_ref ( int fd, union aux\_ext* ax, struct type** tpp, enum type\_code type\_code, const char** pname, int bigend, const char* sym\_name )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & add\_pending() & mdebugread.c & \cxreffunc{add_pending}{mdebugread.c}\\
\ & bad\_rfd\_entry\_complaint() & mdebugread.c & \cxreffunc{bad_rfd_entry_complaint}{mdebugread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & cross\_ref() & mdebugread.c & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & get\_rfd() & mdebugread.c & \cxreffunc{get_rfd}{mdebugread.c}\\
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\ & is\_pending\_symbol() & mdebugread.c & \cxreffunc{is_pending_symbol}{mdebugread.c}\\
\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
\ & \cxreftabiiispan{ bfd\_getb32(), bfd\_getl32()} &\\
Called by:\ & cross\_ref() & mdebugread.c & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fdr\_name()}
\label{func_fdr_name_mdebugread.c}

{\stt static const char* fdr\_name ( FDR* f )}

\smallskip
\begin{cxreftabiii}
Called by:\ & parse\_external() & mdebugread.c & \cxreffunc{parse_external}{mdebugread.c}\\
\ & parse\_lines() & mdebugread.c & \cxreffunc{parse_lines}{mdebugread.c}\\
\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
Refs Var:\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function function\_outside\_compilation\_unit\_complaint()}
\label{func_function_outside_compilation_unit_complaint_mdebugread.c}

{\stt static void function\_outside\_compilation\_unit\_complaint ( const char* arg1 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_rfd()}
\label{func_get_rfd_mdebugread.c}

{\stt static FDR* get\_rfd ( int cf, int rf )}

\smallskip
\begin{cxreftabiii}
Called by:\ & cross\_ref() & mdebugread.c & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
\ & upgrade\_type() & mdebugread.c & \cxreffunc{upgrade_type}{mdebugread.c}\\
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function handle\_psymbol\_enumerators()}
\label{func_handle_psymbol_enumerators_mdebugread.c}

{\stt static void handle\_psymbol\_enumerators ( struct objfile* objfile, FDR* fh, int stype, CORE\_ADDR svalue )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & cur\_fdr & mdebugread.c & \cxrefvar{cur_fdr}{mdebugread.c}\\
\ & cur\_sdx & mdebugread.c & \cxrefvar{cur_sdx}{mdebugread.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\ & psymtab\_language & mdebugread.c & \cxrefvar{psymtab_language}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function has\_opaque\_xref()}
\label{func_has_opaque_xref_mdebugread.c}

{\stt static int has\_opaque\_xref ( FDR* fh, SYMR* sh )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & \cxreftabiiispan{ bfd\_getb32(), bfd\_getl32()} &\\
Called by:\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
Refs Var:\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function index\_complaint()}
\label{func_index_complaint_mdebugread.c}

{\stt static void index\_complaint ( const char* arg1 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function is\_pending\_symbol()}
\label{func_is_pending_symbol_mdebugread.c}

{\stt static struct mdebug\_pending* is\_pending\_symbol ( FDR* fh, char* sh )}

\smallskip
\begin{cxreftabiii}
Called by:\ & add\_pending() & mdebugread.c & \cxreffunc{add_pending}{mdebugread.c}\\
\ & cross\_ref() & mdebugread.c & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
Refs Var:\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & pending\_list & mdebugread.c & \cxrefvar{pending_list}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function mdebug\_next\_symbol\_text()}
\label{func_mdebug_next_symbol_text_mdebugread.c}

{\stt static const char* mdebug\_next\_symbol\_text ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Used in:\ & mdebug\_psymtab\_to\_symtab() & mdebugread.c & \cxreffunc{mdebug_psymtab_to_symtab}{mdebugread.c}\\
\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & cur\_fdr & mdebugread.c & \cxrefvar{cur_fdr}{mdebugread.c}\\
\ & cur\_sdx & mdebugread.c & \cxrefvar{cur_sdx}{mdebugread.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function mdebug\_psymtab\_to\_symtab()}
\label{func_mdebug_psymtab_to_symtab_mdebugread.c}

{\stt static void mdebug\_psymtab\_to\_symtab ( struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Calls:\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\ & scan\_file\_globals() & stabsread.c & \cxreffunc{scan_file_globals}{stabsread.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & new\_psymtab() & mdebugread.c & \cxreffunc{new_psymtab}{mdebugread.c}\\
\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
Refs Func:\ & mdebug\_next\_symbol\_text() & mdebugread.c & \cxreffunc{mdebug_next_symbol_text}{mdebugread.c}\\
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\ & next\_symbol\_text\_func & buildsym.c & \cxrefvar{next_symbol_text_func}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function mylookup\_symbol()}
\label{func_mylookup_symbol_mdebugread.c}

{\stt static struct symbol* mylookup\_symbol ( const char* name, struct block* block, domain\_enum domain, enum address\_class addrclass )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & dict\_iterator\_first() & dictionary.c & \cxreffunc{dict_iterator_first}{dictionary.c}\\
\ & dict\_iterator\_next() & dictionary.c & \cxreffunc{dict_iterator_next}{dictionary.c}\\
\ & mylookup\_symbol() & mdebugread.c & \cxreffunc{mylookup_symbol}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & mylookup\_symbol() & mdebugread.c & \cxreffunc{mylookup_symbol}{mdebugread.c}\\
\ & parse\_procedure() & mdebugread.c & \cxreffunc{parse_procedure}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_block()}
\label{func_new_block_mdebugread.c}

{\stt static struct block* new\_block ( enum block\_type type )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & dict\_create\_hashed\_expandable() & dictionary.c & \cxreffunc{dict_create_hashed_expandable}{dictionary.c}\\
\ & dict\_create\_linear\_expandable() & dictionary.c & \cxreffunc{dict_create_linear_expandable}{dictionary.c}\\
\ & xzalloc() & utils.c & \cxreffunc{xzalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & new\_symtab() & mdebugread.c & \cxreffunc{new_symtab}{mdebugread.c}\\
\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_bvect()}
\label{func_new_bvect_mdebugread.c}

{\stt static struct blockvector* new\_bvect ( int nblocks )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & xzalloc() & utils.c & \cxreffunc{xzalloc}{utils.c}\\
Called by:\ & new\_symtab() & mdebugread.c & \cxreffunc{new_symtab}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_linetable()}
\label{func_new_linetable_mdebugread.c}

{\stt static struct linetable* new\_linetable ( int size )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & new\_symtab() & mdebugread.c & \cxreffunc{new_symtab}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_psymtab()}
\label{func_new_psymtab_mdebugread.c}

{\stt static struct partial\_symtab* new\_psymtab ( const char* name, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & allocate\_psymtab() & symfile.c & \cxreffunc{allocate_psymtab}{symfile.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
Refs Func:\ & mdebug\_psymtab\_to\_symtab() & mdebugread.c & \cxreffunc{mdebug_psymtab_to_symtab}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\ & pending\_list & mdebugread.c & \cxrefvar{pending_list}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_symbol()}
\label{func_new_symbol_mdebugread.c}

{\stt static struct symbol* new\_symbol ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & symbol\_set\_names() & symtab.c & \cxreffunc{symbol_set_names}{symtab.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk(), strlen()} &\\
Called by:\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
Refs Var:\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & psymtab\_language & mdebugread.c & \cxrefvar{psymtab_language}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_symtab()}
\label{func_new_symtab_mdebugread.c}

{\stt static struct symtab* new\_symtab ( const char* name, int maxlines, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & allocate\_symtab() & symfile.c & \cxreffunc{allocate_symtab}{symfile.c}\\
\ & new\_block() & mdebugread.c & \cxreffunc{new_block}{mdebugread.c}\\
\ & new\_bvect() & mdebugread.c & \cxreffunc{new_bvect}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & new\_linetable() & mdebugread.c & \cxreffunc{new_linetable}{mdebugread.c}\\
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
Called by:\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_type()}
\label{func_new_type_mdebugread.c}

{\stt static struct type* new\_type ( char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
Called by:\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
Refs Var:\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function parse\_external()}
\label{func_parse_external_mdebugread.c}

{\stt static void parse\_external ( EXTR* es, int bigend, struct section\_offsets* section\_offsets, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & fdr\_name() & mdebugread.c & \cxreffunc{fdr_name}{mdebugread.c}\\
\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
Refs Var:\ & cur\_fd & mdebugread.c & \cxrefvar{cur_fd}{mdebugread.c}\\
\ & cur\_fdr & mdebugread.c & \cxrefvar{cur_fdr}{mdebugread.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\ & n\_undef\_labels & mdebugread.c & \cxrefvar{n_undef_labels}{mdebugread.c}\\
\ & n\_undef\_procs & mdebugread.c & \cxrefvar{n_undef_procs}{mdebugread.c}\\
\ & n\_undef\_symbols & mdebugread.c & \cxrefvar{n_undef_symbols}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & n\_undef\_vars & mdebugread.c & \cxrefvar{n_undef_vars}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function parse\_lines()}
\label{func_parse_lines_mdebugread.c}

{\stt static void parse\_lines ( FDR* fh, PDR* pr, struct linetable* lt, int maxlines, struct partial\_symtab* pst, CORE\_ADDR lowest\_pdr\_addr )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & add\_line() & mdebugread.c & \cxreffunc{add_line}{mdebugread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & fdr\_name() & mdebugread.c & \cxreffunc{fdr_name}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
Refs Var:\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function parse\_partial\_symbols()}
\label{func_parse_partial_symbols_mdebugread.c}

{\stt static void parse\_partial\_symbols ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & deduce\_language\_from\_filename() & symfile.c & \cxreffunc{deduce_language_from_filename}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & end\_psymtab() & dbxread.c & \cxreffunc{end_psymtab}{dbxread.c}\\
\ & executable\_objfile() & objfiles.c & \cxreffunc{executable_objfile}{objfiles.c}\\
\ & fdr\_name() & mdebugread.c & \cxreffunc{fdr_name}{mdebugread.c}\\
\ & function\_outside\_compilation\_unit\_complaint() & mdebugread.c & \cxreffunc{function_outside_compilation_unit_complaint}{mdebugread.c}\\
\ & get\_section\_index() & symfile.c & \cxreffunc{get_section_index}{symfile.c}\\
\ & handle\_psymbol\_enumerators() & mdebugread.c & \cxreffunc{handle_psymbol_enumerators}{mdebugread.c}\\
\ & has\_opaque\_xref() & mdebugread.c & \cxreffunc{has_opaque_xref}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & hex\_string() & utils.c & \cxreffunc{hex_string}{utils.c}\\
\ & index\_complaint() & mdebugread.c & \cxreffunc{index_complaint}{mdebugread.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & new\_psymtab() & mdebugread.c & \cxreffunc{new_psymtab}{mdebugread.c}\\
\ & prim\_record\_minimal\_symbol\_and\_info() & minsyms.c & \cxreffunc{prim_record_minimal_symbol_and_info}{minsyms.c}\\
\ & psymtab\_get\_first() & objfiles.c & \cxreffunc{psymtab_get_first}{objfiles.c}\\
\ & psymtab\_get\_next() & objfiles.c & \cxreffunc{psymtab_get_next}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & record\_minimal\_symbol() & mdebugread.c & \cxreffunc{record_minimal_symbol}{mdebugread.c}\\
\ & start\_psymtab\_common() & symfile.c & \cxreffunc{start_psymtab_common}{symfile.c}\\
\ & unknown\_ext\_complaint() & mdebugread.c & \cxreffunc{unknown_ext_complaint}{mdebugread.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
\ & xzalloc() & utils.c & \cxreffunc{xzalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_\_inline\_memset\_chk(), \_\_inline\_strcpy\_chk(), \_obstack\_newchunk(), bfd\_get\_section\_by\_name(), bfd\_getb32(), bfd\_getl32(), strchr(), strcmp(), strlen(), strrchr()} &\\
Called by:\ & mdebug\_build\_psymtabs() & mdebugread.c & \cxreffunc{mdebug_build_psymtabs}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & mdebug\_next\_symbol\_text() & mdebugread.c & \cxreffunc{mdebug_next_symbol_text}{mdebugread.c}\\
\ & mdebug\_psymtab\_to\_symtab() & mdebugread.c & \cxreffunc{mdebug_psymtab_to_symtab}{mdebugread.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\ & cur\_fdr & mdebugread.c & \cxrefvar{cur_fdr}{mdebugread.c}\\
\ & cur\_sdx & mdebugread.c & \cxrefvar{cur_sdx}{mdebugread.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & last\_source\_file & buildsym.c & \cxrefvar{last_source_file}{buildsym.c}\\
\ & max\_gdbinfo & mdebugread.c & \cxrefvar{max_gdbinfo}{mdebugread.c}\\
\ & max\_glevel & mdebugread.c & \cxrefvar{max_glevel}{mdebugread.c}\\
\ & next\_symbol\_text\_func & buildsym.c & \cxrefvar{next_symbol_text_func}{buildsym.c}\\
\ & pending\_list & mdebugread.c & \cxrefvar{pending_list}{mdebugread.c}\\
\ & processing\_gcc\_compilation & buildsym.c & \cxrefvar{processing_gcc_compilation}{buildsym.c}\\
\ & psymtab\_language & mdebugread.c & \cxrefvar{psymtab_language}{mdebugread.c}\\
\ & stabs\_symbol & mdebugread.c & \cxrefvar{stabs_symbol}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\ & symnum & buildsym.c & \cxrefvar{symnum}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function parse\_procedure()}
\label{func_parse_procedure_mdebugread.c}

{\stt static void parse\_procedure ( PDR* pr, struct symtab* search\_symtab, struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & mylookup\_symbol() & mdebugread.c & \cxreffunc{mylookup_symbol}{mdebugread.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\ & cur\_fdr & mdebugread.c & \cxrefvar{cur_fdr}{mdebugread.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\ & found\_ecoff\_debugging\_info & mdebugread.c & \cxrefvar{found_ecoff_debugging_info}{mdebugread.c}\\
\ & nodebug\_func\_symbol\_type & mdebugread.c & \cxrefvar{nodebug_func_symbol_type}{mdebugread.c}\\
\ & processing\_gcc\_compilation & buildsym.c & \cxrefvar{processing_gcc_compilation}{buildsym.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & top\_stack & mdebugread.c & \cxrefvar{top_stack}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function parse\_symbol()}
\label{func_parse_symbol_mdebugread.c}

{\stt static int parse\_symbol ( SYMR* sh, union aux\_ext* ax, char* ext\_sh, int bigend, struct section\_offsets* section\_offsets, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Calls:\ & add\_block() & mdebugread.c & \cxreffunc{add_block}{mdebugread.c}\\
\ & add\_pending() & mdebugread.c & \cxreffunc{add_pending}{mdebugread.c}\\
\ & add\_symbol() & mdebugread.c & \cxreffunc{add_symbol}{mdebugread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & dict\_iterator\_first() & dictionary.c & \cxreffunc{dict_iterator_first}{dictionary.c}\\
\ & dict\_iterator\_next() & dictionary.c & \cxreffunc{dict_iterator_next}{dictionary.c}\\
\ & executable\_objfile() & objfiles.c & \cxreffunc{executable_objfile}{objfiles.c}\\
\ & gdbarch\_ecoff\_reg\_to\_regnum() & gdbarch.c & \cxreffunc{gdbarch_ecoff_reg_to_regnum}{gdbarch.c}\\
\ & gdbarch\_int\_bit() & gdbarch.c & \cxreffunc{gdbarch_int_bit}{gdbarch.c}\\
\ & has\_opaque\_xref() & mdebugread.c & \cxreffunc{has_opaque_xref}{mdebugread.c}\\
\ & hashname() & buildsym.c & \cxreffunc{hashname}{buildsym.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & is\_cplus\_marker() & demangle.c & \cxreffunc{is_cplus_marker}{demangle.c}\\
\ & is\_pending\_symbol() & mdebugread.c & \cxreffunc{is_pending_symbol}{mdebugread.c}\\
\ & lookup\_function\_type() & gdbtypes.c & \cxreffunc{lookup_function_type}{gdbtypes.c}\\
\ & make\_pointer\_type() & gdbtypes.c & \cxreffunc{make_pointer_type}{gdbtypes.c}\\
\ & new\_block() & mdebugread.c & \cxreffunc{new_block}{mdebugread.c}\\
\ & new\_symbol() & mdebugread.c & \cxreffunc{new_symbol}{mdebugread.c}\\
\ & new\_type() & mdebugread.c & \cxreffunc{new_type}{mdebugread.c}\\
\ & obconcat() & symfile.c & \cxreffunc{obconcat}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
\ & pop\_parse\_stack() & mdebugread.c & \cxreffunc{pop_parse_stack}{mdebugread.c}\\
\ & push\_parse\_stack() & mdebugread.c & \cxreffunc{push_parse_stack}{mdebugread.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk(), strcmp(), strlen()} &\\
Called by:\ & parse\_external() & mdebugread.c & \cxreffunc{parse_external}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\ & cur\_fd & mdebugread.c & \cxrefvar{cur_fd}{mdebugread.c}\\
\ & cur\_fdr & mdebugread.c & \cxrefvar{cur_fdr}{mdebugread.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\ & found\_ecoff\_debugging\_info & mdebugread.c & \cxrefvar{found_ecoff_debugging_info}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & global\_sym\_chain & stabsread.c & \cxrefvar{global_sym_chain}{stabsread.c}\\
\ & max\_gdbinfo & mdebugread.c & \cxrefvar{max_gdbinfo}{mdebugread.c}\\
\ & mdebug\_type\_int\_32 & mdebugread.c & \cxrefvar{mdebug_type_int_32}{mdebugread.c}\\
\ & mdebug\_type\_void & mdebugread.c & \cxrefvar{mdebug_type_void}{mdebugread.c}\\
\ & nodebug\_var\_symbol\_type & mdebugread.c & \cxrefvar{nodebug_var_symbol_type}{mdebugread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\ & top\_stack & mdebugread.c & \cxrefvar{top_stack}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function parse\_type()}
\label{func_parse_type_mdebugread.c}

{\stt static struct type* parse\_type ( int fd, union aux\_ext* ax, unsigned int aux\_index, int* bs, int bigend, const char* sym\_name )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & bad\_tag\_guess\_complaint() & mdebugread.c & \cxreffunc{bad_tag_guess_complaint}{mdebugread.c}\\
\ & basic\_type\_complaint() & mdebugread.c & \cxreffunc{basic_type_complaint}{mdebugread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & cross\_ref() & mdebugread.c & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & get\_rfd() & mdebugread.c & \cxreffunc{get_rfd}{mdebugread.c}\\
\ & index\_complaint() & mdebugread.c & \cxreffunc{index_complaint}{mdebugread.c}\\
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
\ & unexpected\_type\_code\_complaint() & mdebugread.c & \cxreffunc{unexpected_type_code_complaint}{mdebugread.c}\\
\ & upgrade\_type() & mdebugread.c & \cxreffunc{upgrade_type}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk(), bfd\_getb32(), bfd\_getl32(), strcmp(), strlen()} &\\
Called by:\ & cross\_ref() & mdebugread.c & \cxreffunc{cross_ref}{mdebugread.c}\\
\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
\ & upgrade\_type() & mdebugread.c & \cxreffunc{upgrade_type}{mdebugread.c}\\
Refs Var:\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_type\_adr\_32 & mdebugread.c & \cxrefvar{mdebug_type_adr_32}{mdebugread.c}\\
\ & mdebug\_type\_adr\_64 & mdebugread.c & \cxrefvar{mdebug_type_adr_64}{mdebugread.c}\\
\ & mdebug\_type\_char & mdebugread.c & \cxrefvar{mdebug_type_char}{mdebugread.c}\\
\ & mdebug\_type\_complex & mdebugread.c & \cxrefvar{mdebug_type_complex}{mdebugread.c}\\
\ & mdebug\_type\_double & mdebugread.c & \cxrefvar{mdebug_type_double}{mdebugread.c}\\
\ & mdebug\_type\_double\_complex & mdebugread.c & \cxrefvar{mdebug_type_double_complex}{mdebugread.c}\\
\ & mdebug\_type\_fixed\_dec & mdebugread.c & \cxrefvar{mdebug_type_fixed_dec}{mdebugread.c}\\
\ & mdebug\_type\_float & mdebugread.c & \cxrefvar{mdebug_type_float}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_type\_float\_dec & mdebugread.c & \cxrefvar{mdebug_type_float_dec}{mdebugread.c}\\
\ & mdebug\_type\_int\_32 & mdebugread.c & \cxrefvar{mdebug_type_int_32}{mdebugread.c}\\
\ & mdebug\_type\_int\_64 & mdebugread.c & \cxrefvar{mdebug_type_int_64}{mdebugread.c}\\
\ & mdebug\_type\_long\_32 & mdebugread.c & \cxrefvar{mdebug_type_long_32}{mdebugread.c}\\
\ & mdebug\_type\_long\_64 & mdebugread.c & \cxrefvar{mdebug_type_long_64}{mdebugread.c}\\
\ & mdebug\_type\_long\_long\_64 & mdebugread.c & \cxrefvar{mdebug_type_long_long_64}{mdebugread.c}\\
\ & mdebug\_type\_short & mdebugread.c & \cxrefvar{mdebug_type_short}{mdebugread.c}\\
\ & mdebug\_type\_string & mdebugread.c & \cxrefvar{mdebug_type_string}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_type\_unsigned\_char & mdebugread.c & \cxrefvar{mdebug_type_unsigned_char}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_int\_32 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_int_32}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_int\_64 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_int_64}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_long\_32 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_long_32}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_long\_64 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_long_64}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_long\_long\_64 & mdebugread.c & \cxrefvar{mdebug_type_unsigned_long_long_64}{mdebugread.c}\\
\ & mdebug\_type\_unsigned\_short & mdebugread.c & \cxrefvar{mdebug_type_unsigned_short}{mdebugread.c}\\
\ & mdebug\_type\_void & mdebugread.c & \cxrefvar{mdebug_type_void}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function pop\_parse\_stack()}
\label{func_pop_parse_stack_mdebugread.c}

{\stt static void pop\_parse\_stack ( void )}

\smallskip
\begin{cxreftabiii}
Called by:\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
Refs Var:\ & top\_stack & mdebugread.c & \cxrefvar{top_stack}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function psymtab\_to\_symtab\_1()}
\label{func_psymtab_to_symtab_1_mdebugread.c}

{\stt static void psymtab\_to\_symtab\_1 ( struct partial\_symtab* pst, char* filename )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & add\_symbol\_to\_list() & buildsym.c & \cxreffunc{add_symbol_to_list}{buildsym.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & end\_stabs() & stabsread.c & \cxreffunc{end_stabs}{stabsread.c}\\
\ & end\_symtab() & buildsym.c & \cxreffunc{end_symtab}{buildsym.c}\\
\ & executable\_objfile() & objfiles.c & \cxreffunc{executable_objfile}{objfiles.c}\\
\ & fputs\_filtered() & utils.c & \cxreffunc{fputs_filtered}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & new\_symbol() & mdebugread.c & \cxreffunc{new_symbol}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & new\_symtab() & mdebugread.c & \cxreffunc{new_symtab}{mdebugread.c}\\
\ & parse\_external() & mdebugread.c & \cxreffunc{parse_external}{mdebugread.c}\\
\ & parse\_lines() & mdebugread.c & \cxreffunc{parse_lines}{mdebugread.c}\\
\ & parse\_procedure() & mdebugread.c & \cxreffunc{parse_procedure}{mdebugread.c}\\
\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & pop\_parse\_stack() & mdebugread.c & \cxreffunc{pop_parse_stack}{mdebugread.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & process\_one\_symbol() & dbxread.c & \cxreffunc{process_one_symbol}{dbxread.c}\\
\cxreftabbreak{cxreftabiii}
\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\ & push\_parse\_stack() & mdebugread.c & \cxreffunc{push_parse_stack}{mdebugread.c}\\
\ & record\_line() & buildsym.c & \cxreffunc{record_line}{buildsym.c}\\
\ & shrink\_linetable() & mdebugread.c & \cxreffunc{shrink_linetable}{mdebugread.c}\\
\ & sort\_blocks() & mdebugread.c & \cxreffunc{sort_blocks}{mdebugread.c}\\
\ & wrap\_here() & utils.c & \cxreffunc{wrap_here}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk(), strcmp()} &\\
Called by:\ & mdebug\_psymtab\_to\_symtab() & mdebugread.c & \cxreffunc{mdebug_psymtab_to_symtab}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\ & cur\_fd & mdebugread.c & \cxrefvar{cur_fd}{mdebugread.c}\\
\ & cur\_fdr & mdebugread.c & \cxrefvar{cur_fdr}{mdebugread.c}\\
\ & cur\_sdx & mdebugread.c & \cxrefvar{cur_sdx}{mdebugread.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & current\_subfile & buildsym.c & \cxrefvar{current_subfile}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\ & found\_ecoff\_debugging\_info & mdebugread.c & \cxrefvar{found_ecoff_debugging_info}{mdebugread.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\ & last\_source\_file & buildsym.c & \cxrefvar{last_source_file}{buildsym.c}\\
\ & local\_symbols & buildsym.c & \cxrefvar{local_symbols}{buildsym.c}\\
\ & mdebug\_type\_void & mdebugread.c & \cxrefvar{mdebug_type_void}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & n\_undef\_labels & mdebugread.c & \cxrefvar{n_undef_labels}{mdebugread.c}\\
\ & n\_undef\_procs & mdebugread.c & \cxrefvar{n_undef_procs}{mdebugread.c}\\
\ & n\_undef\_symbols & mdebugread.c & \cxrefvar{n_undef_symbols}{mdebugread.c}\\
\ & n\_undef\_vars & mdebugread.c & \cxrefvar{n_undef_vars}{mdebugread.c}\\
\ & pending\_list & mdebugread.c & \cxrefvar{pending_list}{mdebugread.c}\\
\ & previous\_stab\_code & stabsread.c & \cxrefvar{previous_stab_code}{stabsread.c}\\
\ & processing\_gcc\_compilation & buildsym.c & \cxrefvar{processing_gcc_compilation}{buildsym.c}\\
\ & psymtab\_language & mdebugread.c & \cxrefvar{psymtab_language}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & stabs\_symbol & mdebugread.c & \cxrefvar{stabs_symbol}{mdebugread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\ & top\_stack & mdebugread.c & \cxrefvar{top_stack}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function push\_parse\_stack()}
\label{func_push_parse_stack_mdebugread.c}

{\stt static void push\_parse\_stack ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xzalloc() & utils.c & \cxreffunc{xzalloc}{utils.c}\\
Called by:\ & parse\_symbol() & mdebugread.c & \cxreffunc{parse_symbol}{mdebugread.c}\\
\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
Refs Var:\ & top\_stack & mdebugread.c & \cxrefvar{top_stack}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function record\_minimal\_symbol()}
\label{func_record_minimal_symbol_mdebugread.c}

{\stt static void record\_minimal\_symbol ( const char* name, const CORE\_ADDR address, enum minimal\_symbol\_type ms\_type, int storage\_class, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Calls:\ & executable\_objfile() & objfiles.c & \cxreffunc{executable_objfile}{objfiles.c}\\
\ & get\_section\_index() & symfile.c & \cxreffunc{get_section_index}{symfile.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & prim\_record\_minimal\_symbol\_and\_info() & minsyms.c & \cxreffunc{prim_record_minimal_symbol_and_info}{minsyms.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ bfd\_get\_section\_by\_name()} &\\
Called by:\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
Refs Var:\ & cur\_bfd & mdebugread.c & \cxrefvar{cur_bfd}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function shrink\_linetable()}
\label{func_shrink_linetable_mdebugread.c}

{\stt static struct linetable* shrink\_linetable ( struct linetable* lt )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
Called by:\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function sort\_blocks()}
\label{func_sort_blocks_mdebugread.c}

{\stt static void sort\_blocks ( struct symtab* s )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & \cxreftabiiispan{ qsort()} &\\
Called by:\ & psymtab\_to\_symtab\_1() & mdebugread.c & \cxreffunc{psymtab_to_symtab_1}{mdebugread.c}\\
Refs Func:\ & compare\_blocks() & mdebugread.c & \cxreffunc{compare_blocks}{mdebugread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function unexpected\_type\_code\_complaint()}
\label{func_unexpected_type_code_complaint_mdebugread.c}

{\stt static void unexpected\_type\_code\_complaint ( const char* arg1 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function unknown\_ext\_complaint()}
\label{func_unknown_ext_complaint_mdebugread.c}

{\stt static void unknown\_ext\_complaint ( const char* arg1 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & parse\_partial\_symbols() & mdebugread.c & \cxreffunc{parse_partial_symbols}{mdebugread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function upgrade\_type()}
\label{func_upgrade_type_mdebugread.c}

{\stt static int upgrade\_type ( int fd, struct type** tpp, int tq, union aux\_ext* ax, int bigend, const char* sym\_name )}

\smallskip
\begin{cxreftabiii}
Prototype:& mdebugread.c & \ & \cxreffile{mdebugread.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_rfd() & mdebugread.c & \cxreffunc{get_rfd}{mdebugread.c}\\
\ & lookup\_function\_type() & gdbtypes.c & \cxreffunc{lookup_function_type}{gdbtypes.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
\ & \cxreftabiiispan{ bfd\_getb32(), bfd\_getl32()} &\\
Called by:\ & parse\_type() & mdebugread.c & \cxreffunc{parse_type}{mdebugread.c}\\
Refs Var:\ & debug\_info & mdebugread.c & \cxrefvar{debug_info}{mdebugread.c}\\
\ & debug\_swap & mdebugread.c & \cxrefvar{debug_swap}{mdebugread.c}\\
\cxreftabbreak{cxreftabiii}
\ & mdebug\_type\_int\_32 & mdebugread.c & \cxrefvar{mdebug_type_int_32}{mdebugread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}

