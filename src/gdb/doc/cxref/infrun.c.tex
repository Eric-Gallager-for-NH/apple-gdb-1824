% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF infrun.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File infrun.c}{File infrun.c}
\section{File infrun.c}
\label{file_infrun.c}

\smallskip
\begin{cxreftabiii}
Refs Var:\ & follow\_fork\_mode\_child & infrun.c & \cxrefvar{follow_fork_mode_child}{infrun.c}\\
\ & follow\_fork\_mode\_parent & infrun.c & \cxrefvar{follow_fork_mode_parent}{infrun.c}\\
\ & schedlock\_off & infrun.c & \cxrefvar{schedlock_off}{infrun.c}\\
\ & schedlock\_on & infrun.c & \cxrefvar{schedlock_on}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & schedlock\_step & infrun.c & \cxrefvar{schedlock_step}{infrun.c}\\
\end{cxreftabiii}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <ctype.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{0.8in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.6in}{\stt \#include <regex.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.4in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{0.6in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.6in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inferior.h"} &\cxreffile{inferior.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.4in}{\stt \#include "gdb-events.h"} &\cxreffile{gdb-events.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "exceptions.h"} &\cxreffile{exceptions.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\hspace*{0.2in}{\stt \#include <setjmp.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_wait.h"} &\cxreffile{gdb_wait.h}\\
\hspace*{0.2in}{\stt \#include <sys/wait.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcore.h"} &\cxreffile{gdbcore.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cli/cli-script.h"} &\cxreffile{cli/cli-script.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "target.h"} &\cxreffile{target.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbthread.h"} &\cxreffile{gdbthread.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "annotate.h"} &\cxreffile{annotate.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.2in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "top.h"} &\cxreffile{top.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <signal.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inf-loop.h"} &\cxreffile{inf-loop.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "event-top.h"} &\cxreffile{event-top.h}\\
\hspace*{0.2in}{\stt \#include <signal.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "regcache.h"} &\cxreffile{regcache.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "value.h"} &\cxreffile{value.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "observer.h"} &\cxreffile{observer.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "solib.h"} &\cxreffile{solib.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <stdint.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "mi/mi-common.h"} &\cxreffile{mi/mi-common.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "macosx/macosx-nat-dyld.h"} &\cxreffile{macosx/macosx-nat-dyld.h}\\
\hspace*{0.2in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "macosx/macosx-nat-mutils.h"} &\cxreffile{macosx/macosx-nat-mutils.h}\\
\hspace*{0.4in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.4in}{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.4in}{\stt \#include "inferior.h"} &\cxreffile{inferior.h}\\
\hspace*{0.4in}{\stt \#include "macosx/macosx-nat-utils.h"} &\cxreffile{macosx/macosx-nat-utils.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.4in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.2in}{\stt \#include "macosx/macosx-nat-threads.h"} &\cxreffile{macosx/macosx-nat-threads.h}\\
\hspace*{0.4in}{\stt \#include <pthread.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <mach/machine.h>} &\\
\hspace*{0.2in}{\stt \#include <mach-o/loader.h>} &\\
\hspace*{0.2in}{\stt \#include "macosx/macosx-nat-dyld-info.h"} &\cxreffile{macosx/macosx-nat-dyld-info.h}\\
\hspace*{0.4in}{\stt \#include <mach/machine.h>} &\\
\hspace*{0.4in}{\stt \#include <mach-o/loader.h>} &\\
\hspace*{0.2in}{\stt \#include "macosx/macosx-nat-dyld-path.h"} &\cxreffile{macosx/macosx-nat-dyld-path.h}\\
\hspace*{0.4in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <uuid/uuid.h>} &\\
\hspace*{0.2in}{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/obstack.h"} &\cxreffile{../include/obstack.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "checkpoint.h"} &\cxreffile{checkpoint.h}\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define TARGET\_DISABLE\_HW\_WATCHPOINTS( pid )}

\medskip
{\stt \#define TARGET\_ENABLE\_HW\_WATCHPOINTS( pid )}

\medskip
{\stt \#define MAY\_FOLLOW\_EXEC 0}

\medskip
{\stt \#define SKIP\_PERMANENT\_BREAKPOINT default\_skip\_permanent\_breakpoint}

\medskip
{\stt \#define HAVE\_STEPPABLE\_WATCHPOINT 0}

\medskip
{\stt \#define CANNOT\_STEP\_HW\_WATCHPOINTS 0}

\medskip
{\stt \#define SET\_SIGS( nsigs, sigs, flags )}

\medskip
{\stt \#define UNSET\_SIGS( nsigs, sigs, flags )}

\medskip
{\stt \#define RESUME\_ALL}


\subsection{Type definitions}


\subsubsection{Type enum infwait\_states}
\label{type_enum_infwait_states_infrun.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum infwait\_states} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt infwait\_normal\_state;} &\\
\hspace*{0.2in}{\stt infwait\_thread\_hop\_state;} &\\
\hspace*{0.2in}{\stt infwait\_nonstep\_watch\_state;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum inferior\_stop\_reason}
\label{type_enum_inferior_stop_reason_infrun.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum inferior\_stop\_reason} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt STOP\_UNKNOWN;} &\\
\hspace*{0.2in}{\stt END\_STEPPING\_RANGE;} &\\
\hspace*{0.2in}{\stt BREAKPOINT\_HIT;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt SIGNAL\_EXITED;} &\\
\hspace*{0.2in}{\stt EXITED;} &\\
\hspace*{0.2in}{\stt SIGNAL\_RECEIVED;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct execution\_control\_state}
\label{type_struct_execution_control_state_infrun.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct execution\_control\_state} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct target\_waitstatus ws;} &\\
\hspace*{0.2in}{\stt struct target\_waitstatus* wp;} &\\
\hspace*{0.2in}{\stt int another\_trap;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int random\_signal;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR stop\_func\_start;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR stop\_func\_end;} &\\
\hspace*{0.2in}{\stt const char* stop\_func\_name;} &\\
\hspace*{0.2in}{\stt struct symtab\_and\_line sal;} &\\
\hspace*{0.2in}{\stt int current\_line;} &\\
\hspace*{0.2in}{\stt struct symtab* current\_symtab;} &\\
\hspace*{0.2in}{\stt int handling\_longjmp;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt ptid\_t ptid;} &\\
\hspace*{0.2in}{\stt ptid\_t saved\_inferior\_ptid;} &\\
\hspace*{0.2in}{\stt int step\_after\_step\_resume\_breakpoint;} &\\
\hspace*{0.2in}{\stt int stepping\_through\_solib\_after\_catch;} &\\
\hspace*{0.2in}{\stt bpstat stepping\_through\_solib\_catchpoints;} &\\
\hspace*{0.2in}{\stt int enable\_hw\_watchpoints\_after\_wait;} &\\
\hspace*{0.2in}{\stt int new\_thread\_event;} &\\
\hspace*{0.2in}{\stt struct target\_waitstatus tmpstatus;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt enum infwait\_states infwait\_state;} &\\
\hspace*{0.2in}{\stt ptid\_t waiton\_ptid;} &\\
\hspace*{0.2in}{\stt int wait\_some\_more;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct inferior\_status}
\label{type_struct_inferior_status_infrun.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct inferior\_status} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt ptid\_t stop\_ptid;} &\\
\hspace*{0.2in}{\stt enum target\_signal stop\_signal;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR stop\_pc;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt bpstat stop\_bpstat;} &\\
\hspace*{0.2in}{\stt int stop\_step;} &\\
\hspace*{0.2in}{\stt int stop\_stack\_dummy;} &\\
\hspace*{0.2in}{\stt int stopped\_by\_random\_signal;} &\\
\hspace*{0.2in}{\stt int trap\_expected;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR step\_range\_start;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR step\_range\_end;} &\\
\hspace*{0.2in}{\stt struct address\_range\_list* stepping\_ranges;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct frame\_id step\_frame\_id;} &\\
\hspace*{0.2in}{\stt enum step\_over\_calls\_kind step\_over\_calls;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR step\_resume\_break\_address;} &\\
\hspace*{0.2in}{\stt int stop\_after\_trap;} &\\
\hspace*{0.2in}{\stt int stop\_soon;} &\\
\hspace*{0.2in}{\stt struct regcache* stop\_registers;} &\\
\hspace*{0.2in}{\stt struct regcache* registers;} &\\
\hspace*{0.2in}{\stt struct frame\_id selected\_frame\_id;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int breakpoint\_proceeded;} &\\
\hspace*{0.2in}{\stt int restore\_stack\_info;} &\\
\hspace*{0.2in}{\stt int proceed\_to\_finish;} &\\
\hspace*{0.2in}{\stt void* tdep\_inferior\_status;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable minus\_one\_ptid}
\label{var_minus_one_ptid_infrun.c}

{\stt ptid\_t minus\_one\_ptid}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & do\_reset\_hand\_call\_ptid() & infcall.c & \cxreffunc{do_reset_hand_call_ptid}{infcall.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_wait\_for\_inferior() & infrun.c & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
\ & prepare\_to\_proceed() & infrun.c & \cxreffunc{prepare_to_proceed}{infrun.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\ & set\_schedlock\_helper() & infrun.c & \cxreffunc{set_schedlock_helper}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable null\_ptid}
\label{var_null_ptid_infrun.c}

{\stt ptid\_t null\_ptid}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & \_initialize\_inflow() & inflow.c & \cxreffunc{_initialize_inflow}{inflow.c}\\
\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & generic\_mourn\_inferior() & target/target.c & \cxreffunc{generic_mourn_inferior}{target/target.c}\\
\ & kill\_command() & inflow.c & \cxreffunc{kill_command}{inflow.c}\\
\cxreftabbreak{cxreftabiii}
\ & kill\_if\_already\_running() & infcmd.c & \cxreffunc{kill_if_already_running}{infcmd.c}\\
\ & nosupport\_runtime() & target/target.c & \cxreffunc{nosupport_runtime}{target/target.c}\\
\ & quit\_confirm() & top.c & \cxreffunc{quit_confirm}{top.c}\\
\ & quit\_target() & top.c & \cxreffunc{quit_target}{top.c}\\
\ & remote\_macosx\_open() & remote.c & \cxreffunc{remote_macosx_open}{remote.c}\\
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & run\_command\_1() & infcmd.c & \cxreffunc{run_command_1}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Variable sync\_execution}
\label{var_sync_execution_infrun.c}

{\stt int sync\_execution}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\cxreftabbreak{cxreftabiii}
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & complete\_execution() & inf-loop.c & \cxreffunc{complete_execution}{inf-loop.c}\\
\ & display\_gdb\_prompt() & event-top.c & \cxreffunc{display_gdb_prompt}{event-top.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & inferior\_event\_handler() & inf-loop.c & \cxreffunc{inferior_event_handler}{inf-loop.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_async\_terminal\_inferior() & remote.c & \cxreffunc{remote_async_terminal_inferior}{remote.c}\\
\ & remote\_async\_terminal\_ours() & remote.c & \cxreffunc{remote_async_terminal_ours}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable inferior\_ignoring\_startup\_exec\_events}
\label{var_inferior_ignoring_startup_exec_events_infrun.c}

{\stt int inferior\_ignoring\_startup\_exec\_events}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
\end{cxreftabiii}


\subsubsection{Variable inferior\_ignoring\_leading\_exec\_events}
\label{var_inferior_ignoring_leading_exec_events_infrun.c}

{\stt int inferior\_ignoring\_leading\_exec\_events}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\cxreftabbreak{cxreftabiii}
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable step\_stop\_if\_no\_debug}
\label{var_step_stop_if_no_debug_infrun.c}

{\stt int step\_stop\_if\_no\_debug}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\cxreftabbreak{cxreftabiii}
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & step\_once() & infcmd.c & \cxreffunc{step_once}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Variable stop\_soon}
\label{var_stop_soon_infrun.c}

{\stt enum stop\_kind stop\_soon}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & clear\_proceed\_status() & infrun.c & \cxreffunc{clear_proceed_status}{infrun.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & restore\_inferior\_status() & infrun.c & \cxreffunc{restore_inferior_status}{infrun.c}\\
\ & save\_inferior\_status() & infrun.c & \cxreffunc{save_inferior_status}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & start\_remote() & infrun.c & \cxreffunc{start_remote}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable proceed\_from\_hand\_call}
\label{var_proceed_from_hand_call_infrun.c}

{\stt int proceed\_from\_hand\_call}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\cxreftabbreak{cxreftabiii}
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & do\_unset\_proceed\_from\_hand\_call() & infcall.c & \cxreffunc{do_unset_proceed_from_hand_call}{infcall.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & keep\_going() & infrun.c & \cxreffunc{keep_going}{infrun.c}\\
\ & prepare\_to\_proceed() & infrun.c & \cxreffunc{prepare_to_proceed}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\ & run\_command\_1() & infcmd.c & \cxreffunc{run_command_1}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Variable proceed\_to\_finish}
\label{var_proceed_to_finish_infrun.c}

{\stt int proceed\_to\_finish}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\cxreftabbreak{cxreftabiii}
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & clear\_proceed\_status() & infrun.c & \cxreffunc{clear_proceed_status}{infrun.c}\\
\ & finish\_command() & infcmd.c & \cxreffunc{finish_command}{infcmd.c}\\
\ & finish\_inlined\_subroutine\_command() & infcmd.c & \cxreffunc{finish_inlined_subroutine_command}{infcmd.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\cxreftabbreak{cxreftabiii}
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & restore\_inferior\_status() & infrun.c & \cxreffunc{restore_inferior_status}{infrun.c}\\
\ & save\_inferior\_status() & infrun.c & \cxreffunc{save_inferior_status}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable stop\_registers}
\label{var_stop_registers_infrun.c}

{\stt struct regcache* stop\_registers}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\cxreftabbreak{cxreftabiii}
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & build\_infrun() & infrun.c & \cxreffunc{build_infrun}{infrun.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_return\_value() & infcmd.c & \cxreffunc{print_return_value}{infcmd.c}\\
\ & restore\_inferior\_status() & infrun.c & \cxreffunc{restore_inferior_status}{infrun.c}\\
\ & save\_inferior\_status() & infrun.c & \cxreffunc{save_inferior_status}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable debug\_handcall\_setup}
\label{var_debug_handcall_setup_infrun.c}

{\stt int debug\_handcall\_setup}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\cxreftabbreak{cxreftabiii}
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & top.c & \ & \cxreffile{top.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & discard\_hand\_call\_cleanups() & utils.c & \cxreffunc{discard_hand_call_cleanups}{utils.c}\\
\ & do\_end\_debugger\_mode() & objc-lang.c & \cxreffunc{do_end_debugger_mode}{objc-lang.c}\\
\ & do\_hand\_call\_cleanups() & utils.c & \cxreffunc{do_hand_call_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_reset\_debug\_mode\_flag() & objc-lang.c & \cxreffunc{do_reset_debug_mode_flag}{objc-lang.c}\\
\ & make\_cleanup\_set\_restore\_debugger\_mode() & objc-lang.c & \cxreffunc{make_cleanup_set_restore_debugger_mode}{objc-lang.c}\\
\ & objc\_setup\_safe\_print() & objc-lang.c & \cxreffunc{objc_setup_safe_print}{objc-lang.c}\\
\ & set\_scheduler\_locking\_mode() & infrun.c & \cxreffunc{set_scheduler_locking_mode}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable currently\_inside\_optimized\_code}
\label{var_currently_inside_optimized_code_infrun.c}

{\stt int currently\_inside\_optimized\_code}

\smallskip
\begin{cxreftabiii}
Visible in:\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & interps.c & \ & \cxreffile{interps.c}\\
\ & main.c & \ & \cxreffile{main.c}\\
\ & objc-exp.c & \ & \cxreffile{objc-exp.c}\\
\ & p-exp.c & \ & \cxreffile{p-exp.c}\\
\ & source.c & \ & \cxreffile{source.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
Used in:\ & adjust\_prompts\_for\_optimized\_code() & event-top.c & \cxreffunc{adjust_prompts_for_optimized_code}{event-top.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & set\_async\_prompt() & event-top.c & \cxreffunc{set_async_prompt}{event-top.c}\\
\end{cxreftabiii}


\subsubsection{Variable stop\_after\_trap}
\label{var_stop_after_trap_infrun.c}

{\stt int stop\_after\_trap}

\smallskip
\begin{cxreftabiii}
Visible in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
Used in:\ & clear\_proceed\_status() & infrun.c & \cxreffunc{clear_proceed_status}{infrun.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\ & restore\_inferior\_status() & infrun.c & \cxreffunc{restore_inferior_status}{infrun.c}\\
\ & save\_inferior\_status() & infrun.c & \cxreffunc{save_inferior_status}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable async\_ecss}
\label{var_async_ecss_infrun.c}

{\stt struct execution\_control\_state async\_ecss}

\smallskip
\begin{cxreftabiii}
Visible in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
Used in:\ & fetch\_inferior\_event() & infrun.c & \cxreffunc{fetch_inferior_event}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable async\_ecs}
\label{var_async_ecs_infrun.c}

{\stt struct execution\_control\_state* async\_ecs}

\smallskip
\begin{cxreftabiii}
Visible in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
Used in:\ & fetch\_inferior\_event() & infrun.c & \cxreffunc{fetch_inferior_event}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Variable stepped\_after\_stopped\_by\_watchpoint}
\label{var_stepped_after_stopped_by_watchpoint_infrun.c}

{\stt int stepped\_after\_stopped\_by\_watchpoint}

\smallskip
\begin{cxreftabiii}
Visible in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & remote\_stopped\_data\_address() & remote.c & \cxreffunc{remote_stopped_data_address}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf previous\_inferior\_ptid}
\label{var_previous_inferior_ptid_infrun.c}

{\stt static ptid\_t previous\_inferior\_ptid}

\smallskip
\begin{cxreftabiii}
Used in:\ & fetch\_inferior\_event() & \ & \cxreffunc{fetch_inferior_event}{infrun.c}\\
\ & normal\_stop() & \ & \cxreffunc{normal_stop}{infrun.c}\\
\ & wait\_for\_inferior() & \ & \cxreffunc{wait_for_inferior}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf may\_follow\_exec}
\label{var_may_follow_exec_infrun.c}

{\stt static int may\_follow\_exec}

\smallskip
\begin{cxreftabiii}
Used in:\ & follow\_exec() & \ & \cxreffunc{follow_exec}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf debug\_infrun}
\label{var_debug_infrun_infrun.c}

{\stt static int debug\_infrun}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_frame() & \ & \cxreffunc{insert_step_resume_breakpoint_at_frame}{infrun.c}\\
\ & prepare\_to\_wait() & \ & \cxreffunc{prepare_to_wait}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & proceed() & \ & \cxreffunc{proceed}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\ & stop\_stepping() & \ & \cxreffunc{stop_stepping}{infrun.c}\\
\ & wait\_for\_inferior() & \ & \cxreffunc{wait_for_inferior}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf signal\_stop}
\label{var_signal_stop_infrun.c}

{\stt static unsigned char* signal\_stop}

\smallskip
\begin{cxreftabiii}
Used in:\ & allocate\_signal\_set() & \ & \cxreffunc{allocate_signal_set}{infrun.c}\\
\ & handle\_command() & \ & \cxreffunc{handle_command}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & print\_stop\_reason() & \ & \cxreffunc{print_stop_reason}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & sig\_print\_info() & \ & \cxreffunc{sig_print_info}{infrun.c}\\
\ & signal\_stop\_state() & \ & \cxreffunc{signal_stop_state}{infrun.c}\\
\ & signal\_stop\_update() & \ & \cxreffunc{signal_stop_update}{infrun.c}\\
\ & xdb\_handle\_command() & \ & \cxreffunc{xdb_handle_command}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf signal\_print}
\label{var_signal_print_infrun.c}

{\stt static unsigned char* signal\_print}

\smallskip
\begin{cxreftabiii}
Used in:\ & allocate\_signal\_set() & \ & \cxreffunc{allocate_signal_set}{infrun.c}\\
\ & handle\_command() & \ & \cxreffunc{handle_command}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & sig\_print\_info() & \ & \cxreffunc{sig_print_info}{infrun.c}\\
\ & signal\_print\_state() & \ & \cxreffunc{signal_print_state}{infrun.c}\\
\ & signal\_print\_update() & \ & \cxreffunc{signal_print_update}{infrun.c}\\
\ & xdb\_handle\_command() & \ & \cxreffunc{xdb_handle_command}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf signal\_program}
\label{var_signal_program_infrun.c}

{\stt static unsigned char* signal\_program}

\smallskip
\begin{cxreftabiii}
Used in:\ & allocate\_signal\_set() & \ & \cxreffunc{allocate_signal_set}{infrun.c}\\
\ & handle\_command() & \ & \cxreffunc{handle_command}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & keep\_going() & \ & \cxreffunc{keep_going}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & proceed() & \ & \cxreffunc{proceed}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & sig\_print\_info() & \ & \cxreffunc{sig_print_info}{infrun.c}\\
\ & signal\_pass\_state() & \ & \cxreffunc{signal_pass_state}{infrun.c}\\
\ & signal\_pass\_update() & \ & \cxreffunc{signal_pass_update}{infrun.c}\\
\ & xdb\_handle\_command() & \ & \cxreffunc{xdb_handle_command}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf stop\_command}
\label{var_stop_command_infrun.c}

{\stt static struct cmd\_list\_element* stop\_command}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & normal\_stop() & \ & \cxreffunc{normal_stop}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf breakpoints\_inserted}
\label{var_breakpoints_inserted_infrun.c}

{\stt static int breakpoints\_inserted}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & init\_wait\_for\_inferior() & \ & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_sal() & \ & \cxreffunc{insert_step_resume_breakpoint_at_sal}{infrun.c}\\
\ & keep\_going() & \ & \cxreffunc{keep_going}{infrun.c}\\
\ & normal\_stop() & \ & \cxreffunc{normal_stop}{infrun.c}\\
\ & proceed() & \ & \cxreffunc{proceed}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf step\_start\_function}
\label{var_step_start_function_infrun.c}

{\stt static struct symbol* step\_start\_function}

\smallskip
\begin{cxreftabiii}
Used in:\ & normal\_stop() & \ & \cxreffunc{normal_stop}{infrun.c}\\
\ & proceed() & \ & \cxreffunc{proceed}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf trap\_expected}
\label{var_trap_expected_infrun.c}

{\stt static int trap\_expected}

\smallskip
\begin{cxreftabiii}
Used in:\ & clear\_proceed\_status() & \ & \cxreffunc{clear_proceed_status}{infrun.c}\\
\ & context\_switch() & \ & \cxreffunc{context_switch}{infrun.c}\\
\ & currently\_stepping() & \ & \cxreffunc{currently_stepping}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & keep\_going() & \ & \cxreffunc{keep_going}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & proceed() & \ & \cxreffunc{proceed}{infrun.c}\\
\ & restore\_inferior\_status() & \ & \cxreffunc{restore_inferior_status}{infrun.c}\\
\ & save\_inferior\_status() & \ & \cxreffunc{save_inferior_status}{infrun.c}\\
\ & start\_remote() & \ & \cxreffunc{start_remote}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf stop\_on\_solib\_events}
\label{var_stop_on_solib_events_infrun.c}

{\stt static int stop\_on\_solib\_events}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & normal\_stop() & \ & \cxreffunc{normal_stop}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf solib\_step\_bp}
\label{var_solib_step_bp_infrun.c}

{\stt static struct breakpoint* solib\_step\_bp}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & normal\_stop() & \ & \cxreffunc{normal_stop}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf solib\_finish\_bp}
\label{var_solib_finish_bp_infrun.c}

{\stt static struct breakpoint* solib\_finish\_bp}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & normal\_stop() & \ & \cxreffunc{normal_stop}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf breakpoints\_failed}
\label{var_breakpoints_failed_infrun.c}

{\stt static int breakpoints\_failed}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & keep\_going() & \ & \cxreffunc{keep_going}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf stop\_print\_frame}
\label{var_stop_print_frame_infrun.c}

{\stt static int stop\_print\_frame}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & normal\_stop() & \ & \cxreffunc{normal_stop}{infrun.c}\\
\ & rollback\_stop() & \ & \cxreffunc{rollback_stop}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf step\_resume\_breakpoint}
\label{var_step_resume_breakpoint_infrun.c}

{\stt static struct breakpoint* step\_resume\_breakpoint}

\smallskip
\begin{cxreftabiii}
Used in:\ & context\_switch() & \ & \cxreffunc{context_switch}{infrun.c}\\
\ & currently\_stepping() & \ & \cxreffunc{currently_stepping}{infrun.c}\\
\ & fetch\_inferior\_event() & \ & \cxreffunc{fetch_inferior_event}{infrun.c}\\
\ & follow\_exec() & \ & \cxreffunc{follow_exec}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & follow\_inferior\_reset\_breakpoints() & \ & \cxreffunc{follow_inferior_reset_breakpoints}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & hide\_step\_resume\_breakpoint() & \ & \cxreffunc{hide_step_resume_breakpoint}{infrun.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_sal() & \ & \cxreffunc{insert_step_resume_breakpoint_at_sal}{infrun.c}\\
\ & restore\_step\_resume\_breakpoint() & \ & \cxreffunc{restore_step_resume_breakpoint}{infrun.c}\\
\ & wait\_for\_inferior() & \ & \cxreffunc{wait_for_inferior}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf target\_last\_wait\_ptid}
\label{var_target_last_wait_ptid_infrun.c}

{\stt static ptid\_t target\_last\_wait\_ptid}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & get\_last\_target\_status() & \ & \cxreffunc{get_last_target_status}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf target\_last\_waitstatus}
\label{var_target_last_waitstatus_infrun.c}

{\stt static struct target\_waitstatus target\_last\_waitstatus}

\smallskip
\begin{cxreftabiii}
Used in:\ & get\_last\_target\_status() & \ & \cxreffunc{get_last_target_status}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf pending\_follow}
\label{var_pending_follow_infrun.c}

{\stt static struct \{...\} pending\_follow}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & init\_wait\_for\_inferior() & \ & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf follow\_fork\_mode\_child}
\label{var_follow_fork_mode_child_infrun.c}

{\stt static const char follow\_fork\_mode\_child[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & follow\_fork() & \ & \cxreffunc{follow_fork}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf follow\_fork\_mode\_parent}
\label{var_follow_fork_mode_parent_infrun.c}

{\stt static const char follow\_fork\_mode\_parent[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf follow\_fork\_mode\_kind\_names}
\label{var_follow_fork_mode_kind_names_infrun.c}

{\stt static const char* follow\_fork\_mode\_kind\_names[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf follow\_fork\_mode\_string}
\label{var_follow_fork_mode_string_infrun.c}

{\stt static const char* follow\_fork\_mode\_string}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & follow\_fork() & \ & \cxreffunc{follow_fork}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf singlestep\_breakpoints\_inserted\_p}
\label{var_singlestep_breakpoints_inserted_p_infrun.c}

{\stt static int singlestep\_breakpoints\_inserted\_p}

\smallskip
\begin{cxreftabiii}
Used in:\ & adjust\_pc\_after\_break() & \ & \cxreffunc{adjust_pc_after_break}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf singlestep\_ptid}
\label{var_singlestep_ptid_infrun.c}

{\stt static ptid\_t singlestep\_ptid}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf saved\_singlestep\_ptid}
\label{var_saved_singlestep_ptid_infrun.c}

{\stt static ptid\_t saved\_singlestep\_ptid}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf stepping\_past\_singlestep\_breakpoint}
\label{var_stepping_past_singlestep_breakpoint_infrun.c}

{\stt static int stepping\_past\_singlestep\_breakpoint}

\smallskip
\begin{cxreftabiii}
Used in:\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & init\_wait\_for\_inferior() & \ & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf schedlock\_off}
\label{var_schedlock_off_infrun.c}

{\stt static const char schedlock\_off[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & set\_schedlock\_helper() & \ & \cxreffunc{set_schedlock_helper}{infrun.c}\\
\ & set\_scheduler\_locking\_mode() & \ & \cxreffunc{set_scheduler_locking_mode}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf schedlock\_on}
\label{var_schedlock_on_infrun.c}

{\stt static const char schedlock\_on[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\ & scheduler\_lock\_on\_p() & \ & \cxreffunc{scheduler_lock_on_p}{infrun.c}\\
\ & set\_schedlock\_helper() & \ & \cxreffunc{set_schedlock_helper}{infrun.c}\\
\ & set\_scheduler\_locking\_mode() & \ & \cxreffunc{set_scheduler_locking_mode}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf schedlock\_step}
\label{var_schedlock_step_infrun.c}

{\stt static const char schedlock\_step[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\ & scheduler\_lock\_on\_p() & \ & \cxreffunc{scheduler_lock_on_p}{infrun.c}\\
\ & set\_scheduler\_locking\_mode() & \ & \cxreffunc{set_scheduler_locking_mode}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf scheduler\_enums}
\label{var_scheduler_enums_infrun.c}

{\stt static const char* scheduler\_enums[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf scheduler\_mode}
\label{var_scheduler_mode_infrun.c}

{\stt static const char* scheduler\_mode}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\ & scheduler\_lock\_on\_p() & \ & \cxreffunc{scheduler_lock_on_p}{infrun.c}\\
\ & set\_schedlock\_helper() & \ & \cxreffunc{set_schedlock_helper}{infrun.c}\\
\ & set\_scheduler\_locking\_mode() & \ & \cxreffunc{set_scheduler_locking_mode}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf scheduler\_lock\_ptid}
\label{var_scheduler_lock_ptid_infrun.c}

{\stt static struct ptid scheduler\_lock\_ptid}

\smallskip
\begin{cxreftabiii}
Used in:\ & get\_scheduler\_lock\_ptid() & \ & \cxreffunc{get_scheduler_lock_ptid}{infrun.c}\\
\ & init\_wait\_for\_inferior() & \ & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
\ & resume() & \ & \cxreffunc{resume}{infrun.c}\\
\ & scheduler\_run\_this\_ptid() & \ & \cxreffunc{scheduler_run_this_ptid}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf prev\_pc}
\label{var_prev_pc_infrun.c}

{\stt static CORE\_ADDR prev\_pc}

\smallskip
\begin{cxreftabiii}
Used in:\ & adjust\_pc\_after\_break() & \ & \cxreffunc{adjust_pc_after_break}{infrun.c}\\
\ & context\_switch() & \ & \cxreffunc{context_switch}{infrun.c}\\
\ & handle\_inferior\_event() & \ & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & init\_execution\_control\_state() & \ & \cxreffunc{init_execution_control_state}{infrun.c}\\
\ & init\_wait\_for\_inferior() & \ & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
\ & keep\_going() & \ & \cxreffunc{keep_going}{infrun.c}\\
\ & proceed() & \ & \cxreffunc{proceed}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf suppress\_hook\_stop\_p}
\label{var_suppress_hook_stop_p_infrun.c}

{\stt static void* suppress\_hook\_stop\_p}

\smallskip
\begin{cxreftabiii}
Used in:\ & do\_cleanup\_suppress\_hook\_stop() & \ & \cxreffunc{do_cleanup_suppress_hook_stop}{infrun.c}\\
\ & hook\_stop\_stub() & \ & \cxreffunc{hook_stop_stub}{infrun.c}\\
\ & make\_cleanup\_suppress\_hook\_stop() & \ & \cxreffunc{make_cleanup_suppress_hook_stop}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf minimal\_signal\_handling}
\label{var_minimal_signal_handling_infrun.c}

{\stt static int minimal\_signal\_handling}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf minimal\_signal\_stop}
\label{var_minimal_signal_stop_infrun.c}

{\stt static unsigned char* minimal\_signal\_stop}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf minimal\_signal\_print}
\label{var_minimal_signal_print_infrun.c}

{\stt static unsigned char* minimal\_signal\_print}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf minimal\_signal\_program}
\label{var_minimal_signal_program_infrun.c}

{\stt static unsigned char* minimal\_signal\_program}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf full\_signal\_stop}
\label{var_full_signal_stop_infrun.c}

{\stt static unsigned char* full\_signal\_stop}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf full\_signal\_print}
\label{var_full_signal_print_infrun.c}

{\stt static unsigned char* full\_signal\_print}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\end{cxreftabiii}

\medskip
{\bf full\_signal\_program}
\label{var_full_signal_program_infrun.c}

{\stt static unsigned char* full\_signal\_program}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_infrun() & \ & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & \ & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_infrun()}
\label{func__initialize_infrun_infrun.c}

{\stt void \_initialize\_infrun ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & allocate\_signal\_set() & infrun.c & \cxreffunc{allocate_signal_set}{infrun.c}\\
\ & deprecated\_register\_gdbarch\_swap() & gdbarch.c & \cxreffunc{deprecated_register_gdbarch_swap}{gdbarch.c}\\
\ & ptid\_build() & infrun.c & \cxreffunc{ptid_build}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & scheduler\_run\_this\_ptid() & infrun.c & \cxreffunc{scheduler_run_this_ptid}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & infrun.c & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\ & \cxreftabiiispan{ add\_cmd(), add\_com(), add\_info(), add\_info\_alias(), add\_setshow\_boolean\_cmd(), add\_setshow\_enum\_cmd(), add\_setshow\_zinteger\_cmd()} &\\
Refs Func:\ & build\_infrun() & infrun.c & \cxreffunc{build_infrun}{infrun.c}\\
\ & handle\_command() & infrun.c & \cxreffunc{handle_command}{infrun.c}\\
\ & set\_minimal\_signal\_handling() & infrun.c & \cxreffunc{set_minimal_signal_handling}{infrun.c}\\
\ & set\_schedlock\_func() & infrun.c & \cxreffunc{set_schedlock_func}{infrun.c}\\
\ & show\_debug\_infrun() & infrun.c & \cxreffunc{show_debug_infrun}{infrun.c}\\
\ & show\_follow\_fork\_mode\_string() & infrun.c & \cxreffunc{show_follow_fork_mode_string}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_scheduler\_mode() & infrun.c & \cxreffunc{show_scheduler_mode}{infrun.c}\\
\ & show\_step\_stop\_if\_no\_debug() & infrun.c & \cxreffunc{show_step_stop_if_no_debug}{infrun.c}\\
\ & show\_stop\_on\_solib\_events() & infrun.c & \cxreffunc{show_stop_on_solib_events}{infrun.c}\\
\ & signals\_info() & infrun.c & \cxreffunc{signals_info}{infrun.c}\\
\ & xdb\_handle\_command() & infrun.c & \cxreffunc{xdb_handle_command}{infrun.c}\\
\ & \cxreftabiiispan{ not\_just\_help\_class\_command()} &\\
Refs Var:\ & dbx\_commands & main.c & \cxrefvar{dbx_commands}{main.c}\\
\ & debug\_handcall\_setup & infrun.c & \cxrefvar{debug_handcall_setup}{infrun.c}\\
\ & debug\_infrun & infrun.c & \cxrefvar{debug_infrun}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & follow\_fork\_mode\_kind\_names & infrun.c & \cxrefvar{follow_fork_mode_kind_names}{infrun.c}\\
\ & follow\_fork\_mode\_string & infrun.c & \cxrefvar{follow_fork_mode_string}{infrun.c}\\
\ & full\_signal\_print & infrun.c & \cxrefvar{full_signal_print}{infrun.c}\\
\ & full\_signal\_program & infrun.c & \cxrefvar{full_signal_program}{infrun.c}\\
\ & full\_signal\_stop & infrun.c & \cxrefvar{full_signal_stop}{infrun.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & minimal\_signal\_handling & infrun.c & \cxrefvar{minimal_signal_handling}{infrun.c}\\
\ & minimal\_signal\_print & infrun.c & \cxrefvar{minimal_signal_print}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & minimal\_signal\_program & infrun.c & \cxrefvar{minimal_signal_program}{infrun.c}\\
\ & minimal\_signal\_stop & infrun.c & \cxrefvar{minimal_signal_stop}{infrun.c}\\
\ & minus\_one\_ptid & infrun.c & \cxrefvar{minus_one_ptid}{infrun.c}\\
\ & null\_ptid & infrun.c & \cxrefvar{null_ptid}{infrun.c}\\
\ & scheduler\_enums & infrun.c & \cxrefvar{scheduler_enums}{infrun.c}\\
\ & scheduler\_mode & infrun.c & \cxrefvar{scheduler_mode}{infrun.c}\\
\ & step\_stop\_if\_no\_debug & infrun.c & \cxrefvar{step_stop_if_no_debug}{infrun.c}\\
\ & stop\_command & infrun.c & \cxrefvar{stop_command}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_on\_solib\_events & infrun.c & \cxrefvar{stop_on_solib_events}{infrun.c}\\
\ & stop\_registers & infrun.c & \cxrefvar{stop_registers}{infrun.c}\\
\ & target\_last\_wait\_ptid & infrun.c & \cxrefvar{target_last_wait_ptid}{infrun.c}\\
\ & xdb\_commands & main.c & \cxrefvar{xdb_commands}{main.c}\\
\ & \cxreftabiiispan{ cmdlist, setdebuglist, setlist, showdebuglist, showlist} &\\
\end{cxreftabiii}


\subsubsection{Global Function clear\_proceed\_status()}
\label{func_clear_proceed_status_infrun.c}

{\stt void clear\_proceed\_status ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & bpstat\_clear() & breakpoint.c & \cxreffunc{bpstat_clear}{breakpoint.c}\\
Called by:\ & attach\_command() & infcmd.c & \cxreffunc{attach_command}{infcmd.c}\\
\ & continue\_command() & infcmd.c & \cxreffunc{continue_command}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & extended\_remote\_async\_create\_inferior() & remote.c & \cxreffunc{extended_remote_async_create_inferior}{remote.c}\\
\ & extended\_remote\_create\_inferior() & remote.c & \cxreffunc{extended_remote_create_inferior}{remote.c}\\
\ & finish\_command() & infcmd.c & \cxreffunc{finish_command}{infcmd.c}\\
\ & finish\_inlined\_subroutine\_command() & infcmd.c & \cxreffunc{finish_inlined_subroutine_command}{infcmd.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & init\_wait\_for\_inferior() & infrun.c & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
\ & jump\_command() & infcmd.c & \cxreffunc{jump_command}{infcmd.c}\\
\ & re\_exec\_1() & infcmd.c & \cxreffunc{re_exec_1}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & re\_exec\_once() & infcmd.c & \cxreffunc{re_exec_once}{infcmd.c}\\
\ & signal\_command() & infcmd.c & \cxreffunc{signal_command}{infcmd.c}\\
\ & step\_1\_inlining() & infcmd.c & \cxreffunc{step_1_inlining}{infcmd.c}\\
\ & step\_1\_no\_inlining() & infcmd.c & \cxreffunc{step_1_no_inlining}{infcmd.c}\\
\ & step\_once() & infcmd.c & \cxreffunc{step_once}{infcmd.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\ & until\_next\_command() & infcmd.c & \cxreffunc{until_next_command}{infcmd.c}\\
Refs Var:\ & breakpoint\_proceeded & infcmd.c & \cxrefvar{breakpoint_proceeded}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & finishing\_inlined\_subroutine & infcmd.c & \cxrefvar{finishing_inlined_subroutine}{infcmd.c}\\
\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\ & proceed\_to\_finish & infrun.c & \cxrefvar{proceed_to_finish}{infrun.c}\\
\ & step\_frame\_id & infcmd.c & \cxrefvar{step_frame_id}{infcmd.c}\\
\ & step\_over\_calls & infcmd.c & \cxrefvar{step_over_calls}{infcmd.c}\\
\ & step\_range\_end & infcmd.c & \cxrefvar{step_range_end}{infcmd.c}\\
\ & step\_range\_start & infcmd.c & \cxrefvar{step_range_start}{infcmd.c}\\
\ & stepping\_over\_inlined\_subroutine & infcmd.c & \cxrefvar{stepping_over_inlined_subroutine}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & stepping\_ranges & infcmd.c & \cxrefvar{stepping_ranges}{infcmd.c}\\
\ & stop\_after\_trap & infrun.c & \cxrefvar{stop_after_trap}{infrun.c}\\
\ & stop\_bpstat & infcmd.c & \cxrefvar{stop_bpstat}{infcmd.c}\\
\ & stop\_soon & infrun.c & \cxrefvar{stop_soon}{infrun.c}\\
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function discard\_inferior\_status()}
\label{func_discard_inferior_status_infrun.c}

{\stt void discard\_inferior\_status ( struct inferior\_status* inf\_status )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & bpstat\_clear() & breakpoint.c & \cxreffunc{bpstat_clear}{breakpoint.c}\\
\ & regcache\_xfree() & regcache.c & \cxreffunc{regcache_xfree}{regcache.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Global Function fetch\_inferior\_event()}
\label{func_fetch_inferior_event_infrun.c}

{\stt void fetch\_inferior\_event ( void* client\_data )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & do\_exec\_cleanups() & utils.c & \cxreffunc{do_exec_cleanups}{utils.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & inferior\_event\_handler() & inf-loop.c & \cxreffunc{inferior_event_handler}{inf-loop.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_execution\_control\_state() & infrun.c & \cxreffunc{init_execution_control_state}{infrun.c}\\
\ & make\_exec\_cleanup() & utils.c & \cxreffunc{make_exec_cleanup}{utils.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & registers\_changed() & regcache.c & \cxreffunc{registers_changed}{regcache.c}\\
\ & \cxreftabiiispan{ deprecated\_target\_wait\_hook()} &\\
Called by:\ & fetch\_inferior\_event\_wrapper() & inf-loop.c & \cxreffunc{fetch_inferior_event_wrapper}{inf-loop.c}\\
\ & inferior\_event\_handler() & inf-loop.c & \cxreffunc{inferior_event_handler}{inf-loop.c}\\
Refs Func:\ & delete\_step\_resume\_breakpoint() & thread.c & \cxreffunc{delete_step_resume_breakpoint}{thread.c}\\
Refs Var:\ & async\_ecs & infrun.c & \cxrefvar{async_ecs}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & async\_ecss & infrun.c & \cxrefvar{async_ecss}{infrun.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & deprecated\_target\_wait\_hook & top.c & \cxrefvar{deprecated_target_wait_hook}{top.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & overlay\_cache\_invalid & symfile.c & \cxrefvar{overlay_cache_invalid}{symfile.c}\\
\ & previous\_inferior\_ptid & infrun.c & \cxrefvar{previous_inferior_ptid}{infrun.c}\\
\ & step\_multi & infcmd.c & \cxrefvar{step_multi}{infcmd.c}\\
\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_step & infcmd.c & \cxrefvar{stop_step}{infcmd.c}\\
\ & target\_executing & top.c & \cxrefvar{target_executing}{top.c}\\
\end{cxreftabiii}


\subsubsection{Global Function follow\_inferior\_reset\_breakpoints()}
\label{func_follow_inferior_reset_breakpoints_infrun.c}

{\stt void follow\_inferior\_reset\_breakpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & breakpoint\_re\_set() & breakpoint.c & \cxreffunc{breakpoint_re_set}{breakpoint.c}\\
\ & breakpoint\_re\_set\_thread() & breakpoint.c & \cxreffunc{breakpoint_re_set_thread}{breakpoint.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function get\_last\_target\_status()}
\label{func_get_last_target_status_infrun.c}

{\stt void get\_last\_target\_status ( ptid\_t* ptidp, struct target\_waitstatus* status )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Called by:\ & inferior\_has\_execd() & infrun.c & \cxreffunc{inferior_has_execd}{infrun.c}\\
\ & inferior\_has\_forked() & infrun.c & \cxreffunc{inferior_has_forked}{infrun.c}\\
\ & inferior\_has\_vforked() & infrun.c & \cxreffunc{inferior_has_vforked}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & prepare\_to\_proceed() & infrun.c & \cxreffunc{prepare_to_proceed}{infrun.c}\\
Refs Var:\ & target\_last\_wait\_ptid & infrun.c & \cxrefvar{target_last_wait_ptid}{infrun.c}\\
\ & target\_last\_waitstatus & infrun.c & \cxrefvar{target_last_waitstatus}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function get\_scheduler\_lock\_ptid()}
\label{func_get_scheduler_lock_ptid_infrun.c}

{\stt struct ptid get\_scheduler\_lock\_ptid ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& defs.h & \ & \cxreffile{defs.h}\\
Refs Var:\ & scheduler\_lock\_ptid & infrun.c & \cxrefvar{scheduler_lock_ptid}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function handle\_inferior\_event()}
\label{func_handle_inferior_event_infrun.c}

{\stt void handle\_inferior\_event ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & add\_thread() & thread.c & \cxreffunc{add_thread}{thread.c}\\
\ & adjust\_pc\_after\_break() & infrun.c & \cxreffunc{adjust_pc_after_break}{infrun.c}\\
\ & async\_disable\_stdin() & event-top.c & \cxreffunc{async_disable_stdin}{event-top.c}\\
\cxreftabbreak{cxreftabiii}
\ & at\_inlined\_call\_site\_p() & inlining.c & \cxreffunc{at_inlined_call_site_p}{inlining.c}\\
\ & bpstat\_clear() & breakpoint.c & \cxreffunc{bpstat_clear}{breakpoint.c}\\
\ & bpstat\_copy() & breakpoint.c & \cxreffunc{bpstat_copy}{breakpoint.c}\\
\ & bpstat\_find\_step\_resume\_breakpoint() & breakpoint.c & \cxreffunc{bpstat_find_step_resume_breakpoint}{breakpoint.c}\\
\ & bpstat\_get\_triggered\_catchpoints() & breakpoint.c & \cxreffunc{bpstat_get_triggered_catchpoints}{breakpoint.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & bpstat\_what\_to\_do() & breakpoint.c & \cxreffunc{bpstat_what_to_do}{breakpoint.c}\\
\ & breakpoint\_here\_p() & breakpoint.c & \cxreffunc{breakpoint_here_p}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_thread\_match() & breakpoint.c & \cxreffunc{breakpoint_thread_match}{breakpoint.c}\\
\ & context\_switch() & infrun.c & \cxreffunc{context_switch}{infrun.c}\\
\ & current\_inlined\_subroutine\_call\_stack\_start\_pc() & inlining.c & \cxreffunc{current_inlined_subroutine_call_stack_start_pc}{inlining.c}\\
\ & currently\_stepping() & infrun.c & \cxreffunc{currently_stepping}{infrun.c}\\
\ & delete\_step\_resume\_breakpoint() & thread.c & \cxreffunc{delete_step_resume_breakpoint}{thread.c}\\
\ & disable\_longjmp\_breakpoint() & breakpoint.c & \cxreffunc{disable_longjmp_breakpoint}{breakpoint.c}\\
\ & find\_finish\_breakpoint() & breakpoint.c & \cxreffunc{find_finish_breakpoint}{breakpoint.c}\\
\ & find\_pc\_line() & symtab.c & \cxreffunc{find_pc_line}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_pc\_overlay() & symfile.c & \cxreffunc{find_pc_overlay}{symfile.c}\\
\ & find\_pc\_partial\_function() & blockframe.c & \cxreffunc{find_pc_partial_function}{blockframe.c}\\
\ & flush\_cached\_frames() & frame.c & \cxreffunc{flush_cached_frames}{frame.c}\\
\ & follow\_exec() & infrun.c & \cxreffunc{follow_exec}{infrun.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & frame\_id\_eq() & frame.c & \cxreffunc{frame_id_eq}{frame.c}\\
\ & frame\_id\_inner() & frame.c & \cxreffunc{frame_id_inner}{frame.c}\\
\ & frame\_unwind\_id() & frame.c & \cxreffunc{frame_unwind_id}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & gdbarch\_deprecated\_function\_start\_offset() & gdbarch.c & \cxreffunc{gdbarch_deprecated_function_start_offset}{gdbarch.c}\\
\ & gdbarch\_get\_longjmp\_target() & gdbarch.c & \cxreffunc{gdbarch_get_longjmp_target}{gdbarch.c}\\
\ & gdbarch\_get\_longjmp\_target\_p() & gdbarch.c & \cxreffunc{gdbarch_get_longjmp_target_p}{gdbarch.c}\\
\ & gdbarch\_have\_nonsteppable\_watchpoint() & gdbarch.c & \cxreffunc{gdbarch_have_nonsteppable_watchpoint}{gdbarch.c}\\
\ & gdbarch\_in\_solib\_return\_trampoline() & gdbarch.c & \cxreffunc{gdbarch_in_solib_return_trampoline}{gdbarch.c}\\
\ & gdbarch\_single\_step\_through\_delay() & gdbarch.c & \cxreffunc{gdbarch_single_step_through_delay}{gdbarch.c}\\
\ & gdbarch\_single\_step\_through\_delay\_p() & gdbarch.c & \cxreffunc{gdbarch_single_step_through_delay_p}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_skip\_solib\_resolver() & gdbarch.c & \cxreffunc{gdbarch_skip_solib_resolver}{gdbarch.c}\\
\ & gdbarch\_skip\_trampoline\_code() & gdbarch.c & \cxreffunc{gdbarch_skip_trampoline_code}{gdbarch.c}\\
\ & gdbarch\_software\_single\_step() & gdbarch.c & \cxreffunc{gdbarch_software_single_step}{gdbarch.c}\\
\ & gdbarch\_software\_single\_step\_p() & gdbarch.c & \cxreffunc{gdbarch_software_single_step_p}{gdbarch.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_frame\_type() & frame.c & \cxreffunc{get_frame_type}{frame.c}\\
\ & get\_prev\_frame() & frame.c & \cxreffunc{get_prev_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & in\_prologue() & symtab.c & \cxreffunc{in_prologue}{symtab.c}\\
\ & in\_solib\_dynsym\_resolve\_code() & solib.c & \cxreffunc{in_solib_dynsym_resolve_code}{solib.c}\\
\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\ & inlined\_function\_call\_stack\_pc() & inlining.c & \cxreffunc{inlined_function_call_stack_pc}{inlining.c}\\
\ & inlined\_function\_update\_call\_stack() & inlining.c & \cxreffunc{inlined_function_update_call_stack}{inlining.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_frame() & infrun.c & \cxreffunc{insert_step_resume_breakpoint_at_frame}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & insert\_step\_resume\_breakpoint\_at\_sal() & infrun.c & \cxreffunc{insert_step_resume_breakpoint_at_sal}{infrun.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & is\_at\_stepping\_ranges\_end() & inlining.c & \cxreffunc{is_at_stepping_ranges_end}{inlining.c}\\
\ & is\_within\_stepping\_ranges() & inlining.c & \cxreffunc{is_within_stepping_ranges}{inlining.c}\\
\ & keep\_going() & infrun.c & \cxreffunc{keep_going}{infrun.c}\\
\ & length\_of\_this\_instruction() & target/target.c & \cxreffunc{length_of_this_instruction}{target/target.c}\\
\ & lookup\_internalvar() & value.c & \cxreffunc{lookup_internalvar}{value.c}\\
\ & paddr() & utils.c & \cxreffunc{paddr}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & pc\_set\_load\_state() & objfiles.c & \cxreffunc{pc_set_load_state}{objfiles.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & prepare\_to\_wait() & infrun.c & \cxreffunc{prepare_to_wait}{infrun.c}\\
\ & print\_stop\_reason() & infrun.c & \cxreffunc{print_stop_reason}{infrun.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & re\_enable\_breakpoints\_in\_shlibs() & breakpoint.c & \cxreffunc{re_enable_breakpoints_in_shlibs}{breakpoint.c}\\
\ & read\_pc() & regcache.c & \cxreffunc{read_pc}{regcache.c}\\
\ & read\_pc\_pid() & regcache.c & \cxreffunc{read_pc_pid}{regcache.c}\\
\ & registers\_changed() & regcache.c & \cxreffunc{registers_changed}{regcache.c}\\
\ & remove\_breakpoints() & breakpoint.c & \cxreffunc{remove_breakpoints}{breakpoint.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_breakpoint\_sal() & breakpoint.c & \cxreffunc{set_breakpoint_sal}{breakpoint.c}\\
\ & set\_internalvar() & value.c & \cxreffunc{set_internalvar}{value.c}\\
\ & set\_longjmp\_resume\_breakpoint() & breakpoint.c & \cxreffunc{set_longjmp_resume_breakpoint}{breakpoint.c}\\
\ & skip\_language\_trampoline() & language.c & \cxreffunc{skip_language_trampoline}{language.c}\\
\ & step\_into\_function() & infrun.c & \cxreffunc{step_into_function}{infrun.c}\\
\ & stop\_stepping() & infrun.c & \cxreffunc{stop_stepping}{infrun.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & write\_pc\_pid() & regcache.c & \cxreffunc{write_pc_pid}{regcache.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), dcache\_invalidate(), deprecated\_context\_hook(), exceptions\_state\_mc\_action\_iter(), exceptions\_state\_mc\_action\_iter\_1(), exceptions\_state\_mc\_init(), macosx\_pid\_or\_tid\_to\_str(), macosx\_print\_extra\_stop\_info(), macosx\_solib\_add(), sigsetjmp(), state\_change\_hook(), strlen(), xstrdup()} &\\
Called by:\ & fetch\_inferior\_event() & infrun.c & \cxreffunc{fetch_inferior_event}{infrun.c}\\
\ & wait\_for\_inferior() & infrun.c & \cxreffunc{wait_for_inferior}{infrun.c}\\
Refs Var:\ & auto\_solib\_add & symfile.c & \cxrefvar{auto_solib_add}{symfile.c}\\
\ & breakpoints\_failed & infrun.c & \cxrefvar{breakpoints_failed}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoints\_inserted & infrun.c & \cxrefvar{breakpoints_inserted}{infrun.c}\\
\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & debug\_infrun & infrun.c & \cxrefvar{debug_infrun}{infrun.c}\\
\ & deprecated\_context\_hook & top.c & \cxrefvar{deprecated_context_hook}{top.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\cxreftabbreak{cxreftabiii}
\ & inferior\_ignoring\_leading\_exec\_events & infrun.c & \cxrefvar{inferior_ignoring_leading_exec_events}{infrun.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & minus\_one\_ptid & infrun.c & \cxrefvar{minus_one_ptid}{infrun.c}\\
\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\ & pending\_follow & infrun.c & \cxrefvar{pending_follow}{infrun.c}\\
\ & prev\_pc & infrun.c & \cxrefvar{prev_pc}{infrun.c}\\
\ & saved\_singlestep\_ptid & infrun.c & \cxrefvar{saved_singlestep_ptid}{infrun.c}\\
\ & schedlock\_on & infrun.c & \cxrefvar{schedlock_on}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & scheduler\_mode & infrun.c & \cxrefvar{scheduler_mode}{infrun.c}\\
\ & signal\_print & infrun.c & \cxrefvar{signal_print}{infrun.c}\\
\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\ & singlestep\_breakpoints\_inserted\_p & infrun.c & \cxrefvar{singlestep_breakpoints_inserted_p}{infrun.c}\\
\ & singlestep\_ptid & infrun.c & \cxrefvar{singlestep_ptid}{infrun.c}\\
\ & solib\_finish\_bp & infrun.c & \cxrefvar{solib_finish_bp}{infrun.c}\\
\ & solib\_step\_bp & infrun.c & \cxrefvar{solib_step_bp}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & state\_change\_hook & top.c & \cxrefvar{state_change_hook}{top.c}\\
\ & step\_frame\_id & infcmd.c & \cxrefvar{step_frame_id}{infcmd.c}\\
\ & step\_over\_calls & infcmd.c & \cxrefvar{step_over_calls}{infcmd.c}\\
\ & step\_range\_end & infcmd.c & \cxrefvar{step_range_end}{infcmd.c}\\
\ & step\_range\_start & infcmd.c & \cxrefvar{step_range_start}{infcmd.c}\\
\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\ & step\_stop\_if\_no\_debug & infrun.c & \cxrefvar{step_stop_if_no_debug}{infrun.c}\\
\ & stepped\_after\_stopped\_by\_watchpoint & infrun.c & \cxrefvar{stepped_after_stopped_by_watchpoint}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & stepping\_over\_inlined\_subroutine & infcmd.c & \cxrefvar{stepping_over_inlined_subroutine}{infcmd.c}\\
\ & stepping\_past\_singlestep\_breakpoint & infrun.c & \cxrefvar{stepping_past_singlestep_breakpoint}{infrun.c}\\
\ & stepping\_ranges & infcmd.c & \cxrefvar{stepping_ranges}{infcmd.c}\\
\ & stop\_after\_trap & infrun.c & \cxrefvar{stop_after_trap}{infrun.c}\\
\ & stop\_bpstat & infcmd.c & \cxrefvar{stop_bpstat}{infcmd.c}\\
\ & stop\_on\_solib\_events & infrun.c & \cxrefvar{stop_on_solib_events}{infrun.c}\\
\ & stop\_pc & infcmd.c & \cxrefvar{stop_pc}{infcmd.c}\\
\ & stop\_print\_frame & infrun.c & \cxrefvar{stop_print_frame}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_signal & infcmd.c & \cxrefvar{stop_signal}{infcmd.c}\\
\ & stop\_soon & infrun.c & \cxrefvar{stop_soon}{infrun.c}\\
\ & stop\_stack\_dummy & infcmd.c & \cxrefvar{stop_stack_dummy}{infcmd.c}\\
\ & stop\_step & infcmd.c & \cxrefvar{stop_step}{infcmd.c}\\
\ & stopped\_by\_random\_signal & infcmd.c & \cxrefvar{stopped_by_random_signal}{infcmd.c}\\
\ & sync\_execution & infrun.c & \cxrefvar{sync_execution}{infrun.c}\\
\ & target\_dcache & target/target.c & \cxrefvar{target_dcache}{target/target.c}\\
\ & target\_last\_wait\_ptid & infrun.c & \cxrefvar{target_last_wait_ptid}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & target\_last\_waitstatus & infrun.c & \cxrefvar{target_last_waitstatus}{infrun.c}\\
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Global Function hide\_step\_resume\_breakpoint()}
\label{func_hide_step_resume_breakpoint_infrun.c}

{\stt struct breakpoint* hide\_step\_resume\_breakpoint ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Called by:\ & do\_end\_debugger\_mode() & objc-lang.c & \cxreffunc{do_end_debugger_mode}{objc-lang.c}\\
Refs Var:\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function inferior\_has\_execd()}
\label{func_inferior_has_execd_infrun.c}

{\stt int inferior\_has\_execd ( int pid, char** execd\_pathname )}

\smallskip
\begin{cxreftabiii}
Prototype:& target.h & \ & \cxreffile{target.h}\\
Calls:\ & get\_last\_target\_status() & infrun.c & \cxreffunc{get_last_target_status}{infrun.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function inferior\_has\_forked()}
\label{func_inferior_has_forked_infrun.c}

{\stt int inferior\_has\_forked ( int pid, int* child\_pid )}

\smallskip
\begin{cxreftabiii}
Prototype:& target.h & \ & \cxreffile{target.h}\\
Calls:\ & get\_last\_target\_status() & infrun.c & \cxreffunc{get_last_target_status}{infrun.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function inferior\_has\_vforked()}
\label{func_inferior_has_vforked_infrun.c}

{\stt int inferior\_has\_vforked ( int pid, int* child\_pid )}

\smallskip
\begin{cxreftabiii}
Prototype:& target.h & \ & \cxreffile{target.h}\\
Calls:\ & get\_last\_target\_status() & infrun.c & \cxreffunc{get_last_target_status}{infrun.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function init\_execution\_control\_state()}
\label{func_init_execution_control_state_infrun.c}

{\stt void init\_execution\_control\_state ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & find\_pc\_line() & symtab.c & \cxreffunc{find_pc_line}{symtab.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
Called by:\ & fetch\_inferior\_event() & infrun.c & \cxreffunc{fetch_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & wait\_for\_inferior() & infrun.c & \cxreffunc{wait_for_inferior}{infrun.c}\\
Refs Var:\ & prev\_pc & infrun.c & \cxrefvar{prev_pc}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function init\_wait\_for\_inferior()}
\label{func_init_wait_for_inferior_infrun.c}

{\stt void init\_wait\_for\_inferior ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & breakpoint\_init\_inferior() & breakpoint.c & \cxreffunc{breakpoint_init_inferior}{breakpoint.c}\\
\ & clear\_proceed\_status() & infrun.c & \cxreffunc{clear_proceed_status}{infrun.c}\\
Called by:\ & attach\_command() & infcmd.c & \cxreffunc{attach_command}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & kill\_if\_already\_running() & infcmd.c & \cxreffunc{kill_if_already_running}{infcmd.c}\\
\ & start\_remote() & infrun.c & \cxreffunc{start_remote}{infrun.c}\\
Refs Var:\ & breakpoints\_inserted & infrun.c & \cxrefvar{breakpoints_inserted}{infrun.c}\\
\ & minus\_one\_ptid & infrun.c & \cxrefvar{minus_one_ptid}{infrun.c}\\
\ & pending\_follow & infrun.c & \cxrefvar{pending_follow}{infrun.c}\\
\ & prev\_pc & infrun.c & \cxrefvar{prev_pc}{infrun.c}\\
\ & scheduler\_lock\_ptid & infrun.c & \cxrefvar{scheduler_lock_ptid}{infrun.c}\\
\ & stepping\_past\_singlestep\_breakpoint & infrun.c & \cxrefvar{stepping_past_singlestep_breakpoint}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_signal & infcmd.c & \cxrefvar{stop_signal}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function insert\_step\_resume\_breakpoint\_at\_sal()}
\label{func_insert_step_resume_breakpoint_at_sal_infrun.c}

{\stt void insert\_step\_resume\_breakpoint\_at\_sal ( struct symtab\_and\_line sr\_sal, struct frame\_id sr\_id )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & adjust\_current\_inlined\_subroutine\_stack\_position() & inlining.c & \cxreffunc{adjust_current_inlined_subroutine_stack_position}{inlining.c}\\
\ & inlined\_function\_end\_of\_inlined\_code\_p() & inlining.c & \cxreffunc{inlined_function_end_of_inlined_code_p}{inlining.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & set\_momentary\_breakpoint() & breakpoint.c & \cxreffunc{set_momentary_breakpoint}{breakpoint.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_frame() & infrun.c & \cxreffunc{insert_step_resume_breakpoint_at_frame}{infrun.c}\\
\ & step\_into\_function() & infrun.c & \cxreffunc{step_into_function}{infrun.c}\\
Refs Var:\ & breakpoints\_inserted & infrun.c & \cxrefvar{breakpoints_inserted}{infrun.c}\\
\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function make\_cleanup\_restore\_inferior\_status()}
\label{func_make_cleanup_restore_inferior_status_infrun.c}

{\stt struct cleanup* make\_cleanup\_restore\_inferior\_status ( struct inferior\_status* inf\_status )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
Called by:\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
Refs Func:\ & do\_restore\_inferior\_status\_cleanup() & infrun.c & \cxreffunc{do_restore_inferior_status_cleanup}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function make\_cleanup\_suppress\_hook\_stop()}
\label{func_make_cleanup_suppress_hook_stop_infrun.c}

{\stt struct cleanup* make\_cleanup\_suppress\_hook\_stop ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
Called by:\ & parse\_exp\_in\_context() & parse.c & \cxreffunc{parse_exp_in_context}{parse.c}\\
Refs Func:\ & do\_cleanup\_suppress\_hook\_stop() & infrun.c & \cxreffunc{do_cleanup_suppress_hook_stop}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & suppress\_hook\_stop\_p & infrun.c & \cxrefvar{suppress_hook_stop_p}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function normal\_stop()}
\label{func_normal_stop_infrun.c}

{\stt void normal\_stop ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & bpstat\_num() & breakpoint.c & \cxreffunc{bpstat_num}{breakpoint.c}\\
\ & bpstat\_print() & breakpoint.c & \cxreffunc{bpstat_print}{breakpoint.c}\\
\ & breakpoint\_auto\_delete() & breakpoint.c & \cxreffunc{breakpoint_auto_delete}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & clear\_inlined\_subroutine\_print\_frames() & inlining.c & \cxreffunc{clear_inlined_subroutine_print_frames}{inlining.c}\\
\ & current\_inlined\_subroutine\_call\_stack\_start\_pc() & inlining.c & \cxreffunc{current_inlined_subroutine_call_stack_start_pc}{inlining.c}\\
\ & deprecated\_update\_frame\_pc\_hack() & frame.c & \cxreffunc{deprecated_update_frame_pc_hack}{frame.c}\\
\ & disable\_current\_display() & printcmd.c & \cxreffunc{disable_current_display}{printcmd.c}\\
\ & do\_displays() & printcmd.c & \cxreffunc{do_displays}{printcmd.c}\\
\ & find\_pc\_function() & blockframe.c & \cxreffunc{find_pc_function}{blockframe.c}\\
\ & find\_pc\_function\_no\_inlined() & blockframe.c & \cxreffunc{find_pc_function_no_inlined}{blockframe.c}\\
\ & frame\_id\_eq() & frame.c & \cxreffunc{frame_id_eq}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & frame\_pop() & frame.c & \cxreffunc{frame_pop}{frame.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_frame\_type() & frame.c & \cxreffunc{get_frame_type}{frame.c}\\
\ & get\_last\_target\_status() & infrun.c & \cxreffunc{get_last_target_status}{infrun.c}\\
\ & get\_prev\_frame() & frame.c & \cxreffunc{get_prev_frame}{frame.c}\\
\ & get\_selected\_frame() & frame.c & \cxreffunc{get_selected_frame}{frame.c}\\
\ & inlined\_function\_call\_stack\_pc() & inlining.c & \cxreffunc{inlined_function_call_stack_pc}{inlining.c}\\
\cxreftabbreak{cxreftabiii}
\ & inlined\_function\_update\_call\_stack() & inlining.c & \cxreffunc{inlined_function_update_call_stack}{inlining.c}\\
\ & inlined\_subroutine\_restore\_after\_dummy\_call() & inlining.c & \cxreffunc{inlined_subroutine_restore_after_dummy_call}{inlining.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & observer\_notify\_normal\_stop() & observer.c & \cxreffunc{observer_notify_normal_stop}{observer.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & print\_stack\_frame() & stack.c & \cxreffunc{print_stack_frame}{stack.c}\\
\ & print\_stop\_reason() & infrun.c & \cxreffunc{print_stop_reason}{infrun.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & read\_pc() & regcache.c & \cxreffunc{read_pc}{regcache.c}\\
\ & regcache\_cpy() & regcache.c & \cxreffunc{regcache_cpy}{regcache.c}\\
\ & remove\_breakpoints() & breakpoint.c & \cxreffunc{remove_breakpoints}{breakpoint.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\ & ui\_out\_print\_annotation\_int() & ui-out.c & \cxreffunc{ui_out_print_annotation_int}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_print\_annotation\_string() & ui-out.c & \cxreffunc{ui_out_print_annotation_string}{ui-out.c}\\
\ & \cxreftabiiispan{ annotate\_stopped(), catch\_errors(), macosx\_pid\_or\_tid\_to\_str(), maybe\_create\_checkpoint(), stack\_changed\_hook(), state\_change\_hook(), strncmp()} &\\
Called by:\ & attach\_command() & infcmd.c & \cxreffunc{attach_command}{infcmd.c}\\
\ & fetch\_inferior\_event() & infrun.c & \cxreffunc{fetch_inferior_event}{infrun.c}\\
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\ & resume\_cleanups() & infrun.c & \cxreffunc{resume_cleanups}{infrun.c}\\
\ & rollback\_stop() & infrun.c & \cxreffunc{rollback_stop}{infrun.c}\\
\ & start\_remote() & infrun.c & \cxreffunc{start_remote}{infrun.c}\\
Refs Func:\ & hook\_stop\_stub() & infrun.c & \cxreffunc{hook_stop_stub}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoints\_inserted & infrun.c & \cxrefvar{breakpoints_inserted}{infrun.c}\\
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & currently\_inside\_optimized\_code & infrun.c & \cxrefvar{currently_inside_optimized_code}{infrun.c}\\
\ & deprecated\_selected\_frame & frame.c & \cxrefvar{deprecated_selected_frame}{frame.c}\\
\ & dwarf2\_inform\_debugging\_optimized\_code & dwarf2read.c & \cxrefvar{dwarf2_inform_debugging_optimized_code}{dwarf2read.c}\\
\ & finishing\_inlined\_subroutine & infcmd.c & \cxrefvar{finishing_inlined_subroutine}{infcmd.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & interpreter\_p & main.c & \cxrefvar{interpreter_p}{main.c}\\
\ & previous\_inferior\_ptid & infrun.c & \cxrefvar{previous_inferior_ptid}{infrun.c}\\
\ & proceed\_to\_finish & infrun.c & \cxrefvar{proceed_to_finish}{infrun.c}\\
\ & solib\_finish\_bp & infrun.c & \cxrefvar{solib_finish_bp}{infrun.c}\\
\ & solib\_step\_bp & infrun.c & \cxrefvar{solib_step_bp}{infrun.c}\\
\ & stack\_changed\_hook & top.c & \cxrefvar{stack_changed_hook}{top.c}\\
\ & state\_change\_hook & top.c & \cxrefvar{state_change_hook}{top.c}\\
\ & step\_frame\_id & infcmd.c & \cxrefvar{step_frame_id}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & step\_multi & infcmd.c & \cxrefvar{step_multi}{infcmd.c}\\
\ & step\_start\_function & infrun.c & \cxrefvar{step_start_function}{infrun.c}\\
\ & stop\_bpstat & infcmd.c & \cxrefvar{stop_bpstat}{infcmd.c}\\
\ & stop\_command & infrun.c & \cxrefvar{stop_command}{infrun.c}\\
\ & stop\_on\_solib\_events & infrun.c & \cxrefvar{stop_on_solib_events}{infrun.c}\\
\ & stop\_pc & infcmd.c & \cxrefvar{stop_pc}{infcmd.c}\\
\ & stop\_print\_frame & infrun.c & \cxrefvar{stop_print_frame}{infrun.c}\\
\ & stop\_registers & infrun.c & \cxrefvar{stop_registers}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_stack\_dummy & infcmd.c & \cxrefvar{stop_stack_dummy}{infcmd.c}\\
\ & stop\_step & infcmd.c & \cxrefvar{stop_step}{infcmd.c}\\
\ & stopped\_by\_random\_signal & infcmd.c & \cxrefvar{stopped_by_random_signal}{infcmd.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\ & \cxreftabiiispan{ auto\_checkpointing} &\\
\end{cxreftabiii}


\subsubsection{Global Function pid\_to\_ptid()}
\label{func_pid_to_ptid_infrun.c}

{\stt ptid\_t pid\_to\_ptid ( int pid )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & ptid\_build() & infrun.c & \cxreffunc{ptid_build}{infrun.c}\\
Called by:\ & \_initialize\_regcache() & regcache.c & \cxreffunc{_initialize_regcache}{regcache.c}\\
\ & detach\_breakpoints() & breakpoint.c & \cxreffunc{detach_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & follow\_exec() & infrun.c & \cxreffunc{follow_exec}{infrun.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & init\_execution\_control\_state() & infrun.c & \cxreffunc{init_execution_control_state}{infrun.c}\\
\ & prepare\_to\_wait() & infrun.c & \cxreffunc{prepare_to_wait}{infrun.c}\\
\ & reattach\_breakpoints() & breakpoint.c & \cxreffunc{reattach_breakpoints}{breakpoint.c}\\
\ & registers\_changed() & regcache.c & \cxreffunc{registers_changed}{regcache.c}\\
\ & remote\_current\_thread() & remote.c & \cxreffunc{remote_current_thread}{remote.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & thread\_alive() & thread.c & \cxreffunc{thread_alive}{thread.c}\\
\ & thread\_id\_to\_pid() & thread.c & \cxreffunc{thread_id_to_pid}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function proceed()}
\label{func_proceed_infrun.c}

{\stt void proceed ( CORE\_ADDR addr, enum target\_signal siggnal, int step )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & bpstat\_should\_step() & breakpoint.c & \cxreffunc{bpstat_should_step}{breakpoint.c}\\
\ & breakpoint\_here\_p() & breakpoint.c & \cxreffunc{breakpoint_here_p}{breakpoint.c}\\
\ & do\_hand\_call\_cleanups() & utils.c & \cxreffunc{do_hand_call_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_pc\_function() & blockframe.c & \cxreffunc{find_pc_function}{blockframe.c}\\
\ & find\_pc\_partial\_function\_no\_inlined() & blockframe.c & \cxreffunc{find_pc_partial_function_no_inlined}{blockframe.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & gdbarch\_single\_step\_through\_delay() & gdbarch.c & \cxreffunc{gdbarch_single_step_through_delay}{gdbarch.c}\\
\ & gdbarch\_single\_step\_through\_delay\_p() & gdbarch.c & \cxreffunc{gdbarch_single_step_through_delay_p}{gdbarch.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & prepare\_to\_proceed() & infrun.c & \cxreffunc{prepare_to_proceed}{infrun.c}\\
\ & read\_pc() & regcache.c & \cxreffunc{read_pc}{regcache.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\ & wait\_for\_inferior() & infrun.c & \cxreffunc{wait_for_inferior}{infrun.c}\\
\ & write\_pc() & regcache.c & \cxreffunc{write_pc}{regcache.c}\\
\ & \cxreftabiiispan{ annotate\_starting()} &\\
Called by:\ & continue\_command() & infcmd.c & \cxreffunc{continue_command}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & extended\_remote\_async\_create\_inferior() & remote.c & \cxreffunc{extended_remote_async_create_inferior}{remote.c}\\
\ & extended\_remote\_create\_inferior() & remote.c & \cxreffunc{extended_remote_create_inferior}{remote.c}\\
\ & finish\_command() & infcmd.c & \cxreffunc{finish_command}{infcmd.c}\\
\ & finish\_inlined\_subroutine\_command() & infcmd.c & \cxreffunc{finish_inlined_subroutine_command}{infcmd.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & jump\_command() & infcmd.c & \cxreffunc{jump_command}{infcmd.c}\\
\ & re\_exec\_1() & infcmd.c & \cxreffunc{re_exec_1}{infcmd.c}\\
\ & re\_exec\_once() & infcmd.c & \cxreffunc{re_exec_once}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & signal\_command() & infcmd.c & \cxreffunc{signal_command}{infcmd.c}\\
\ & step\_1\_inlining() & infcmd.c & \cxreffunc{step_1_inlining}{infcmd.c}\\
\ & step\_1\_no\_inlining() & infcmd.c & \cxreffunc{step_1_no_inlining}{infcmd.c}\\
\ & step\_once() & infcmd.c & \cxreffunc{step_once}{infcmd.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\ & until\_next\_command() & infcmd.c & \cxreffunc{until_next_command}{infcmd.c}\\
Refs Var:\ & breakpoints\_inserted & infrun.c & \cxrefvar{breakpoints_inserted}{infrun.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & debug\_infrun & infrun.c & \cxrefvar{debug_infrun}{infrun.c}\\
\ & gdb\_override\_async & target/target.c & \cxrefvar{gdb_override_async}{target/target.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & prev\_pc & infrun.c & \cxrefvar{prev_pc}{infrun.c}\\
\ & proceed\_from\_hand\_call & infrun.c & \cxrefvar{proceed_from_hand_call}{infrun.c}\\
\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & step\_start\_function & infrun.c & \cxrefvar{step_start_function}{infrun.c}\\
\ & stop\_after\_trap & infrun.c & \cxrefvar{stop_after_trap}{infrun.c}\\
\ & stop\_pc & infcmd.c & \cxrefvar{stop_pc}{infcmd.c}\\
\ & stop\_signal & infcmd.c & \cxrefvar{stop_signal}{infcmd.c}\\
\ & target\_executing & top.c & \cxrefvar{target_executing}{top.c}\\
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ptid\_build()}
\label{func_ptid_build_infrun.c}

{\stt ptid\_t ptid\_build ( int pid, long lwp, long tid )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Called by:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\ & record\_currthread() & remote.c & \cxreffunc{record_currthread}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_newthread\_step() & remote.c & \cxreffunc{remote_newthread_step}{remote.c}\\
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ptid\_equal()}
\label{func_ptid_equal_infrun.c}

{\stt int ptid\_equal ( ptid\_t ptid1, ptid\_t ptid2 )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Called by:\ & delete\_thread() & thread.c & \cxreffunc{delete_thread}{thread.c}\\
\ & dummy\_frame\_push() & dummy-frame.c & \cxreffunc{dummy_frame_push}{dummy-frame.c}\\
\ & find\_thread\_pid() & thread.c & \cxreffunc{find_thread_pid}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & info\_threads\_command() & thread.c & \cxreffunc{info_threads_command}{thread.c}\\
\ & kill\_command() & inflow.c & \cxreffunc{kill_command}{inflow.c}\\
\ & kill\_if\_already\_running() & infcmd.c & \cxreffunc{kill_if_already_running}{infcmd.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & nosupport\_runtime() & target/target.c & \cxreffunc{nosupport_runtime}{target/target.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\cxreftabbreak{cxreftabiii}
\ & prepare\_to\_proceed() & infrun.c & \cxreffunc{prepare_to_proceed}{infrun.c}\\
\ & quit\_confirm() & top.c & \cxreffunc{quit_confirm}{top.c}\\
\ & quit\_target() & top.c & \cxreffunc{quit_target}{top.c}\\
\ & read\_register\_pid() & regcache.c & \cxreffunc{read_register_pid}{regcache.c}\\
\ & regcache\_raw\_read() & regcache.c & \cxreffunc{regcache_raw_read}{regcache.c}\\
\ & regcache\_raw\_supply() & regcache.c & \cxreffunc{regcache_raw_supply}{regcache.c}\\
\ & regcache\_raw\_write() & regcache.c & \cxreffunc{regcache_raw_write}{regcache.c}\\
\ & remote\_macosx\_open() & remote.c & \cxreffunc{remote_macosx_open}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & restore\_current\_thread() & thread.c & \cxreffunc{restore_current_thread}{thread.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\ & run\_command\_1() & infcmd.c & \cxreffunc{run_command_1}{infcmd.c}\\
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
\ & write\_register\_pid() & regcache.c & \cxreffunc{write_register_pid}{regcache.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ptid\_get\_lwp()}
\label{func_ptid_get_lwp_infrun.c}

{\stt long ptid\_get\_lwp ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
\end{cxreftabiii}


\subsubsection{Global Function ptid\_get\_pid()}
\label{func_ptid_get_pid_infrun.c}

{\stt int ptid\_get\_pid ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Called by:\ & attach\_command() & infcmd.c & \cxreffunc{attach_command}{infcmd.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & debug\_to\_notice\_signals() & target/target.c & \cxreffunc{debug_to_notice_signals}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & debug\_to\_pid\_to\_str() & target/target.c & \cxreffunc{debug_to_pid_to_str}{target/target.c}\\
\ & debug\_to\_post\_startup\_inferior() & target/target.c & \cxreffunc{debug_to_post_startup_inferior}{target/target.c}\\
\ & debug\_to\_resume() & target/target.c & \cxreffunc{debug_to_resume}{target/target.c}\\
\ & debug\_to\_thread\_alive() & target/target.c & \cxreffunc{debug_to_thread_alive}{target/target.c}\\
\ & debug\_to\_wait() & target/target.c & \cxreffunc{debug_to_wait}{target/target.c}\\
\ & detach\_breakpoints() & breakpoint.c & \cxreffunc{detach_breakpoints}{breakpoint.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & handle\_sigio() & inflow.c & \cxreffunc{handle_sigio}{inflow.c}\\
\cxreftabbreak{cxreftabiii}
\ & inferior\_has\_execd() & infrun.c & \cxreffunc{inferior_has_execd}{infrun.c}\\
\ & inferior\_has\_forked() & infrun.c & \cxreffunc{inferior_has_forked}{infrun.c}\\
\ & inferior\_has\_vforked() & infrun.c & \cxreffunc{inferior_has_vforked}{infrun.c}\\
\ & insert\_catchpoint() & breakpoint.c & \cxreffunc{insert_catchpoint}{breakpoint.c}\\
\ & lookup\_child\_selector() & objc-lang.c & \cxreffunc{lookup_child_selector}{objc-lang.c}\\
\ & normal\_pid\_to\_str() & target/target.c & \cxreffunc{normal_pid_to_str}{target/target.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & pass\_signal() & inflow.c & \cxreffunc{pass_signal}{inflow.c}\\
\cxreftabbreak{cxreftabiii}
\ & pid\_info() & infcmd.c & \cxreffunc{pid_info}{infcmd.c}\\
\ & reinit\_frame\_cache() & frame.c & \cxreffunc{reinit_frame_cache}{frame.c}\\
\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & remote\_find\_new\_threads() & remote.c & \cxreffunc{remote_find_new_threads}{remote.c}\\
\ & remote\_get\_thread\_local\_address() & remote.c & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\ & remote\_pid\_to\_str() & remote.c & \cxreffunc{remote_pid_to_str}{remote.c}\\
\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
\ & remote\_store\_registers() & remote.c & \cxreffunc{remote_store_registers}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_thread\_alive() & remote.c & \cxreffunc{remote_thread_alive}{remote.c}\\
\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\ & remote\_vcont\_resume() & remote.c & \cxreffunc{remote_vcont_resume}{remote.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & terminal\_init\_inferior() & inflow.c & \cxreffunc{terminal_init_inferior}{inflow.c}\\
\ & thread\_alive() & thread.c & \cxreffunc{thread_alive}{thread.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ptid\_get\_tid()}
\label{func_ptid_get_tid_infrun.c}

{\stt long ptid\_get\_tid ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
\end{cxreftabiii}


\subsubsection{Global Function restore\_inferior\_status()}
\label{func_restore_inferior_status_infrun.c}

{\stt void restore\_inferior\_status ( struct inferior\_status* inf\_status )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & bpstat\_clear() & breakpoint.c & \cxreffunc{bpstat_clear}{breakpoint.c}\\
\ & flush\_inlined\_subroutine\_frames() & inlining.c & \cxreffunc{flush_inlined_subroutine_frames}{inlining.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & inlined\_subroutine\_restore\_after\_dummy\_call() & inlining.c & \cxreffunc{inlined_subroutine_restore_after_dummy_call}{inlining.c}\\
\ & regcache\_cpy() & regcache.c & \cxreffunc{regcache_cpy}{regcache.c}\\
\ & regcache\_xfree() & regcache.c & \cxreffunc{regcache_xfree}{regcache.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ catch\_errors()} &\\
Called by:\ & do\_restore\_inferior\_status\_cleanup() & infrun.c & \cxreffunc{do_restore_inferior_status_cleanup}{infrun.c}\\
Refs Func:\ & restore\_selected\_frame() & infrun.c & \cxreffunc{restore_selected_frame}{infrun.c}\\
Refs Var:\ & breakpoint\_proceeded & infcmd.c & \cxrefvar{breakpoint_proceeded}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & proceed\_to\_finish & infrun.c & \cxrefvar{proceed_to_finish}{infrun.c}\\
\ & step\_frame\_id & infcmd.c & \cxrefvar{step_frame_id}{infcmd.c}\\
\ & step\_over\_calls & infcmd.c & \cxrefvar{step_over_calls}{infcmd.c}\\
\ & step\_range\_end & infcmd.c & \cxrefvar{step_range_end}{infcmd.c}\\
\ & step\_range\_start & infcmd.c & \cxrefvar{step_range_start}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & stepping\_ranges & infcmd.c & \cxrefvar{stepping_ranges}{infcmd.c}\\
\ & stop\_after\_trap & infrun.c & \cxrefvar{stop_after_trap}{infrun.c}\\
\ & stop\_bpstat & infcmd.c & \cxrefvar{stop_bpstat}{infcmd.c}\\
\ & stop\_pc & infcmd.c & \cxrefvar{stop_pc}{infcmd.c}\\
\ & stop\_registers & infrun.c & \cxrefvar{stop_registers}{infrun.c}\\
\ & stop\_signal & infcmd.c & \cxrefvar{stop_signal}{infcmd.c}\\
\ & stop\_soon & infrun.c & \cxrefvar{stop_soon}{infrun.c}\\
\ & stop\_stack\_dummy & infcmd.c & \cxrefvar{stop_stack_dummy}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_step & infcmd.c & \cxrefvar{stop_step}{infcmd.c}\\
\ & stopped\_by\_random\_signal & infcmd.c & \cxrefvar{stopped_by_random_signal}{infcmd.c}\\
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function restore\_step\_resume\_breakpoint()}
\label{func_restore_step_resume_breakpoint_infrun.c}

{\stt void restore\_step\_resume\_breakpoint ( struct breakpoint* bp )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & do\_end\_debugger\_mode() & objc-lang.c & \cxreffunc{do_end_debugger_mode}{objc-lang.c}\\
Refs Var:\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function resume()}
\label{func_resume_infrun.c}

{\stt void resume ( int step, enum target\_signal sig )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & breakpoint\_here\_p() & breakpoint.c & \cxreffunc{breakpoint_here_p}{breakpoint.c}\\
\ & discard\_cleanups() & utils.c & \cxreffunc{discard_cleanups}{utils.c}\\
\ & follow\_fork() & infrun.c & \cxreffunc{follow_fork}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & gdbarch\_cannot\_step\_breakpoint() & gdbarch.c & \cxreffunc{gdbarch_cannot_step_breakpoint}{gdbarch.c}\\
\ & gdbarch\_software\_single\_step() & gdbarch.c & \cxreffunc{gdbarch_software_single_step}{gdbarch.c}\\
\ & gdbarch\_software\_single\_step\_p() & gdbarch.c & \cxreffunc{gdbarch_software_single_step_p}{gdbarch.c}\\
\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & quit() & utils.c & \cxreffunc{quit}{utils.c}\\
\ & read\_pc() & regcache.c & \cxreffunc{read_pc}{regcache.c}\\
\ & remove\_hw\_watchpoints() & breakpoint.c & \cxreffunc{remove_hw_watchpoints}{breakpoint.c}\\
\ & scheduler\_run\_this\_ptid() & infrun.c & \cxreffunc{scheduler_run_this_ptid}{infrun.c}\\
\ & \cxreftabiiispan{ dcache\_invalidate()} &\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & keep\_going() & infrun.c & \cxreffunc{keep_going}{infrun.c}\\
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
Refs Func:\ & default\_skip\_permanent\_breakpoint() & infrun.c & \cxreffunc{default_skip_permanent_breakpoint}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & resume\_cleanups() & infrun.c & \cxreffunc{resume_cleanups}{infrun.c}\\
Refs Var:\ & breakpoints\_inserted & infrun.c & \cxrefvar{breakpoints_inserted}{infrun.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & debug\_infrun & infrun.c & \cxrefvar{debug_infrun}{infrun.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & minus\_one\_ptid & infrun.c & \cxrefvar{minus_one_ptid}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & pending\_follow & infrun.c & \cxrefvar{pending_follow}{infrun.c}\\
\ & quit\_flag & utils.c & \cxrefvar{quit_flag}{utils.c}\\
\ & schedlock\_on & infrun.c & \cxrefvar{schedlock_on}{infrun.c}\\
\ & schedlock\_step & infrun.c & \cxrefvar{schedlock_step}{infrun.c}\\
\ & scheduler\_lock\_ptid & infrun.c & \cxrefvar{scheduler_lock_ptid}{infrun.c}\\
\ & scheduler\_mode & infrun.c & \cxrefvar{scheduler_mode}{infrun.c}\\
\ & singlestep\_breakpoints\_inserted\_p & infrun.c & \cxrefvar{singlestep_breakpoints_inserted_p}{infrun.c}\\
\ & singlestep\_ptid & infrun.c & \cxrefvar{singlestep_ptid}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & stepping\_past\_singlestep\_breakpoint & infrun.c & \cxrefvar{stepping_past_singlestep_breakpoint}{infrun.c}\\
\ & target\_dcache & target/target.c & \cxrefvar{target_dcache}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Global Function rollback\_stop()}
\label{func_rollback_stop_infrun.c}

{\stt void rollback\_stop ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
Refs Var:\ & stop\_print\_frame & infrun.c & \cxrefvar{stop_print_frame}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function save\_inferior\_ptid()}
\label{func_save_inferior_ptid_infrun.c}

{\stt struct cleanup* save\_inferior\_ptid ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & detach\_breakpoints() & breakpoint.c & \cxreffunc{detach_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & reattach\_breakpoints() & breakpoint.c & \cxreffunc{reattach_breakpoints}{breakpoint.c}\\
Refs Func:\ & restore\_inferior\_ptid() & infrun.c & \cxreffunc{restore_inferior_ptid}{infrun.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function save\_inferior\_status()}
\label{func_save_inferior_status_infrun.c}

{\stt struct inferior\_status* save\_inferior\_status ( int restore\_stack\_info )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & bpstat\_copy() & breakpoint.c & \cxreffunc{bpstat_copy}{breakpoint.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_selected\_frame() & frame.c & \cxreffunc{get_selected_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & inlined\_subroutine\_save\_before\_dummy\_call() & inlining.c & \cxreffunc{inlined_subroutine_save_before_dummy_call}{inlining.c}\\
\ & regcache\_dup() & regcache.c & \cxreffunc{regcache_dup}{regcache.c}\\
\ & regcache\_dup\_no\_passthrough() & regcache.c & \cxreffunc{regcache_dup_no_passthrough}{regcache.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
Refs Var:\ & breakpoint\_proceeded & infcmd.c & \cxrefvar{breakpoint_proceeded}{infcmd.c}\\
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & proceed\_to\_finish & infrun.c & \cxrefvar{proceed_to_finish}{infrun.c}\\
\ & step\_frame\_id & infcmd.c & \cxrefvar{step_frame_id}{infcmd.c}\\
\ & step\_over\_calls & infcmd.c & \cxrefvar{step_over_calls}{infcmd.c}\\
\ & step\_range\_end & infcmd.c & \cxrefvar{step_range_end}{infcmd.c}\\
\ & step\_range\_start & infcmd.c & \cxrefvar{step_range_start}{infcmd.c}\\
\ & stepping\_ranges & infcmd.c & \cxrefvar{stepping_ranges}{infcmd.c}\\
\ & stop\_after\_trap & infrun.c & \cxrefvar{stop_after_trap}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_bpstat & infcmd.c & \cxrefvar{stop_bpstat}{infcmd.c}\\
\ & stop\_pc & infcmd.c & \cxrefvar{stop_pc}{infcmd.c}\\
\ & stop\_registers & infrun.c & \cxrefvar{stop_registers}{infrun.c}\\
\ & stop\_signal & infcmd.c & \cxrefvar{stop_signal}{infcmd.c}\\
\ & stop\_soon & infrun.c & \cxrefvar{stop_soon}{infrun.c}\\
\ & stop\_stack\_dummy & infcmd.c & \cxrefvar{stop_stack_dummy}{infcmd.c}\\
\ & stop\_step & infcmd.c & \cxrefvar{stop_step}{infcmd.c}\\
\ & stopped\_by\_random\_signal & infcmd.c & \cxrefvar{stopped_by_random_signal}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function scheduler\_lock\_on\_p()}
\label{func_scheduler_lock_on_p_infrun.c}

{\stt int scheduler\_lock\_on\_p ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& defs.h & \ & \cxreffile{defs.h}\\
Called by:\ & check\_safe\_call() & valops.c & \cxreffunc{check_safe_call}{valops.c}\\
\ & objc\_setup\_safe\_print() & objc-lang.c & \cxreffunc{objc_setup_safe_print}{objc-lang.c}\\
\ & print\_object\_command() & objc-lang.c & \cxreffunc{print_object_command}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
Refs Var:\ & schedlock\_on & infrun.c & \cxrefvar{schedlock_on}{infrun.c}\\
\ & schedlock\_step & infrun.c & \cxrefvar{schedlock_step}{infrun.c}\\
\ & scheduler\_mode & infrun.c & \cxrefvar{scheduler_mode}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function scheduler\_run\_this\_ptid()}
\label{func_scheduler_run_this_ptid_infrun.c}

{\stt void scheduler\_run\_this\_ptid ( struct ptid this\_ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& defs.h & \ & \cxreffile{defs.h}\\
Called by:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\ & set\_schedlock\_helper() & infrun.c & \cxreffunc{set_schedlock_helper}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
Refs Var:\ & scheduler\_lock\_ptid & infrun.c & \cxrefvar{scheduler_lock_ptid}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_scheduler\_locking\_mode()}
\label{func_set_scheduler_locking_mode_infrun.c}

{\stt enum scheduler\_locking\_mode set\_scheduler\_locking\_mode ( enum scheduler\_locking\_mode new\_mode )}

\smallskip
\begin{cxreftabiii}
Prototype:& defs.h & \ & \cxreffile{defs.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & set\_schedlock\_helper() & infrun.c & \cxreffunc{set_schedlock_helper}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & do\_set\_schedlock\_mode() & utils.c & \cxreffunc{do_set_schedlock_mode}{utils.c}\\
\ & make\_cleanup\_set\_restore\_scheduler\_locking\_mode() & utils.c & \cxreffunc{make_cleanup_set_restore_scheduler_locking_mode}{utils.c}\\
Refs Var:\ & debug\_handcall\_setup & infrun.c & \cxrefvar{debug_handcall_setup}{infrun.c}\\
\ & schedlock\_off & infrun.c & \cxrefvar{schedlock_off}{infrun.c}\\
\ & schedlock\_on & infrun.c & \cxrefvar{schedlock_on}{infrun.c}\\
\ & schedlock\_step & infrun.c & \cxrefvar{schedlock_step}{infrun.c}\\
\ & scheduler\_mode & infrun.c & \cxrefvar{scheduler_mode}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function signal\_pass\_state()}
\label{func_signal_pass_state_infrun.c}

{\stt int signal\_pass\_state ( int signo )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Refs Var:\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function signal\_pass\_update()}
\label{func_signal_pass_update_infrun.c}

{\stt int signal\_pass\_update ( int signo, int state )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Refs Var:\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function signal\_print\_state()}
\label{func_signal_print_state_infrun.c}

{\stt int signal\_print\_state ( int signo )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Refs Var:\ & signal\_print & infrun.c & \cxrefvar{signal_print}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function signal\_print\_update()}
\label{func_signal_print_update_infrun.c}

{\stt int signal\_print\_update ( int signo, int state )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Refs Var:\ & signal\_print & infrun.c & \cxrefvar{signal_print}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function signal\_stop\_state()}
\label{func_signal_stop_state_infrun.c}

{\stt int signal\_stop\_state ( int signo )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Refs Var:\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function signal\_stop\_update()}
\label{func_signal_stop_update_infrun.c}

{\stt int signal\_stop\_update ( int signo, int state )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Refs Var:\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function start\_remote()}
\label{func_start_remote_infrun.c}

{\stt void start\_remote ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & init\_thread\_list() & thread.c & \cxreffunc{init_thread_list}{thread.c}\\
\ & init\_wait\_for\_inferior() & infrun.c & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & wait\_for\_inferior() & infrun.c & \cxreffunc{wait_for_inferior}{infrun.c}\\
Called by:\ & remote\_start\_remote\_dummy() & remote.c & \cxreffunc{remote_start_remote_dummy}{remote.c}\\
Refs Var:\ & stop\_soon & infrun.c & \cxrefvar{stop_soon}{infrun.c}\\
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function wait\_for\_inferior()}
\label{func_wait_for_inferior_infrun.c}

{\stt void wait\_for\_inferior ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_execution\_control\_state() & infrun.c & \cxreffunc{init_execution_control_state}{infrun.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & registers\_changed() & regcache.c & \cxreffunc{registers_changed}{regcache.c}\\
\ & \cxreftabiiispan{ deprecated\_target\_wait\_hook()} &\\
Called by:\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\ & start\_remote() & infrun.c & \cxreffunc{start_remote}{infrun.c}\\
Refs Func:\ & delete\_step\_resume\_breakpoint() & thread.c & \cxreffunc{delete_step_resume_breakpoint}{thread.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & debug\_infrun & infrun.c & \cxrefvar{debug_infrun}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_target\_wait\_hook & top.c & \cxrefvar{deprecated_target_wait_hook}{top.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & overlay\_cache\_invalid & symfile.c & \cxrefvar{overlay_cache_invalid}{symfile.c}\\
\ & previous\_inferior\_ptid & infrun.c & \cxrefvar{previous_inferior_ptid}{infrun.c}\\
\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function write\_inferior\_status\_register()}
\label{func_write_inferior_status_register_infrun.c}

{\stt void write\_inferior\_status\_register ( struct inferior\_status* inf\_status, int regno, long val )}

\smallskip
\begin{cxreftabiii}
Prototype:& inferior.h & \ & \cxreffile{inferior.h}\\
Calls:\ & regcache\_raw\_write() & regcache.c & \cxreffunc{regcache_raw_write}{regcache.c}\\
\ & register\_size() & regcache.c & \cxreffunc{register_size}{regcache.c}\\
\ & store\_signed\_integer() & findvar.c & \cxreffunc{store_signed_integer}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function adjust\_pc\_after\_break()}
\label{func_adjust_pc_after_break_infrun.c}

{\stt static void adjust\_pc\_after\_break ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Calls:\ & currently\_stepping() & infrun.c & \cxreffunc{currently_stepping}{infrun.c}\\
\ & gdbarch\_decr\_pc\_after\_break() & gdbarch.c & \cxreffunc{gdbarch_decr_pc_after_break}{gdbarch.c}\\
\ & gdbarch\_software\_single\_step\_p() & gdbarch.c & \cxreffunc{gdbarch_software_single_step_p}{gdbarch.c}\\
\ & read\_pc\_pid() & regcache.c & \cxreffunc{read_pc_pid}{regcache.c}\\
\cxreftabbreak{cxreftabiii}
\ & software\_breakpoint\_inserted\_here\_p() & breakpoint.c & \cxreffunc{software_breakpoint_inserted_here_p}{breakpoint.c}\\
\ & write\_pc\_pid() & regcache.c & \cxreffunc{write_pc_pid}{regcache.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & prev\_pc & infrun.c & \cxrefvar{prev_pc}{infrun.c}\\
\ & singlestep\_breakpoints\_inserted\_p & infrun.c & \cxrefvar{singlestep_breakpoints_inserted_p}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function allocate\_signal\_set()}
\label{func_allocate_signal_set_infrun.c}

{\stt static int allocate\_signal\_set ( unsigned char** stop, unsigned char** print, unsigned char** program )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
Refs Var:\ & signal\_print & infrun.c & \cxrefvar{signal_print}{infrun.c}\\
\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function build\_infrun()}
\label{func_build_infrun_infrun.c}

{\stt static void build\_infrun ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & regcache\_xmalloc() & regcache.c & \cxreffunc{regcache_xmalloc}{regcache.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_registers & infrun.c & \cxrefvar{stop_registers}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function context\_switch()}
\label{func_context_switch_infrun.c}

{\stt static void context\_switch ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Calls:\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & load\_infrun\_state() & thread.c & \cxreffunc{load_infrun_state}{thread.c}\\
\ & save\_infrun\_state() & thread.c & \cxreffunc{save_infrun_state}{thread.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & prev\_pc & infrun.c & \cxrefvar{prev_pc}{infrun.c}\\
\ & step\_frame\_id & infcmd.c & \cxrefvar{step_frame_id}{infcmd.c}\\
\ & step\_range\_end & infcmd.c & \cxrefvar{step_range_end}{infcmd.c}\\
\ & step\_range\_start & infcmd.c & \cxrefvar{step_range_start}{infcmd.c}\\
\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\ & stepping\_ranges & infcmd.c & \cxrefvar{stepping_ranges}{infcmd.c}\\
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function currently\_stepping()}
\label{func_currently_stepping_infrun.c}

{\stt static int currently\_stepping ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & bpstat\_should\_step() & breakpoint.c & \cxreffunc{bpstat_should_step}{breakpoint.c}\\
Called by:\ & adjust\_pc\_after\_break() & infrun.c & \cxreffunc{adjust_pc_after_break}{infrun.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & keep\_going() & infrun.c & \cxreffunc{keep_going}{infrun.c}\\
Refs Var:\ & step\_range\_end & infcmd.c & \cxrefvar{step_range_end}{infcmd.c}\\
\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function default\_skip\_permanent\_breakpoint()}
\label{func_default_skip_permanent_breakpoint_infrun.c}

{\stt static void default\_skip\_permanent\_breakpoint ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
Used in:\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_cleanup\_suppress\_hook\_stop()}
\label{func_do_cleanup_suppress_hook_stop_infrun.c}

{\stt static void do\_cleanup\_suppress\_hook\_stop ( void* arg )}

\smallskip
\begin{cxreftabiii}
Used in:\ & make\_cleanup\_suppress\_hook\_stop() & infrun.c & \cxreffunc{make_cleanup_suppress_hook_stop}{infrun.c}\\
Refs Var:\ & suppress\_hook\_stop\_p & infrun.c & \cxrefvar{suppress_hook_stop_p}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_restore\_inferior\_status\_cleanup()}
\label{func_do_restore_inferior_status_cleanup_infrun.c}

{\stt static void do\_restore\_inferior\_status\_cleanup ( void* sts )}

\smallskip
\begin{cxreftabiii}
Calls:\ & restore\_inferior\_status() & infrun.c & \cxreffunc{restore_inferior_status}{infrun.c}\\
Used in:\ & make\_cleanup\_restore\_inferior\_status() & infrun.c & \cxreffunc{make_cleanup_restore_inferior_status}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function follow\_exec()}
\label{func_follow_exec_infrun.c}

{\stt static void follow\_exec ( int pid, char* execd\_pathname )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_run\_target() & target/target.c & \cxreffunc{find_run_target}{target/target.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & push\_target() & target/target.c & \cxreffunc{push_target}{target/target.c}\\
\ & solib\_create\_inferior\_hook() & solib.c & \cxreffunc{solib_create_inferior_hook}{solib.c}\\
\ & symbol\_file\_add\_main() & symfile.c & \cxreffunc{symbol_file_add_main}{symfile.c}\\
\ & update\_breakpoints\_after\_exec() & breakpoint.c & \cxreffunc{update_breakpoints_after_exec}{breakpoint.c}\\
\ & \cxreftabiiispan{ exec\_file\_attach()} &\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & finishing\_inlined\_subroutine & infcmd.c & \cxrefvar{finishing_inlined_subroutine}{infcmd.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & may\_follow\_exec & infrun.c & \cxrefvar{may_follow_exec}{infrun.c}\\
\ & step\_range\_end & infcmd.c & \cxrefvar{step_range_end}{infcmd.c}\\
\ & step\_range\_start & infcmd.c & \cxrefvar{step_range_start}{infcmd.c}\\
\ & step\_resume\_breakpoint & infrun.c & \cxrefvar{step_resume_breakpoint}{infrun.c}\\
\ & stepping\_over\_inlined\_subroutine & infcmd.c & \cxrefvar{stepping_over_inlined_subroutine}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & stepping\_ranges & infcmd.c & \cxrefvar{stepping_ranges}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function follow\_fork()}
\label{func_follow_fork_infrun.c}

{\stt static int follow\_fork ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Called by:\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & follow\_fork\_mode\_child & infrun.c & \cxrefvar{follow_fork_mode_child}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & follow\_fork\_mode\_string & infrun.c & \cxrefvar{follow_fork_mode_string}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function handle\_command()}
\label{func_handle_command_infrun.c}

{\stt static void handle\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup\_freeargv() & utils.c & \cxreffunc{make_cleanup_freeargv}{utils.c}\\
\ & nomem() & utils.c & \cxreffunc{nomem}{utils.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & query() & utils.c & \cxreffunc{query}{utils.c}\\
\ & sig\_print\_header() & infrun.c & \cxreffunc{sig_print_header}{infrun.c}\\
\ & sig\_print\_info() & infrun.c & \cxreffunc{sig_print_info}{infrun.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), atoi(), buildargv(), error\_no\_arg(), isdigit(), strlen(), strncmp(), target\_signal\_from\_command(), target\_signal\_from\_name(), target\_signal\_to\_name()} &\\
Called by:\ & xdb\_handle\_command() & infrun.c & \cxreffunc{xdb_handle_command}{infrun.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & signal\_print & infrun.c & \cxrefvar{signal_print}{infrun.c}\\
\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function hook\_stop\_stub()}
\label{func_hook_stop_stub_infrun.c}

{\stt static int hook\_stop\_stub ( void* cmd )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & \cxreftabiiispan{ execute\_cmd\_pre\_hook()} &\\
Used in:\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
Refs Var:\ & suppress\_hook\_stop\_p & infrun.c & \cxrefvar{suppress_hook_stop_p}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function insert\_step\_resume\_breakpoint\_at\_frame()}
\label{func_insert_step_resume_breakpoint_at_frame_infrun.c}

{\stt static void insert\_step\_resume\_breakpoint\_at\_frame ( struct frame\_info* return\_frame )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & find\_pc\_overlay() & symfile.c & \cxreffunc{find_pc_overlay}{symfile.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & gdbarch\_addr\_bits\_remove() & gdbarch.c & \cxreffunc{gdbarch_addr_bits_remove}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_frame\_pc() & frame.c & \cxreffunc{get_frame_pc}{frame.c}\\
\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_sal() & infrun.c & \cxreffunc{insert_step_resume_breakpoint_at_sal}{infrun.c}\\
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & debug\_infrun & infrun.c & \cxrefvar{debug_infrun}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & step\_frame\_id & infcmd.c & \cxrefvar{step_frame_id}{infcmd.c}\\
\ & stepping\_over\_inlined\_subroutine & infcmd.c & \cxrefvar{stepping_over_inlined_subroutine}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function keep\_going()}
\label{func_keep_going_infrun.c}

{\stt static void keep\_going ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & currently\_stepping() & infrun.c & \cxreffunc{currently_stepping}{infrun.c}\\
\ & do\_hand\_call\_cleanups() & utils.c & \cxreffunc{do_hand_call_cleanups}{utils.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & prepare\_to\_wait() & infrun.c & \cxreffunc{prepare_to_wait}{infrun.c}\\
\ & read\_pc() & regcache.c & \cxreffunc{read_pc}{regcache.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\ & stop\_stepping() & infrun.c & \cxreffunc{stop_stepping}{infrun.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & step\_into\_function() & infrun.c & \cxreffunc{step_into_function}{infrun.c}\\
Refs Var:\ & breakpoints\_failed & infrun.c & \cxrefvar{breakpoints_failed}{infrun.c}\\
\ & breakpoints\_inserted & infrun.c & \cxrefvar{breakpoints_inserted}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & prev\_pc & infrun.c & \cxrefvar{prev_pc}{infrun.c}\\
\ & proceed\_from\_hand\_call & infrun.c & \cxrefvar{proceed_from_hand_call}{infrun.c}\\
\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\ & stop\_signal & infcmd.c & \cxrefvar{stop_signal}{infcmd.c}\\
\ & trap\_expected & infrun.c & \cxrefvar{trap_expected}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function prepare\_to\_proceed()}
\label{func_prepare_to_proceed_infrun.c}

{\stt static int prepare\_to\_proceed ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & breakpoint\_here\_p() & breakpoint.c & \cxreffunc{breakpoint_here_p}{breakpoint.c}\\
\ & flush\_cached\_frames() & frame.c & \cxreffunc{flush_cached_frames}{frame.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_last\_target\_status() & infrun.c & \cxreffunc{get_last_target_status}{infrun.c}\\
\ & inlined\_function\_call\_stack\_pc() & inlining.c & \cxreffunc{inlined_function_call_stack_pc}{inlining.c}\\
\ & inlined\_function\_update\_call\_stack() & inlining.c & \cxreffunc{inlined_function_update_call_stack}{inlining.c}\\
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\ & read\_pc() & regcache.c & \cxreffunc{read_pc}{regcache.c}\\
\ & read\_pc\_pid() & regcache.c & \cxreffunc{read_pc_pid}{regcache.c}\\
\ & registers\_changed() & regcache.c & \cxreffunc{registers_changed}{regcache.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & minus\_one\_ptid & infrun.c & \cxrefvar{minus_one_ptid}{infrun.c}\\
\ & proceed\_from\_hand\_call & infrun.c & \cxrefvar{proceed_from_hand_call}{infrun.c}\\
\ & stop\_pc & infcmd.c & \cxrefvar{stop_pc}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function prepare\_to\_wait()}
\label{func_prepare_to_wait_infrun.c}

{\stt static void prepare\_to\_wait ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\ & registers\_changed() & regcache.c & \cxreffunc{registers_changed}{regcache.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & keep\_going() & infrun.c & \cxreffunc{keep_going}{infrun.c}\\
Refs Var:\ & debug\_infrun & infrun.c & \cxrefvar{debug_infrun}{infrun.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & overlay\_cache\_invalid & symfile.c & \cxrefvar{overlay_cache_invalid}{symfile.c}\\
\end{cxreftabiii}


\subsubsection{Local Function print\_stop\_reason()}
\label{func_print_stop_reason_infrun.c}

{\stt static void print\_stop\_reason ( enum inferior\_stop\_reason stop\_reason, int stop\_info )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup\_ui\_out\_notify\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_notify_begin_end}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_field\_fmt() & ui-out.c & \cxreffunc{ui_out_field_fmt}{ui-out.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\ & ui\_out\_print\_annotation\_string() & ui-out.c & \cxreffunc{ui_out_print_annotation_string}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\ & \cxreftabiiispan{ annotate\_exited(), annotate\_signal(), annotate\_signal\_name(), annotate\_signal\_name\_end(), annotate\_signal\_string(), annotate\_signal\_string\_end(), annotate\_signalled(), async\_reason\_lookup(), target\_signal\_to\_name(), target\_signal\_to\_string()} &\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & step\_into\_function() & infrun.c & \cxreffunc{step_into_function}{infrun.c}\\
Refs Var:\ & finishing\_inlined\_subroutine & infcmd.c & \cxrefvar{finishing_inlined_subroutine}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\ & step\_multi & infcmd.c & \cxrefvar{step_multi}{infcmd.c}\\
\ & stop\_step & infcmd.c & \cxrefvar{stop_step}{infcmd.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function restore\_inferior\_ptid()}
\label{func_restore_inferior_ptid_infrun.c}

{\stt static void restore\_inferior\_ptid ( void* arg )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Used in:\ & save\_inferior\_ptid() & infrun.c & \cxreffunc{save_inferior_ptid}{infrun.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function restore\_selected\_frame()}
\label{func_restore_selected_frame_infrun.c}

{\stt static int restore\_selected\_frame ( void* args )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & restore\_inferior\_status() & infrun.c & \cxreffunc{restore_inferior_status}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function resume\_cleanups()}
\label{func_resume_cleanups_infrun.c}

{\stt static void resume\_cleanups ( void* ignore )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
Used in:\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_minimal\_signal\_handling()}
\label{func_set_minimal_signal_handling_infrun.c}

{\stt static void set\_minimal\_signal\_handling ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Called by:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
Refs Var:\ & full\_signal\_print & infrun.c & \cxrefvar{full_signal_print}{infrun.c}\\
\ & full\_signal\_program & infrun.c & \cxrefvar{full_signal_program}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & full\_signal\_stop & infrun.c & \cxrefvar{full_signal_stop}{infrun.c}\\
\ & minimal\_signal\_handling & infrun.c & \cxrefvar{minimal_signal_handling}{infrun.c}\\
\ & minimal\_signal\_print & infrun.c & \cxrefvar{minimal_signal_print}{infrun.c}\\
\ & minimal\_signal\_program & infrun.c & \cxrefvar{minimal_signal_program}{infrun.c}\\
\ & minimal\_signal\_stop & infrun.c & \cxrefvar{minimal_signal_stop}{infrun.c}\\
\ & signal\_print & infrun.c & \cxrefvar{signal_print}{infrun.c}\\
\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function set\_schedlock\_func()}
\label{func_set_schedlock_func_infrun.c}

{\stt static void set\_schedlock\_func ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & set\_schedlock\_helper() & infrun.c & \cxreffunc{set_schedlock_helper}{infrun.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_schedlock\_helper()}
\label{func_set_schedlock_helper_infrun.c}

{\stt static void set\_schedlock\_helper ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & scheduler\_run\_this\_ptid() & infrun.c & \cxreffunc{scheduler_run_this_ptid}{infrun.c}\\
Called by:\ & set\_schedlock\_func() & infrun.c & \cxreffunc{set_schedlock_func}{infrun.c}\\
\ & set\_scheduler\_locking\_mode() & infrun.c & \cxreffunc{set_scheduler_locking_mode}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & minus\_one\_ptid & infrun.c & \cxrefvar{minus_one_ptid}{infrun.c}\\
\ & schedlock\_off & infrun.c & \cxrefvar{schedlock_off}{infrun.c}\\
\ & schedlock\_on & infrun.c & \cxrefvar{schedlock_on}{infrun.c}\\
\ & scheduler\_mode & infrun.c & \cxrefvar{scheduler_mode}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_debug\_infrun()}
\label{func_show_debug_infrun_infrun.c}

{\stt static void show\_debug\_infrun ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_follow\_fork\_mode\_string()}
\label{func_show_follow_fork_mode_string_infrun.c}

{\stt static void show\_follow\_fork\_mode\_string ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_scheduler\_mode()}
\label{func_show_scheduler_mode_infrun.c}

{\stt static void show\_scheduler\_mode ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_step\_stop\_if\_no\_debug()}
\label{func_show_step_stop_if_no_debug_infrun.c}

{\stt static void show\_step\_stop\_if\_no\_debug ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_stop\_on\_solib\_events()}
\label{func_show_stop_on_solib_events_infrun.c}

{\stt static void show\_stop\_on\_solib\_events ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function sig\_print\_header()}
\label{func_sig_print_header_infrun.c}

{\stt static void sig\_print\_header ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
Called by:\ & handle\_command() & infrun.c & \cxreffunc{handle_command}{infrun.c}\\
\ & signals\_info() & infrun.c & \cxreffunc{signals_info}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function sig\_print\_info()}
\label{func_sig_print_info_infrun.c}

{\stt static void sig\_print\_info ( enum target\_signal oursig )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & \cxreftabiiispan{ strlen(), target\_signal\_to\_name(), target\_signal\_to\_string()} &\\
Called by:\ & handle\_command() & infrun.c & \cxreffunc{handle_command}{infrun.c}\\
\ & signals\_info() & infrun.c & \cxreffunc{signals_info}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & signal\_print & infrun.c & \cxrefvar{signal_print}{infrun.c}\\
\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function signals\_info()}
\label{func_signals_info_infrun.c}

{\stt static void signals\_info ( const char* signum\_exp, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & parse\_and\_eval\_long() & eval.c & \cxreffunc{parse_and_eval_long}{eval.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & quit() & utils.c & \cxreffunc{quit}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & sig\_print\_header() & infrun.c & \cxreffunc{sig_print_header}{infrun.c}\\
\ & sig\_print\_info() & infrun.c & \cxreffunc{sig_print_info}{infrun.c}\\
\ & \cxreftabiiispan{ target\_signal\_from\_command(), target\_signal\_from\_name()} &\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
Refs Var:\ & quit\_flag & utils.c & \cxrefvar{quit_flag}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Local Function step\_into\_function()}
\label{func_step_into_function_infrun.c}

{\stt static void step\_into\_function ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & find\_pc\_line() & symtab.c & \cxreffunc{find_pc_line}{symtab.c}\\
\ & find\_pc\_overlay() & symfile.c & \cxreffunc{find_pc_overlay}{symfile.c}\\
\ & find\_pc\_symtab() & symtab.c & \cxreffunc{find_pc_symtab}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_adjust\_breakpoint\_address() & gdbarch.c & \cxreffunc{gdbarch_adjust_breakpoint_address}{gdbarch.c}\\
\ & gdbarch\_adjust\_breakpoint\_address\_p() & gdbarch.c & \cxreffunc{gdbarch_adjust_breakpoint_address_p}{gdbarch.c}\\
\ & gdbarch\_skip\_prologue() & gdbarch.c & \cxreffunc{gdbarch_skip_prologue}{gdbarch.c}\\
\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_sal() & infrun.c & \cxreffunc{insert_step_resume_breakpoint_at_sal}{infrun.c}\\
\ & keep\_going() & infrun.c & \cxreffunc{keep_going}{infrun.c}\\
\ & print\_stop\_reason() & infrun.c & \cxreffunc{print_stop_reason}{infrun.c}\\
\ & skip\_language\_trampoline() & language.c & \cxreffunc{skip_language_trampoline}{language.c}\\
\cxreftabbreak{cxreftabiii}
\ & stop\_stepping() & infrun.c & \cxreffunc{stop_stepping}{infrun.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\ & step\_range\_end & infcmd.c & \cxrefvar{step_range_end}{infcmd.c}\\
\ & step\_range\_start & infcmd.c & \cxrefvar{step_range_start}{infcmd.c}\\
\ & stop\_pc & infcmd.c & \cxrefvar{stop_pc}{infcmd.c}\\
\ & stop\_step & infcmd.c & \cxrefvar{stop_step}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function stop\_stepping()}
\label{func_stop_stepping_infrun.c}

{\stt static void stop\_stepping ( struct execution\_control\_state* ecs )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & keep\_going() & infrun.c & \cxreffunc{keep_going}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & step\_into\_function() & infrun.c & \cxreffunc{step_into_function}{infrun.c}\\
Refs Var:\ & debug\_infrun & infrun.c & \cxrefvar{debug_infrun}{infrun.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function xdb\_handle\_command()}
\label{func_xdb_handle_command_infrun.c}

{\stt static void xdb\_handle\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& infrun.c & \ & \cxreffile{infrun.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & handle\_command() & infrun.c & \cxreffunc{handle_command}{infrun.c}\\
\ & make\_cleanup\_freeargv() & utils.c & \cxreffunc{make_cleanup_freeargv}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & nomem() & utils.c & \cxreffunc{nomem}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), buildargv(), strcmp(), strlen(), target\_signal\_from\_name()} &\\
Used in:\ & \_initialize\_infrun() & infrun.c & \cxreffunc{_initialize_infrun}{infrun.c}\\
Refs Var:\ & signal\_print & infrun.c & \cxrefvar{signal_print}{infrun.c}\\
\ & signal\_program & infrun.c & \cxrefvar{signal_program}{infrun.c}\\
\ & signal\_stop & infrun.c & \cxrefvar{signal_stop}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}

