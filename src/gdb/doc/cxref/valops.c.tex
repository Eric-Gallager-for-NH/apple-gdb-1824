% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF valops.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File valops.c}{File valops.c}
\section{File valops.c}
\label{file_valops.c}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.4in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.2in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inferior.h"} &\cxreffile{inferior.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.4in}{\stt \#include "gdb-events.h"} &\cxreffile{gdb-events.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcore.h"} &\cxreffile{gdbcore.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "target.h"} &\cxreffile{target.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/demangle.h"} &\cxreffile{../include/demangle.h}\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "block.h"} &\cxreffile{block.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "regcache.h"} &\cxreffile{regcache.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cp-abi.h"} &\cxreffile{cp-abi.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "exceptions.h"} &\cxreffile{exceptions.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\hspace*{0.2in}{\stt \#include <setjmp.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "dictionary.h"} &\cxreffile{dictionary.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbthread.h"} &\cxreffile{gdbthread.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb.h"} &\cxreffile{gdb.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <errno.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cp-support.h"} &\cxreffile{cp-support.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "observer.h"} &\cxreffile{observer.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "macosx/macosx-nat-infthread.h"} &\cxreffile{macosx/macosx-nat-infthread.h}\\
\hspace*{0.2in}{\stt \#include <mach/mach.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "macosx/macosx-nat-infthread.h"} &\cxreffile{macosx/macosx-nat-infthread.h}\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define STRING\_HASH\_TABLE\_SIZE 2039}


\subsection{Type definitions}


\subsubsection{Type enum oload\_classification}
\label{type_enum_oload_classification_valops.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum oload\_classification} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt STANDARD;} &\\
\hspace*{0.2in}{\stt NON\_STANDARD;} &\\
\hspace*{0.2in}{\stt INCOMPATIBLE;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct string\_in\_child}
\label{type_struct_string_in_child_valops.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct string\_in\_child} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* str;} &\\
\hspace*{0.2in}{\stt int len;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR addr;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt struct string\_in\_child* next;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct thread\_is\_safe\_args}
\label{type_struct_thread_is_safe_args_valops.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct thread\_is\_safe\_args} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct thread\_info* tp;} &\\
\hspace*{0.2in}{\stt regex\_t* unsafe\_functions;} &\\
\hspace*{0.2in}{\stt int npatterns;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int stack\_depth;} &\\
\hspace*{0.2in}{\stt int unsafe\_p;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable overload\_resolution}
\label{var_overload_resolution_valops.c}

{\stt int overload\_resolution}

\smallskip
\begin{cxreftabiii}
Visible in:\ & eval.c & \ & \cxreffile{eval.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & \_initialize\_valops() & valops.c & \cxreffunc{_initialize_valops}{valops.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\end{cxreftabiii}


\subsubsection{External Variables}

{\bf overload\_debug}
\label{var_overload_debug_valops.c}

{\stt extern int overload\_debug}

\smallskip
\begin{cxreftabiii}
Defined in:& gdbtypes.c & \ & \cxrefvar{overload_debug}{gdbtypes.c}\\
\end{cxreftabiii}

\medskip
{\bf msym\_text\_symbol\_type}
\label{var_msym_text_symbol_type_valops.c}

{\stt extern struct type* msym\_text\_symbol\_type}

\smallskip
\begin{cxreftabiii}
Defined in:& parse.c & \ & \cxrefvar{msym_text_symbol_type}{parse.c}\\
\end{cxreftabiii}

\medskip
{\bf msym\_data\_symbol\_type}
\label{var_msym_data_symbol_type_valops.c}

{\stt extern struct type* msym\_data\_symbol\_type}

\smallskip
\begin{cxreftabiii}
Defined in:& parse.c & \ & \cxrefvar{msym_data_symbol_type}{parse.c}\\
\end{cxreftabiii}

\medskip
{\bf msym\_unknown\_symbol\_type}
\label{var_msym_unknown_symbol_type_valops.c}

{\stt extern struct type* msym\_unknown\_symbol\_type}

\smallskip
\begin{cxreftabiii}
Defined in:& parse.c & \ & \cxrefvar{msym_unknown_symbol_type}{parse.c}\\
\end{cxreftabiii}

\medskip
{\bf symbol\_generation}
\label{var_symbol_generation_valops.c}

{\stt extern unsigned int symbol\_generation}

\smallskip
\begin{cxreftabiii}
Defined in:& breakpoint.c & \ & \cxrefvar{symbol_generation}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf string\_table}
\label{var_string_table_valops.c}

{\stt static struct string\_in\_child* string\_table[2039]}

\smallskip
\begin{cxreftabiii}
Used in:\ & allocate\_string\_in\_inferior() & \ & \cxreffunc{allocate_string_in_inferior}{valops.c}\\
\ & value\_clear\_inferior\_string\_pool() & \ & \cxreffunc{value_clear_inferior_string_pool}{valops.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_valops()}
\label{func__initialize_valops_valops.c}

{\stt void \_initialize\_valops ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & \cxreftabiiispan{ add\_setshow\_boolean\_cmd()} &\\
Refs Func:\ & show\_overload\_resolution() & valops.c & \cxreffunc{show_overload_resolution}{valops.c}\\
Refs Var:\ & overload\_resolution & valops.c & \cxrefvar{overload_resolution}{valops.c}\\
\ & \cxreftabiiispan{ setlist, showlist} &\\
\end{cxreftabiii}


\subsubsection{Global Function allocate\_space\_in\_inferior\_malloc()}
\label{func_allocate_space_in_inferior_malloc_valops.c}

{\stt CORE\_ADDR allocate\_space\_in\_inferior\_malloc ( int len )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & call\_function\_by\_hand() & infcall.c & \cxreffunc{call_function_by_hand}{infcall.c}\\
\ & create\_cached\_function() & value.c & \cxreffunc{create_cached_function}{value.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_name\_of\_malloc() & gdbarch.c & \cxreffunc{gdbarch_name_of_malloc}{gdbarch.c}\\
\ & lookup\_cached\_function() & value.c & \cxreffunc{lookup_cached_function}{value.c}\\
\ & make\_cleanup\_set\_restore\_unwind\_on\_signal() & infcall.c & \cxreffunc{make_cleanup_set_restore_unwind_on_signal}{infcall.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_logical\_not() & valarith.c & \cxreffunc{value_logical_not}{valarith.c}\\
Used in:\ & update\_current\_target() & target/target.c & \cxreffunc{update_current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & builtin\_type\_voidptrfuncptr & gdbtypes.c & \cxrefvar{builtin_type_voidptrfuncptr}{gdbtypes.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Global Function check\_field()}
\label{func_check_field_valops.c}

{\stt int check\_field ( struct value* arg1, const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_field\_in() & valops.c & \cxreffunc{check_field_in}{valops.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & lookup\_symbol\_aux() & symtab.c & \cxreffunc{lookup_symbol_aux}{symtab.c}\\
Refs Var:\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\end{cxreftabiii}


\subsubsection{Global Function check\_safe\_call()}
\label{func_check_safe_call_valops.c}

{\stt int check\_safe\_call ( regex\_t unsafe\_functions[], int npatterns, int stack\_depth, enum check\_which\_threads which\_threads )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & deprecated\_safe\_get\_selected\_frame() & frame.c & \cxreffunc{deprecated_safe_get_selected_frame}{frame.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & frame\_id\_eq() & frame.c & \cxreffunc{frame_id_eq}{frame.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & iterate\_over\_threads() & thread.c & \cxreffunc{iterate_over_threads}{thread.c}\\
\ & make\_cleanup\_restore\_current\_thread() & thread.c & \cxreffunc{make_cleanup_restore_current_thread}{thread.c}\\
\ & safe\_check\_is\_thread\_unsafe() & valops.c & \cxreffunc{safe_check_is_thread_unsafe}{valops.c}\\
\ & scheduler\_lock\_on\_p() & infrun.c & \cxreffunc{scheduler_lock_on_p}{infrun.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ macosx\_prune\_threads()} &\\
Refs Func:\ & safe\_check\_is\_thread\_unsafe() & valops.c & \cxreffunc{safe_check_is_thread_unsafe}{valops.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\end{cxreftabiii}


\subsubsection{Global Function destructor\_name\_p()}
\label{func_destructor_name_p_valops.c}

{\stt int destructor\_name\_p ( const char* name, const struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & type\_name\_no\_tag() & gdbtypes.c & \cxreffunc{type_name_no_tag}{gdbtypes.c}\\
\ & \cxreftabiiispan{ strchr(), strlen(), strncmp()} &\\
Called by:\ & c\_parse() & c-exp.c & \cxreffunc{c_parse}{c-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & check\_field\_in() & valops.c & \cxreffunc{check_field_in}{valops.c}\\
\ & collect\_methods() & linespec.c & \cxreffunc{collect_methods}{linespec.c}\\
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\ & value\_struct\_elt\_for\_reference() & valops.c & \cxreffunc{value_struct_elt_for_reference}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function find\_function\_in\_inferior()}
\label{func_find_function_in_inferior_valops.c}

{\stt struct value* find\_function\_in\_inferior ( const char* name, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & func\_sym\_is\_inlined\_function() & inlining.c & \cxreffunc{func_sym_is_inlined_function}{inlining.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_symbol\_all() & symtab.c & \cxreffunc{lookup_symbol_all}{symtab.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_of\_variable() & valops.c & \cxreffunc{value_of_variable}{valops.c}\\
Called by:\ & lookup\_cached\_function() & value.c & \cxreffunc{lookup_cached_function}{value.c}\\
\ & print\_object\_command() & objc-lang.c & \cxreffunc{print_object_command}{objc-lang.c}\\
\ & scm\_evaluate\_string() & scm-lang.c & \cxreffunc{scm_evaluate_string}{scm-lang.c}\\
\ & scm\_lookup\_name() & scm-lang.c & \cxreffunc{scm_lookup_name}{scm-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_nsstring() & objc-lang.c & \cxreffunc{value_nsstring}{objc-lang.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & msym\_text\_symbol\_type & parse.c & \cxrefvar{msym_text_symbol_type}{parse.c}\\
\end{cxreftabiii}


\subsubsection{Global Function find\_overload\_match()}
\label{func_find_overload_match_valops.c}

{\stt int find\_overload\_match ( struct type** arg\_types, int nargs, char* name, int method, int lax, struct value** objp, struct symbol* fsym, struct value** valp, struct symbol** symp, int* staticp )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & classify\_oload\_match() & valops.c & \cxreffunc{classify_oload_match}{valops.c}\\
\ & cp\_func\_name() & cp-support.c & \cxreffunc{cp_func_name}{cp-support.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_oload\_champ() & valops.c & \cxreffunc{find_oload_champ}{valops.c}\\
\ & find\_oload\_champ\_namespace() & valops.c & \cxreffunc{find_oload_champ_namespace}{valops.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & oload\_method\_static() & valops.c & \cxreffunc{oload_method_static}{valops.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_find\_oload\_method\_list() & valops.c & \cxreffunc{value_find_oload_method_list}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_virtual\_fn\_field() & cp-abi.c & \cxreffunc{value_virtual_fn_field}{cp-abi.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Global Function find\_rt\_vbase\_offset()}
\label{func_find_rt_vbase_offset_valops.c}

{\stt void find\_rt\_vbase\_offset ( struct type* type, struct type* basetype, const gdb\_byte* valaddr, int offset, int* boffset\_p, int* skip\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_rt\_vbase\_offset() & valops.c & \cxreffunc{find_rt_vbase_offset}{valops.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_at() & valops.c & \cxreffunc{value_at}{valops.c}\\
\ & virtual\_base\_index\_skip\_primaries() & gdbtypes.c & \cxreffunc{virtual_base_index_skip_primaries}{gdbtypes.c}\\
\ & virtual\_base\_list\_length\_skip\_primaries() & gdbtypes.c & \cxreffunc{virtual_base_list_length_skip_primaries}{gdbtypes.c}\\
Called by:\ & cp\_print\_value() & cp-valprint.c & \cxreffunc{cp_print_value}{cp-valprint.c}\\
\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & find\_rt\_vbase\_offset() & valops.c & \cxreffunc{find_rt_vbase_offset}{valops.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_addr()}
\label{func_value_addr_valops.c}

{\stt struct value* value\_addr ( struct value* arg1 )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & set\_value\_pointed\_to\_offset() & value.c & \cxreffunc{set_value_pointed_to_offset}{value.c}\\
\ & value\_change\_enclosing\_type() & value.c & \cxreffunc{value_change_enclosing_type}{value.c}\\
\ & value\_coerce\_function() & valops.c & \cxreffunc{value_coerce_function}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & c\_val\_print() & c-valprint.c & \cxreffunc{c_val_print}{c-valprint.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & evaluate\_subexp\_for\_address() & eval.c & \cxreffunc{evaluate_subexp_for_address}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & find\_function\_addr() & infcall.c & \cxreffunc{find_function_addr}{infcall.c}\\
\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & gnuv3\_virtual\_fn\_field() & gnu-v3-abi.c & \cxreffunc{gnuv3_virtual_fn_field}{gnu-v3-abi.c}\\
\ & java\_print\_value\_fields() & jv-valprint.c & \cxreffunc{java_print_value_fields}{jv-valprint.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & typecmp() & valops.c & \cxreffunc{typecmp}{valops.c}\\
\ & value\_arg\_coerce() & infcall.c & \cxreffunc{value_arg_coerce}{infcall.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\ & value\_x\_binop() & valarith.c & \cxreffunc{value_x_binop}{valarith.c}\\
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_aggregate\_elt()}
\label{func_value_aggregate_elt_valops.c}

{\stt struct value* value\_aggregate\_elt ( struct type* curtype, char* name, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & value\_namespace\_elt() & valops.c & \cxreffunc{value_namespace_elt}{valops.c}\\
\ & value\_struct\_elt\_for\_reference() & valops.c & \cxreffunc{value_struct_elt_for_reference}{valops.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_allocate\_space\_in\_inferior()}
\label{func_value_allocate_space_in_inferior_valops.c}

{\stt struct value* value\_allocate\_space\_in\_inferior ( int len )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
Called by:\ & scm\_evaluate\_string() & scm-lang.c & \cxreffunc{scm_evaluate_string}{scm-lang.c}\\
\ & scm\_lookup\_name() & scm-lang.c & \cxreffunc{scm_lookup_name}{scm-lang.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & builtin\_type\_void\_data\_ptr & gdbtypes.c & \cxrefvar{builtin_type_void_data_ptr}{gdbtypes.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_array()}
\label{func_value_array_valops.c}

{\stt struct value* value\_array ( int lowbound, int highbound, struct value** elemvec )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_space\_in\_inferior() & valops.c & \cxreffunc{allocate_space_in_inferior}{valops.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_contents\_all() & value.c & \cxreffunc{value_contents_all}{value.c}\\
\ & value\_contents\_all\_raw() & value.c & \cxreffunc{value_contents_all_raw}{value.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & write\_memory() & corefile.c & \cxreffunc{write_memory}{corefile.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_assign()}
\label{func_value_assign_valops.c}

{\stt struct value* value\_assign ( struct value* toval, struct value* fromval )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_frame\_id\_hack() & value.c & \cxreffunc{deprecated_value_frame_id_hack}{value.c}\\
\ & deprecated\_value\_internalvar\_hack() & value.c & \cxreffunc{deprecated_value_internalvar_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & deprecated\_value\_modifiable() & value.c & \cxreffunc{deprecated_value_modifiable}{value.c}\\
\ & deprecated\_value\_regnum\_hack() & value.c & \cxreffunc{deprecated_value_regnum_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & frame\_register\_read() & frame.c & \cxreffunc{frame_register_read}{frame.c}\\
\ & frame\_relative\_level() & frame.c & \cxreffunc{frame_relative_level}{frame.c}\\
\ & gdbarch\_convert\_register\_p() & gdbarch.c & \cxreffunc{gdbarch_convert_register_p}{gdbarch.c}\\
\ & gdbarch\_value\_to\_register() & gdbarch.c & \cxreffunc{gdbarch_value_to_register}{gdbarch.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & modify\_field() & value.c & \cxreffunc{modify_field}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & observer\_notify\_target\_changed() & observer.c & \cxreffunc{observer_notify_target_changed}{observer.c}\\
\ & put\_frame\_register() & frame.c & \cxreffunc{put_frame_register}{frame.c}\\
\ & read\_memory() & corefile.c & \cxreffunc{read_memory}{corefile.c}\\
\ & register\_size() & regcache.c & \cxreffunc{register_size}{regcache.c}\\
\ & reinit\_frame\_cache() & frame.c & \cxreffunc{reinit_frame_cache}{frame.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & set\_internalvar() & value.c & \cxreffunc{set_internalvar}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_internalvar\_component() & value.c & \cxreffunc{set_internalvar_component}{value.c}\\
\ & set\_value\_embedded\_offset() & value.c & \cxreffunc{set_value_embedded_offset}{value.c}\\
\ & set\_value\_pointed\_to\_offset() & value.c & \cxreffunc{set_value_pointed_to_offset}{value.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_bitpos() & value.c & \cxreffunc{value_bitpos}{value.c}\\
\ & value\_bitsize() & value.c & \cxreffunc{value_bitsize}{value.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_change\_enclosing\_type() & value.c & \cxreffunc{value_change_enclosing_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_pointed\_to\_offset() & value.c & \cxreffunc{value_pointed_to_offset}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & write\_memory() & corefile.c & \cxreffunc{write_memory}{corefile.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), deprecated\_memory\_changed\_hook(), deprecated\_register\_changed\_hook(), exceptions\_state\_mc\_action\_iter(), exceptions\_state\_mc\_action\_iter\_1(), exceptions\_state\_mc\_init(), sigsetjmp()} &\\
Called by:\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & gdb\_value\_assign() & wrapper.c & \cxreffunc{gdb_value_assign}{wrapper.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_memory\_changed\_hook & top.c & \cxrefvar{deprecated_memory_changed_hook}{top.c}\\
\ & deprecated\_register\_changed\_hook & top.c & \cxrefvar{deprecated_register_changed_hook}{top.c}\\
\ & deprecated\_selected\_frame & frame.c & \cxrefvar{deprecated_selected_frame}{frame.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_at()}
\label{func_value_at_valops.c}

{\stt struct value* value\_at ( struct type* type, CORE\_ADDR addr )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & read\_memory() & corefile.c & \cxreffunc{read_memory}{corefile.c}\\
\ & value\_contents\_all\_raw() & value.c & \cxreffunc{value_contents_all_raw}{value.c}\\
Called by:\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & c\_val\_print() & c-valprint.c & \cxreffunc{c_val_print}{c-valprint.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & f\_val\_print() & f-valprint.c & \cxreffunc{f_val_print}{f-valprint.c}\\
\ & find\_rt\_vbase\_offset() & valops.c & \cxreffunc{find_rt_vbase_offset}{valops.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & hpacc\_value\_rtti\_type() & hpacc-abi.c & \cxreffunc{hpacc_value_rtti_type}{hpacc-abi.c}\\
\ & hpacc\_virtual\_fn\_field() & hpacc-abi.c & \cxreffunc{hpacc_virtual_fn_field}{hpacc-abi.c}\\
\ & java\_class\_from\_object() & jv-lang.c & \cxreffunc{java_class_from_object}{jv-lang.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & pascal\_val\_print() & p-valprint.c & \cxreffunc{pascal_val_print}{p-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\ & value\_static\_field() & value.c & \cxreffunc{value_static_field}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_at\_lazy()}
\label{func_value_at_lazy_valops.c}

{\stt struct value* value\_at\_lazy ( struct type* type, CORE\_ADDR addr )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & set\_value\_lazy() & value.c & \cxreffunc{set_value_lazy}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & do\_examine() & printcmd.c & \cxreffunc{do_examine}{printcmd.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & gnuv3\_baseclass\_offset() & gnu-v3-abi.c & \cxreffunc{gnuv3_baseclass_offset}{gnu-v3-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\ & gnuv3\_virtual\_fn\_field() & gnu-v3-abi.c & \cxreffunc{gnuv3_virtual_fn_field}{gnu-v3-abi.c}\\
\ & print\_subexp\_standard() & expprint.c & \cxreffunc{print_subexp_standard}{expprint.c}\\
\ & value\_array() & valops.c & \cxreffunc{value_array}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_string() & valops.c & \cxreffunc{value_string}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function value\_bitstring()}
\label{func_value_bitstring_valops.c}

{\stt struct value* value\_bitstring ( char* ptr, int len )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & create\_set\_type() & gdbtypes.c & \cxreffunc{create_set_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_cast()}
\label{func_value_cast_valops.c}

{\stt struct value* value\_cast ( struct type* type, struct value* arg2 )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
Called by:\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_ptr\_subscript() & ada-lang.c & \cxreffunc{ada_value_ptr_subscript}{ada-lang.c}\\
\ & ada\_value\_slice() & ada-lang.c & \cxreffunc{ada_value_slice}{ada-lang.c}\\
\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\ & coerce\_enum() & value.c & \cxreffunc{coerce_enum}{value.c}\\
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\ & evaluate\_subexp\_for\_address() & eval.c & \cxreffunc{evaluate_subexp_for_address}{eval.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & evaluate\_subexp\_with\_coercion() & eval.c & \cxreffunc{evaluate_subexp_with_coercion}{eval.c}\\
\ & gdb\_value\_cast() & wrapper.c & \cxreffunc{gdb_value_cast}{wrapper.c}\\
\ & get\_closure\_implementation\_fn() & gdbtypes.c & \cxreffunc{get_closure_implementation_fn}{gdbtypes.c}\\
\ & gnuv2\_value\_rtti\_type() & gnu-v2-abi.c & \cxreffunc{gnuv2_value_rtti_type}{gnu-v2-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\ & gnuv3\_virtual\_fn\_field() & gnu-v3-abi.c & \cxreffunc{gnuv3_virtual_fn_field}{gnu-v3-abi.c}\\
\ & hpacc\_virtual\_fn\_field() & hpacc-abi.c & \cxreffunc{hpacc_virtual_fn_field}{hpacc-abi.c}\\
\ & print\_object\_command() & objc-lang.c & \cxreffunc{print_object_command}{objc-lang.c}\\
\ & return\_command() & stack.c & \cxreffunc{return_command}{stack.c}\\
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\ & value\_arg\_coerce() & infcall.c & \cxreffunc{value_arg_coerce}{infcall.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\ & value\_literal\_complex() & valops.c & \cxreffunc{value_literal_complex}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_clear\_inferior\_string\_pool()}
\label{func_value_clear_inferior_string_pool_valops.c}

{\stt void value\_clear\_inferior\_string\_pool ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & generic\_mourn\_inferior() & target/target.c & \cxreffunc{generic_mourn_inferior}{target/target.c}\\
Refs Var:\ & string\_table & valops.c & \cxrefvar{string_table}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function value\_coerce\_array()}
\label{func_value_coerce_array_valops.c}

{\stt struct value* value\_coerce\_array ( struct value* arg1 )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & lookup\_child\_selector\_nocache() & objc-lang.c & \cxreffunc{lookup_child_selector_nocache}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_objc\_class() & objc-lang.c & \cxreffunc{lookup_objc_class}{objc-lang.c}\\
\ & typecmp() & valops.c & \cxreffunc{typecmp}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_nsstring() & objc-lang.c & \cxreffunc{value_nsstring}{objc-lang.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_coerce\_function()}
\label{func_value_coerce_function_valops.c}

{\stt struct value* value\_coerce\_function ( struct value* arg1 )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_fetch\_lazy()}
\label{func_value_fetch_lazy_valops.c}

{\stt int value\_fetch\_lazy ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & read\_memory() & corefile.c & \cxreffunc{read_memory}{corefile.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_value\_lazy() & value.c & \cxreffunc{set_value_lazy}{value.c}\\
\ & value\_contents\_all\_raw() & value.c & \cxreffunc{value_contents_all_raw}{value.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
Called by:\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & cp\_print\_hpacc\_virtual\_table\_entries() & cp-valprint.c & \cxreffunc{cp_print_hpacc_virtual_table_entries}{cp-valprint.c}\\
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & gdb\_value\_fetch\_lazy() & wrapper.c & \cxreffunc{gdb_value_fetch_lazy}{wrapper.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & record\_latest\_value() & value.c & \cxreffunc{record_latest_value}{value.c}\\
\ & return\_command() & stack.c & \cxreffunc{return_command}{stack.c}\\
\ & set\_internalvar() & value.c & \cxreffunc{set_internalvar}{value.c}\\
\ & value\_contents\_all() & value.c & \cxreffunc{value_contents_all}{value.c}\\
\ & value\_contents\_writeable() & value.c & \cxreffunc{value_contents_writeable}{value.c}\\
\ & value\_of\_internalvar() & value.c & \cxreffunc{value_of_internalvar}{value.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function value\_find\_oload\_method\_list()}
\label{func_value_find_oload_method_list_valops.c}

{\stt struct fn\_field* value\_find\_oload\_method\_list ( struct value** argp, char* method, int offset, int* num\_fns, struct type** basetype, int* boffset )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_full\_object()}
\label{func_value_full_object_valops.c}

{\stt struct value* value\_full\_object ( struct value* volatile argp, struct type* rtype, int xfull, int xtop, int xusing\_enc )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_value\_embedded\_offset() & value.c & \cxreffunc{set_value_embedded_offset}{value.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_change\_enclosing\_type() & value.c & \cxreffunc{value_change_enclosing_type}{value.c}\\
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & value\_rtti\_type() & cp-abi.c & \cxreffunc{value_rtti_type}{cp-abi.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ exceptions\_state\_mc\_action\_iter(), exceptions\_state\_mc\_action\_iter\_1(), exceptions\_state\_mc\_init(), sigsetjmp()} &\\
Called by:\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
Refs Var:\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_ind()}
\label{func_value_ind_valops.c}

{\stt struct value* value\_ind ( struct value* arg1 )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & set\_value\_embedded\_offset() & value.c & \cxreffunc{set_value_embedded_offset}{value.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_change\_enclosing\_type() & value.c & \cxreffunc{value_change_enclosing_type}{value.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\ & value\_pointed\_to\_offset() & value.c & \cxreffunc{value_pointed_to_offset}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_ind() & ada-lang.c & \cxreffunc{ada_value_ind}{ada-lang.c}\\
\ & ada\_value\_ptr\_subscript() & ada-lang.c & \cxreffunc{ada_value_ptr_subscript}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & cp\_print\_hpacc\_virtual\_table\_entries() & cp-valprint.c & \cxreffunc{cp_print_hpacc_virtual_table_entries}{cp-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & gdb\_value\_ind() & wrapper.c & \cxreffunc{gdb_value_ind}{wrapper.c}\\
\ & get\_closure\_implementation\_fn() & gdbtypes.c & \cxreffunc{get_closure_implementation_fn}{gdbtypes.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & java\_link\_class\_type() & jv-lang.c & \cxreffunc{java_link_class_type}{jv-lang.c}\\
\ & scm\_lookup\_name() & scm-lang.c & \cxreffunc{scm_lookup_name}{scm-lang.c}\\
\ & type\_from\_class() & jv-lang.c & \cxreffunc{type_from_class}{jv-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_find\_oload\_method\_list() & valops.c & \cxreffunc{value_find_oload_method_list}{valops.c}\\
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\ & value\_rtti\_target\_type() & valops.c & \cxreffunc{value_rtti_target_type}{valops.c}\\
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & varobj\_value\_struct\_elt\_by\_index() & varobj.c & \cxreffunc{varobj_value_struct_elt_by_index}{varobj.c}\\
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_literal\_complex()}
\label{func_value_literal_complex_valops.c}

{\stt struct value* value\_literal\_complex ( struct value* arg1, struct value* arg2, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & cast\_into\_complex() & valops.c & \cxreffunc{cast_into_complex}{valops.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_of\_local()}
\label{func_value_of_local_valops.c}

{\stt struct value* value\_of\_local ( const char* name, int complain )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & dict\_empty() & dictionary.c & \cxreffunc{dict_empty}{dictionary.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_frame\_function() & blockframe.c & \cxreffunc{get_frame_function}{blockframe.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_block\_symbol() & symtab.c & \cxreffunc{lookup_block_symbol}{symtab.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & value\_of\_this() & valops.c & \cxreffunc{value_of_this}{valops.c}\\
Refs Var:\ & deprecated\_selected\_frame & frame.c & \cxrefvar{deprecated_selected_frame}{frame.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_of\_this()}
\label{func_value_of_this_valops.c}

{\stt struct value* value\_of\_this ( int complain )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_frame\_function() & blockframe.c & \cxreffunc{get_frame_function}{blockframe.c}\\
\ & get\_selected\_frame() & frame.c & \cxreffunc{get_selected_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_of\_local() & valops.c & \cxreffunc{value_of_local}{valops.c}\\
Called by:\ & pascal\_parse() & p-exp.c & \cxreffunc{pascal_parse}{p-exp.c}\\
Used in:\ & c-lang.c & \ & \cxreffile{c-lang.c}\\
\ & f-lang.c & \ & \cxreffile{f-lang.c}\\
\ & jv-lang.c & \ & \cxreffile{jv-lang.c}\\
\ & language.c & \ & \cxreffile{language.c}\\
\ & m2-lang.c & \ & \cxreffile{m2-lang.c}\\
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & p-lang.c & \ & \cxreffile{p-lang.c}\\
\ & scm-lang.c & \ & \cxreffile{scm-lang.c}\\
Refs Var:\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_of\_variable()}
\label{func_value_of_variable_valops.c}

{\stt struct value* value\_of\_variable ( struct symbol* var, struct block* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & block\_innermost\_frame() & blockframe.c & \cxreffunc{block_innermost_frame}{blockframe.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
\ & symbol\_read\_needs\_frame() & findvar.c & \cxreffunc{symbol_read_needs_frame}{findvar.c}\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & find\_function\_in\_inferior() & valops.c & \cxreffunc{find_function_in_inferior}{valops.c}\\
\ & get\_var\_value() & ada-lang.c & \cxreffunc{get_var_value}{ada-lang.c}\\
\ & scm\_lookup\_name() & scm-lang.c & \cxreffunc{scm_lookup_name}{scm-lang.c}\\
\ & value\_maybe\_namespace\_elt() & valops.c & \cxreffunc{value_maybe_namespace_elt}{valops.c}\\
Refs Var:\ & demangle & utils.c & \cxrefvar{demangle}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function value\_repeat()}
\label{func_value_repeat_valops.c}

{\stt struct value* value\_repeat ( struct value* arg1, int count )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_repeat\_value() & value.c & \cxreffunc{allocate_repeat_value}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & read\_memory() & corefile.c & \cxreffunc{read_memory}{corefile.c}\\
\ & value\_contents\_all\_raw() & value.c & \cxreffunc{value_contents_all_raw}{value.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_rtti\_target\_type()}
\label{func_value_rtti_target_type_valops.c}

{\stt struct type* value\_rtti\_target\_type ( struct value* v, int* full, int* top, int* using\_enc )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_rtti\_type() & cp-abi.c & \cxreffunc{value_rtti_type}{cp-abi.c}\\
Called by:\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & safe\_value\_rtti\_target\_type() & varobj.c & \cxreffunc{safe_value_rtti_target_type}{varobj.c}\\
\ & whatis\_exp() & typeprint.c & \cxreffunc{whatis_exp}{typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_slice()}
\label{func_value_slice_valops.c}

{\stt struct value* value\_slice ( struct value* array, int lowbound, int length )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & create\_set\_type() & gdbtypes.c & \cxreffunc{create_set_type}{gdbtypes.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_frame\_id\_hack() & value.c & \cxreffunc{deprecated_value_frame_id_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\ & get\_discrete\_bounds() & gdbtypes.c & \cxreffunc{get_discrete_bounds}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & set\_value\_lazy() & value.c & \cxreffunc{set_value_lazy}{value.c}\\
\ & set\_value\_offset() & value.c & \cxreffunc{set_value_offset}{value.c}\\
\ & value\_bit\_index() & valarith.c & \cxreffunc{value_bit_index}{valarith.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_contents\_writeable() & value.c & \cxreffunc{value_contents_writeable}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & ada\_value\_slice() & ada-lang.c & \cxreffunc{ada_value_slice}{ada-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_string()}
\label{func_value_string_valops.c}

{\stt struct value* value\_string ( const char* ptr, int len )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_string\_in\_inferior() & valops.c & \cxreffunc{allocate_string_in_inferior}{valops.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_string\_type() & gdbtypes.c & \cxreffunc{create_string_type}{gdbtypes.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & lookup\_child\_selector\_nocache() & objc-lang.c & \cxreffunc{lookup_child_selector_nocache}{objc-lang.c}\\
\ & lookup\_objc\_class() & objc-lang.c & \cxreffunc{lookup_objc_class}{objc-lang.c}\\
\ & value\_concat() & valarith.c & \cxreffunc{value_concat}{valarith.c}\\
\ & value\_nsstring() & objc-lang.c & \cxreffunc{value_nsstring}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_struct\_elt()}
\label{func_value_struct_elt_valops.c}

{\stt struct value* value\_struct\_elt ( struct value** argp, struct value** args, const char* name, int* static\_memfuncp, const char* err )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & destructor\_name\_p() & valops.c & \cxreffunc{destructor_name_p}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_destructor\_fn\_field() & gdbtypes.c & \cxreffunc{get_destructor_fn_field}{gdbtypes.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_data() & ada-lang.c & \cxreffunc{desc_data}{ada-lang.c}\\
\ & desc\_one\_bound() & ada-lang.c & \cxreffunc{desc_one_bound}{ada-lang.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & gdb\_value\_struct\_elt() & wrapper.c & \cxreffunc{gdb_value_struct_elt}{wrapper.c}\\
\ & get\_closure\_implementation\_fn() & gdbtypes.c & \cxreffunc{get_closure_implementation_fn}{gdbtypes.c}\\
\ & get\_java\_utf8\_name() & jv-lang.c & \cxreffunc{get_java_utf8_name}{jv-lang.c}\\
\ & java\_class\_from\_object() & jv-lang.c & \cxreffunc{java_class_from_object}{jv-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & java\_class\_is\_primitive() & jv-lang.c & \cxreffunc{java_class_is_primitive}{jv-lang.c}\\
\ & java\_link\_class\_type() & jv-lang.c & \cxreffunc{java_link_class_type}{jv-lang.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & type\_from\_class() & jv-lang.c & \cxreffunc{type_from_class}{jv-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\ & value\_x\_binop() & valarith.c & \cxreffunc{value_x_binop}{valarith.c}\\
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function value\_zero()}
\label{func_value_zero_valops.c}

{\stt struct value* value\_zero ( struct type* type, enum lval\_type lv )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & cast\_into\_complex() & valops.c & \cxreffunc{cast_into_complex}{valops.c}\\
\ & evaluate\_subexp\_for\_address() & eval.c & \cxreffunc{evaluate_subexp_for_address}{eval.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_x\_binop() & valarith.c & \cxreffunc{value_x_binop}{valarith.c}\\
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_get\_dynamic\_type() & varobj.c & \cxreffunc{varobj_get_dynamic_type}{varobj.c}\\
\ & varobj\_get\_type\_internal() & varobj.c & \cxreffunc{varobj_get_type_internal}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Local Function allocate\_space\_in\_inferior()}
\label{func_allocate_space_in_inferior_valops.c}

{\stt static CORE\_ADDR allocate\_space\_in\_inferior ( int len )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Called by:\ & allocate\_string\_in\_inferior() & valops.c & \cxreffunc{allocate_string_in_inferior}{valops.c}\\
\ & value\_array() & valops.c & \cxreffunc{value_array}{valops.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function allocate\_string\_in\_inferior()}
\label{func_allocate_string_in_inferior_valops.c}

{\stt static CORE\_ADDR allocate\_string\_in\_inferior ( const char* str, int len )}

\smallskip
\begin{cxreftabiii}
Calls:\ & allocate\_space\_in\_inferior() & valops.c & \cxreffunc{allocate_space_in_inferior}{valops.c}\\
\ & inferior\_string\_hash() & valops.c & \cxreffunc{inferior_string_hash}{valops.c}\\
\ & write\_memory() & corefile.c & \cxreffunc{write_memory}{corefile.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), memcmp()} &\\
Called by:\ & value\_string() & valops.c & \cxreffunc{value_string}{valops.c}\\
Refs Var:\ & string\_table & valops.c & \cxrefvar{string_table}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cast\_into\_complex()}
\label{func_cast_into_complex_valops.c}

{\stt static struct value* cast\_into\_complex ( struct type* type, struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_literal\_complex() & valops.c & \cxreffunc{value_literal_complex}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function check\_field\_in()}
\label{func_check_field_in_valops.c}

{\stt static int check\_field\_in ( struct type* type, const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & check\_field\_in() & valops.c & \cxreffunc{check_field_in}{valops.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & destructor\_name\_p() & valops.c & \cxreffunc{destructor_name_p}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_destructor\_fn\_field() & gdbtypes.c & \cxreffunc{get_destructor_fn_field}{gdbtypes.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & strcmp\_iw() & utils.c & \cxreffunc{strcmp_iw}{utils.c}\\
Called by:\ & check\_field() & valops.c & \cxreffunc{check_field}{valops.c}\\
\ & check\_field\_in() & valops.c & \cxreffunc{check_field_in}{valops.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function classify\_oload\_match()}
\label{func_classify_oload_match_valops.c}

{\stt static enum oload\_classification classify\_oload\_match ( struct badness\_vector* oload\_champ\_bv, int nargs, int static\_offset )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Called by:\ & find\_oload\_champ\_namespace\_loop() & valops.c & \cxreffunc{find_oload_champ_namespace_loop}{valops.c}\\
\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_check\_is\_thread\_unsafe()}
\label{func_do_check_is_thread_unsafe_valops.c}

{\stt static int do\_check\_is\_thread\_unsafe ( void* argptr )}

\smallskip
\begin{cxreftabiii}
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & find\_pc\_partial\_function() & blockframe.c & \cxreffunc{find_pc_partial_function}{blockframe.c}\\
\ & frame\_relative\_level() & frame.c & \cxreffunc{frame_relative_level}{frame.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_frame\_pc() & frame.c & \cxreffunc{get_frame_pc}{frame.c}\\
\ & get\_prev\_frame() & frame.c & \cxreffunc{get_prev_frame}{frame.c}\\
\ & make\_cleanup\_ui\_out\_tuple\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_tuple_begin_end}{ui-out.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & switch\_to\_thread() & thread.c & \cxreffunc{switch_to_thread}{thread.c}\\
\ & ui\_out\_field\_fmt() & ui-out.c & \cxreffunc{ui_out_field_fmt}{ui-out.c}\\
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ regexec(), strlen()} &\\
Used in:\ & safe\_check\_is\_thread\_unsafe() & valops.c & \cxreffunc{safe_check_is_thread_unsafe}{valops.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_method\_list()}
\label{func_find_method_list_valops.c}

{\stt static struct fn\_field* find\_method\_list ( struct value** argp, char* method, int offset, struct type* type, int* num\_fns, struct type** basetype, int* boffset )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & baseclass\_offset() & cp-abi.c & \cxreffunc{baseclass_offset}{cp-abi.c}\\
\ & check\_stub\_method\_group() & gdbtypes.c & \cxreffunc{check_stub_method_group}{gdbtypes.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & find\_rt\_vbase\_offset() & valops.c & \cxreffunc{find_rt_vbase_offset}{valops.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & strcmp\_iw() & utils.c & \cxreffunc{strcmp_iw}{utils.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_all() & value.c & \cxreffunc{value_contents_all}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
Called by:\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & value\_find\_oload\_method\_list() & valops.c & \cxreffunc{value_find_oload_method_list}{valops.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_oload\_champ()}
\label{func_find_oload_champ_valops.c}

{\stt static int find\_oload\_champ ( struct type** arg\_types, int nargs, int method, int num\_fns, struct fn\_field* fns\_ptr, struct symbol** oload\_syms, struct badness\_vector** oload\_champ\_bv )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & compare\_badness() & gdbtypes.c & \cxreffunc{compare_badness}{gdbtypes.c}\\
\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
\ & oload\_method\_static() & valops.c & \cxreffunc{oload_method_static}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & rank\_function() & gdbtypes.c & \cxreffunc{rank_function}{gdbtypes.c}\\
\ & symbol\_demangled\_name() & symtab.c & \cxreffunc{symbol_demangled_name}{symtab.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & find\_oload\_champ\_namespace\_loop() & valops.c & \cxreffunc{find_oload_champ_namespace_loop}{valops.c}\\
\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
Refs Var:\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\ & overload\_debug & gdbtypes.c & \cxrefvar{overload_debug}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function find\_oload\_champ\_namespace()}
\label{func_find_oload_champ_namespace_valops.c}

{\stt static int find\_oload\_champ\_namespace ( struct type** arg\_types, int nargs, const char* func\_name, const char* qualified\_name, struct symbol*** oload\_syms, struct badness\_vector** oload\_champ\_bv )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & find\_oload\_champ\_namespace\_loop() & valops.c & \cxreffunc{find_oload_champ_namespace_loop}{valops.c}\\
Called by:\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function find\_oload\_champ\_namespace\_loop()}
\label{func_find_oload_champ_namespace_loop_valops.c}

{\stt static int find\_oload\_champ\_namespace\_loop ( struct type** arg\_types, int nargs, const char* func\_name, const char* qualified\_name, int namespace\_len, struct symbol*** oload\_syms, struct badness\_vector** oload\_champ\_bv, int* oload\_champ )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & classify\_oload\_match() & valops.c & \cxreffunc{classify_oload_match}{valops.c}\\
\ & cp\_find\_first\_component() & cp-support.c & \cxreffunc{cp_find_first_component}{cp-support.c}\\
\ & discard\_cleanups() & utils.c & \cxreffunc{discard_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & find\_oload\_champ() & valops.c & \cxreffunc{find_oload_champ}{valops.c}\\
\ & find\_oload\_champ\_namespace\_loop() & valops.c & \cxreffunc{find_oload_champ_namespace_loop}{valops.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_symbol\_overload\_list() & cp-support.c & \cxreffunc{make_symbol_overload_list}{cp-support.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk()} &\\
Called by:\ & find\_oload\_champ\_namespace() & valops.c & \cxreffunc{find_oload_champ_namespace}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_oload\_champ\_namespace\_loop() & valops.c & \cxreffunc{find_oload_champ_namespace_loop}{valops.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Local Function inferior\_string\_hash()}
\label{func_inferior_string_hash_valops.c}

{\stt static unsigned int inferior\_string\_hash ( const char* string, int len )}

\smallskip
\begin{cxreftabiii}
Called by:\ & allocate\_string\_in\_inferior() & valops.c & \cxreffunc{allocate_string_in_inferior}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function oload\_method\_static()}
\label{func_oload_method_static_valops.c}

{\stt static int oload\_method\_static ( int method, struct fn\_field* fns\_ptr, int index )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Called by:\ & find\_oload\_champ() & valops.c & \cxreffunc{find_oload_champ}{valops.c}\\
\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function safe\_check\_is\_thread\_unsafe()}
\label{func_safe_check_is_thread_unsafe_valops.c}

{\stt static int safe\_check\_is\_thread\_unsafe ( struct thread\_info* tp, void* data )}

\smallskip
\begin{cxreftabiii}
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup\_restore\_current\_thread() & thread.c & \cxreffunc{make_cleanup_restore_current_thread}{thread.c}\\
\ & \cxreftabiiispan{ catch\_errors()} &\\
Called by:\ & check\_safe\_call() & valops.c & \cxreffunc{check_safe_call}{valops.c}\\
Used in:\ & check\_safe\_call() & valops.c & \cxreffunc{check_safe_call}{valops.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & do\_check\_is\_thread\_unsafe() & valops.c & \cxreffunc{do_check_is_thread_unsafe}{valops.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function search\_struct\_field()}
\label{func_search_struct_field_valops.c}

{\stt static struct value* search\_struct\_field ( const char* name, struct value* arg1, int offset, struct type* type, int looking\_for\_baseclass )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & baseclass\_offset() & cp-abi.c & \cxreffunc{baseclass_offset}{cp-abi.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_frame\_id\_hack() & value.c & \cxreffunc{deprecated_value_frame_id_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & set\_value\_lazy() & value.c & \cxreffunc{set_value_lazy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_value\_offset() & value.c & \cxreffunc{set_value_offset}{value.c}\\
\ & strcmp\_iw() & utils.c & \cxreffunc{strcmp_iw}{utils.c}\\
\ & target\_read\_memory() & target/target.c & \cxreffunc{target_read_memory}{target/target.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_static\_field() & value.c & \cxreffunc{value_static_field}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function search\_struct\_method()}
\label{func_search_struct_method_valops.c}

{\stt static struct value* search\_struct\_method ( const char* name, struct value** arg1p, struct value** args, int offset, int* static\_memfuncp, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & baseclass\_offset() & cp-abi.c & \cxreffunc{baseclass_offset}{cp-abi.c}\\
\ & check\_stub\_method\_group() & gdbtypes.c & \cxreffunc{check_stub_method_group}{gdbtypes.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_rt\_vbase\_offset() & valops.c & \cxreffunc{find_rt_vbase_offset}{valops.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\ & strcmp\_iw() & utils.c & \cxreffunc{strcmp_iw}{utils.c}\\
\ & target\_read\_memory() & target/target.c & \cxreffunc{target_read_memory}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & typecmp() & valops.c & \cxreffunc{typecmp}{valops.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_all() & value.c & \cxreffunc{value_contents_all}{value.c}\\
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_virtual\_fn\_field() & cp-abi.c & \cxreffunc{value_virtual_fn_field}{cp-abi.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), cplus\_demangle\_opname(), strncmp()} &\\
Called by:\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_overload\_resolution()}
\label{func_show_overload_resolution_valops.c}

{\stt static void show\_overload\_resolution ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_valops() & valops.c & \cxreffunc{_initialize_valops}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function typecmp()}
\label{func_typecmp_valops.c}

{\stt static int typecmp ( int staticp, int varargs, int nargs, struct field t1[], struct value* t2[] )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function value\_cast\_1()}
\label{func_value_cast_1_valops.c}

{\stt static struct value* value\_cast\_1 ( struct type* type, struct value* arg2 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & cast\_into\_complex() & valops.c & \cxreffunc{cast_into_complex}{valops.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & extract\_unsigned\_integer() & findvar.c & \cxreffunc{extract_unsigned_integer}{findvar.c}\\
\ & gdbarch\_addr\_bit() & gdbarch.c & \cxreffunc{gdbarch_addr_bit}{gdbarch.c}\\
\ & get\_discrete\_bounds() & gdbtypes.c & \cxreffunc{get_discrete_bounds}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & set\_value\_pointed\_to\_offset() & value.c & \cxreffunc{set_value_pointed_to_offset}{value.c}\\
\ & type\_name\_no\_tag() & gdbtypes.c & \cxreffunc{type_name_no_tag}{gdbtypes.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_as\_double() & value.c & \cxreffunc{value_as_double}{value.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_change\_enclosing\_type() & value.c & \cxreffunc{value_change_enclosing_type}{value.c}\\
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\ & value\_coerce\_function() & valops.c & \cxreffunc{value_coerce_function}{valops.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\ & value\_from\_double() & value.c & \cxreffunc{value_from_double}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_logical\_not() & valarith.c & \cxreffunc{value_logical_not}{valarith.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & builtin\_type\_void & gdbtypes.c & \cxrefvar{builtin_type_void}{gdbtypes.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\ & deprecated\_hp\_som\_som\_object\_present & symtab.c & \cxrefvar{deprecated_hp_som_som_object_present}{symtab.c}\\
\end{cxreftabiii}


\subsubsection{Local Function value\_maybe\_namespace\_elt()}
\label{func_value_maybe_namespace_elt_valops.c}

{\stt static struct value* value\_maybe\_namespace\_elt ( const struct type* curtype, char* name, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & cp\_lookup\_symbol\_namespace() & cp-namespace.c & \cxreffunc{cp_lookup_symbol_namespace}{cp-namespace.c}\\
\ & get\_selected\_block() & stack.c & \cxreffunc{get_selected_block}{stack.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_of\_variable() & valops.c & \cxreffunc{value_of_variable}{valops.c}\\
Called by:\ & value\_namespace\_elt() & valops.c & \cxreffunc{value_namespace_elt}{valops.c}\\
\ & value\_struct\_elt\_for\_reference() & valops.c & \cxreffunc{value_struct_elt_for_reference}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Local Function value\_namespace\_elt()}
\label{func_value_namespace_elt_valops.c}

{\stt static struct value* value\_namespace\_elt ( const struct type* curtype, char* name, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & value\_maybe\_namespace\_elt() & valops.c & \cxreffunc{value_maybe_namespace_elt}{valops.c}\\
Called by:\ & value\_aggregate\_elt() & valops.c & \cxreffunc{value_aggregate_elt}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function value\_struct\_elt\_for\_reference()}
\label{func_value_struct_elt_for_reference_valops.c}

{\stt static struct value* value\_struct\_elt\_for\_reference ( struct type* domain, int offset, struct type* curtype, char* name, struct type* intype, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& valops.c & \ & \cxreffile{valops.c}\\
Calls:\ & check\_stub\_method\_group() & gdbtypes.c & \cxreffunc{check_stub_method_group}{gdbtypes.c}\\
\ & destructor\_name\_p() & valops.c & \cxreffunc{destructor_name_p}{valops.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_member\_type() & gdbtypes.c & \cxreffunc{lookup_member_type}{gdbtypes.c}\\
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\ & lookup\_symbol() & symtab.c & \cxreffunc{lookup_symbol}{symtab.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_maybe\_namespace\_elt() & valops.c & \cxreffunc{value_maybe_namespace_elt}{valops.c}\\
\ & value\_static\_field() & value.c & \cxreffunc{value_static_field}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_struct\_elt\_for\_reference() & valops.c & \cxreffunc{value_struct_elt_for_reference}{valops.c}\\
\ & \cxreftabiiispan{ cplus\_demangle\_opname(), strcmp(), strncmp()} &\\
Called by:\ & value\_aggregate\_elt() & valops.c & \cxreffunc{value_aggregate_elt}{valops.c}\\
\ & value\_struct\_elt\_for\_reference() & valops.c & \cxreffunc{value_struct_elt_for_reference}{valops.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}

