% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF remote.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File remote.c}{File remote.c}
\section{File remote.c}
\label{file_remote.c}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <ctype.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <fcntl.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inferior.h"} &\cxreffile{inferior.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.8in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{1.0in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{1.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include <regex.h>} &\\
\hspace*{0.8in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.8in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.8in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{1.0in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "gdb-events.h"} &\cxreffile{gdb-events.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\hspace*{0.4in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "exceptions.h"} &\cxreffile{exceptions.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\hspace*{0.2in}{\stt \#include <setjmp.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "target.h"} &\cxreffile{target.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <uuid/uuid.h>} &\\
\hspace*{0.2in}{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/obstack.h"} &\cxreffile{../include/obstack.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb-stabs.h"} &\cxreffile{gdb-stabs.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbthread.h"} &\cxreffile{gdbthread.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "remote.h"} &\cxreffile{remote.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "regcache.h"} &\cxreffile{regcache.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "value.h"} &\cxreffile{value.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "observer.h"} &\cxreffile{observer.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "solib.h"} &\cxreffile{solib.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <ctype.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <sys/time.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "event-loop.h"} &\cxreffile{event-loop.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "event-top.h"} &\cxreffile{event-top.h}\\
\hspace*{0.2in}{\stt \#include <signal.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inf-loop.h"} &\cxreffile{inf-loop.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <signal.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "serial.h"} &\cxreffile{serial.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcore.h"} &\cxreffile{gdbcore.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "remote-fileio.h"} &\cxreffile{remote-fileio.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objc-lang.h"} &\cxreffile{objc-lang.h}\\
\hspace*{0.2in}{\stt \#include <Availability.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "macosx/macosx-nat-dyld.h"} &\cxreffile{macosx/macosx-nat-dyld.h}\\
\hspace*{0.2in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "macosx/macosx-nat-mutils.h"} &\cxreffile{macosx/macosx-nat-mutils.h}\\
\hspace*{0.4in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.4in}{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.4in}{\stt \#include "inferior.h"} &\cxreffile{inferior.h}\\
\hspace*{0.4in}{\stt \#include "macosx/macosx-nat-utils.h"} &\cxreffile{macosx/macosx-nat-utils.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.4in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.2in}{\stt \#include "macosx/macosx-nat-threads.h"} &\cxreffile{macosx/macosx-nat-threads.h}\\
\hspace*{0.4in}{\stt \#include <pthread.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <mach/machine.h>} &\\
\hspace*{0.2in}{\stt \#include <mach-o/loader.h>} &\\
\hspace*{0.2in}{\stt \#include "macosx/macosx-nat-dyld-info.h"} &\cxreffile{macosx/macosx-nat-dyld-info.h}\\
\hspace*{0.4in}{\stt \#include <mach/machine.h>} &\\
\hspace*{0.4in}{\stt \#include <mach-o/loader.h>} &\\
\hspace*{0.2in}{\stt \#include "macosx/macosx-nat-dyld-path.h"} &\cxreffile{macosx/macosx-nat-dyld-path.h}\\
\hspace*{0.4in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "macosx/macosx-nat-dyld-process.h"} &\cxreffile{macosx/macosx-nat-dyld-process.h}\\
\hspace*{0.2in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <execinfo.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <libgen.h>} &\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define PROTOCOL\_LOG\_BUFSIZE 3072}

\medskip
{\stt \#define DEFAULT\_MAX\_REMOTE\_PACKET\_SIZE 2000}

\medskip
{\stt \#define MAX\_REMOTE\_PACKET\_SIZE 16384}

\medskip
{\stt \#define MIN\_REMOTE\_PACKET\_SIZE 20}

\medskip
{\stt \#define MAGIC\_NULL\_PID 42000}

\medskip
{\stt \#define OPAQUETHREADBYTES 8}

\medskip
{\stt \#define TAG\_THREADID 1}

\medskip
{\stt \#define TAG\_EXISTS 2}

\medskip
{\stt \#define TAG\_DISPLAY 4}

\medskip
{\stt \#define TAG\_THREADNAME 8}

\medskip
{\stt \#define TAG\_MOREDISPLAY 16}

\medskip
{\stt \#define BUF\_THREAD\_ID\_SIZE}

\medskip
{\stt \#define TAG\_THREADID 1}

\medskip
{\stt \#define TAG\_EXISTS 2}

\medskip
{\stt \#define TAG\_DISPLAY 4}

\medskip
{\stt \#define TAG\_THREADNAME 8}

\medskip
{\stt \#define TAG\_MOREDISPLAY 16}

\medskip
{\stt \#define MAXTHREADLISTRESULTS 32}

\medskip
{\stt \#define CRAZY\_MAX\_THREADS 1000}

\medskip
{\stt \#define MAX\_TRIES 3}

\medskip
{\stt \#define INT\_PRINT\_MAX 20}


\subsection{Type definitions}


\subsubsection{Type struct packet\_reg}
\label{type_struct_packet_reg_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct packet\_reg} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt long offset;} &\\
\hspace*{0.2in}{\stt long regnum;} &\\
\hspace*{0.2in}{\stt long pnum;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int in\_g\_packet;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct remote\_state}
\label{type_struct_remote_state_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct remote\_state} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt size\_t sizeof\_g\_packet;} &\\
\hspace*{0.2in}{\stt struct packet\_reg* regs;} &\\
\hspace*{0.2in}{\stt size\_t actual\_register\_packet\_size;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt size\_t remote\_packet\_size;} &\\
\hspace*{0.2in}{\stt int has\_target;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum pkt\_direction}
\label{type_enum_pkt_direction_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum pkt\_direction} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt sent\_from\_gdb;} &\\
\hspace*{0.2in}{\stt received\_by\_gdb;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct protocol\_log\_entry}
\label{type_struct_protocol_log_entry_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct protocol\_log\_entry} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum pkt\_direction direction;} &\\
\hspace*{0.2in}{\stt struct timeval tv;} &\\
\hspace*{0.2in}{\stt char mi\_token[16];} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt char packet[3072];} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct protocol\_log}
\label{type_struct_protocol_log_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct protocol\_log} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt int head;} &\\
\hspace*{0.2in}{\stt int max\_ent;} &\\
\hspace*{0.2in}{\stt struct protocol\_log\_entry* ents;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct memory\_packet\_config}
\label{type_struct_memory_packet_config_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct memory\_packet\_config} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt const char* name;} &\\
\hspace*{0.2in}{\stt size\_t size;} &\\
\hspace*{0.2in}{\stt int fixed\_p;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum packet\_support}
\label{type_enum_packet_support_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum packet\_support} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt PACKET\_SUPPORT\_UNKNOWN;} &\\
\hspace*{0.2in}{\stt PACKET\_ENABLE;} &\\
\hspace*{0.2in}{\stt PACKET\_DISABLE;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct packet\_config}
\label{type_struct_packet_config_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct packet\_config} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt const char* name;} &\\
\hspace*{0.2in}{\stt const char* title;} &\\
\hspace*{0.2in}{\stt enum auto\_boolean detect;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt enum packet\_support support;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum packet\_result}
\label{type_enum_packet_result_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum packet\_result} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt PACKET\_ERROR;} &\\
\hspace*{0.2in}{\stt PACKET\_OK;} &\\
\hspace*{0.2in}{\stt PACKET\_UNKNOWN;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum Z\_packet\_type}
\label{type_enum_Z_packet_type_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum Z\_packet\_type} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt Z\_PACKET\_SOFTWARE\_BP;} &\\
\hspace*{0.2in}{\stt Z\_PACKET\_HARDWARE\_BP;} &\\
\hspace*{0.2in}{\stt Z\_PACKET\_WRITE\_WP;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt Z\_PACKET\_READ\_WP;} &\\
\hspace*{0.2in}{\stt Z\_PACKET\_ACCESS\_WP;} &\\
\hspace*{0.2in}{\stt NR\_Z\_PACKET\_TYPES;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef threadref}
\label{type_threadref_remote.c}

{\stt typedef unsigned char threadref[8]}


\subsubsection{Typedef gdb\_threadref}
\label{type_gdb_threadref_remote.c}

{\stt typedef int gdb\_threadref}


\subsubsection{Type struct gdb\_ext\_thread\_info}
\label{type_struct_gdb_ext_thread_info_remote.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct gdb\_ext\_thread\_info} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt threadref threadid;} &\\
\hspace*{0.2in}{\stt int active;} &\\
\hspace*{0.2in}{\stt char display[256];} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt char shortname[32];} &\\
\hspace*{0.2in}{\stt char more\_display[256];} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef rmt\_thread\_action}
\label{type_rmt_thread_action_remote.c}

{\stt typedef int (*rmt\_thread\_action)(threadref* ref,void* context)}


\subsection{Variables}


\subsubsection{Variable deprecated\_target\_resume\_hook}
\label{var_deprecated_target_resume_hook_remote.c}

{\stt void (*deprecated\_target\_resume\_hook)(void)}

\smallskip
\begin{cxreftabiii}
Visible in:\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & remote-fileio.c & \ & \cxreffile{remote-fileio.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
Used in:\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable deprecated\_target\_wait\_loop\_hook}
\label{var_deprecated_target_wait_loop_hook_remote.c}

{\stt void (*deprecated\_target\_wait\_loop\_hook)(void)}

\smallskip
\begin{cxreftabiii}
Visible in:\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & remote-fileio.c & \ & \cxreffile{remote-fileio.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
Used in:\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable current\_remote\_stats}
\label{var_current_remote_stats_remote.c}

{\stt struct remote\_stats* current\_remote\_stats}

\smallskip
\begin{cxreftabiii}
Visible in:\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & remote-fileio.c & \ & \cxreffile{remote-fileio.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
Used in:\ & add\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_pkt_to_protocol_log}{remote.c}\\
\ & end\_remote\_timer() & remote.c & \cxreffunc{end_remote_timer}{remote.c}\\
\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & remote\_stop() & remote.c & \cxreffunc{remote_stop}{remote.c}\\
\ & start\_remote\_timer() & remote.c & \cxreffunc{start_remote_timer}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable total\_packets\_sent}
\label{var_total_packets_sent_remote.c}

{\stt uint64\_t total\_packets\_sent}

\smallskip
\begin{cxreftabiii}
Visible in:\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & remote-fileio.c & \ & \cxreffile{remote-fileio.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
Used in:\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable total\_packets\_received}
\label{var_total_packets_received_remote.c}

{\stt uint64\_t total\_packets\_received}

\smallskip
\begin{cxreftabiii}
Visible in:\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & remote-fileio.c & \ & \cxreffile{remote-fileio.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
Used in:\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable remote\_debugflags}
\label{var_remote_debugflags_remote.c}

{\stt char* remote\_debugflags}

\smallskip
\begin{cxreftabiii}
Visible in:\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & set\_remote\_debugflags\_command() & remote.c & \cxreffunc{set_remote_debugflags_command}{remote.c}\\
\ & show\_remote\_debugflags\_command() & remote.c & \cxreffunc{show_remote_debugflags_command}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable protocol\_log}
\label{var_protocol_log_remote.c}

{\stt struct protocol\_log protocol\_log}

\smallskip
\begin{cxreftabiii}
Visible in:\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & add\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_pkt_to_protocol_log}{remote.c}\\
\ & dump\_protocol\_log() & remote.c & \cxreffunc{dump_protocol_log}{remote.c}\\
\ & initialize\_protocol\_log() & remote.c & \cxreffunc{initialize_protocol_log}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable no\_ack\_mode}
\label{var_no_ack_mode_remote.c}

{\stt int no\_ack\_mode}

\smallskip
\begin{cxreftabiii}
Visible in:\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & read\_frame() & remote.c & \cxreffunc{read_frame}{remote.c}\\
\ & show\_no\_ack\_mode\_cmd() & remote.c & \cxreffunc{show_no_ack_mode_cmd}{remote.c}\\
\ & start\_no\_ack\_mode() & remote.c & \cxreffunc{start_no_ack_mode}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable user\_requested\_no\_ack\_mode}
\label{var_user_requested_no_ack_mode_remote.c}

{\stt enum auto\_boolean user\_requested\_no\_ack\_mode}

\smallskip
\begin{cxreftabiii}
Visible in:\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & set\_no\_ack\_mode\_cmd() & remote.c & \cxreffunc{set_no_ack_mode_cmd}{remote.c}\\
\ & show\_no\_ack\_mode\_cmd() & remote.c & \cxreffunc{show_no_ack_mode_cmd}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable remote\_ops}
\label{var_remote_ops_remote.c}

{\stt struct target\_ops remote\_ops}

\smallskip
\begin{cxreftabiii}
Visible in:\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_extended\_remote\_ops() & remote.c & \cxreffunc{init_extended_remote_ops}{remote.c}\\
\ & init\_remote\_macosx\_ops() & remote.c & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\ & remote\_mourn() & remote.c & \cxreffunc{remote_mourn}{remote.c}\\
\ & remote\_open() & remote.c & \cxreffunc{remote_open}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable kill\_kludge}
\label{var_kill_kludge_remote.c}

{\stt int kill\_kludge}

\smallskip
\begin{cxreftabiii}
Visible in:\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & remote\_async\_kill() & remote.c & \cxreffunc{remote_async_kill}{remote.c}\\
\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_kill() & remote.c & \cxreffunc{remote_kill}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable remote\_hw\_watchpoint\_limit}
\label{var_remote_hw_watchpoint_limit_remote.c}

{\stt int remote\_hw\_watchpoint\_limit}

\smallskip
\begin{cxreftabiii}
Visible in:\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
\ & remote\_check\_watch\_resources() & remote.c & \cxreffunc{remote_check_watch_resources}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Variable remote\_hw\_breakpoint\_limit}
\label{var_remote_hw_breakpoint_limit_remote.c}

{\stt int remote\_hw\_breakpoint\_limit}

\smallskip
\begin{cxreftabiii}
Visible in:\ & remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
\ & remote\_check\_watch\_resources() & remote.c & \cxreffunc{remote_check_watch_resources}{remote.c}\\
\end{cxreftabiii}


\subsubsection{External Variables}

{\bf exec\_bfd}
\label{var_exec_bfd_remote.c}

{\stt extern bfd* exec\_bfd}

\medskip
{\bf stepped\_after\_stopped\_by\_watchpoint}
\label{var_stepped_after_stopped_by_watchpoint_remote.c}

{\stt extern int stepped\_after\_stopped\_by\_watchpoint}

\smallskip
\begin{cxreftabiii}
Defined in:& infrun.c & \ & \cxrefvar{stepped_after_stopped_by_watchpoint}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf remote\_gdbarch\_data\_handle}
\label{var_remote_gdbarch_data_handle_remote.c}

{\stt static struct gdbarch\_data* remote\_gdbarch\_data\_handle}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & get\_remote\_state() & \ & \cxreffunc{get_remote_state}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf g\_max\_remote\_packet\_size}
\label{var_g_max_remote_packet_size_remote.c}

{\stt static long g\_max\_remote\_packet\_size}

\smallskip
\begin{cxreftabiii}
Used in:\ & init\_remote\_state() & \ & \cxreffunc{init_remote_state}{remote.c}\\
\ & set\_max\_remote\_packet\_size() & \ & \cxreffunc{set_max_remote_packet_size}{remote.c}\\
\ & show\_max\_remote\_packet\_size() & \ & \cxreffunc{show_max_remote_packet_size}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_watch\_data\_address}
\label{var_remote_watch_data_address_remote.c}

{\stt static CORE\_ADDR remote\_watch\_data\_address}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async\_wait() & \ & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_stopped\_data\_address() & \ & \cxreffunc{remote_stopped_data_address}{remote.c}\\
\ & remote\_wait() & \ & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_stopped\_by\_watchpoint\_p}
\label{var_remote_stopped_by_watchpoint_p_remote.c}

{\stt static int remote\_stopped\_by\_watchpoint\_p}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async\_wait() & \ & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_stopped\_by\_watchpoint() & \ & \cxreffunc{remote_stopped_by_watchpoint}{remote.c}\\
\ & remote\_wait() & \ & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf extended\_remote\_ops}
\label{var_extended_remote_ops_remote.c}

{\stt static struct target\_ops extended\_remote\_ops}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & extended\_remote\_open() & \ & \cxreffunc{extended_remote_open}{remote.c}\\
\ & init\_extended\_remote\_ops() & \ & \cxreffunc{init_extended_remote_ops}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_async\_ops}
\label{var_remote_async_ops_remote.c}

{\stt static struct target\_ops remote\_async\_ops}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_extended\_async\_remote\_ops() & \ & \cxreffunc{init_extended_async_remote_ops}{remote.c}\\
\ & init\_remote\_async\_ops() & \ & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & remote\_async\_mourn() & \ & \cxreffunc{remote_async_mourn}{remote.c}\\
\ & remote\_async\_open() & \ & \cxreffunc{remote_async_open}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf extended\_async\_remote\_ops}
\label{var_extended_async_remote_ops_remote.c}

{\stt static struct target\_ops extended\_async\_remote\_ops}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & extended\_remote\_async\_open() & \ & \cxreffunc{extended_remote_async_open}{remote.c}\\
\ & init\_extended\_async\_remote\_ops() & \ & \cxreffunc{init_extended_async_remote_ops}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf wait\_forever\_enabled\_p}
\label{var_wait_forever_enabled_p_remote.c}

{\stt static int wait\_forever\_enabled\_p}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async\_wait() & \ & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_open\_1() & \ & \cxreffunc{remote_open_1}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_break}
\label{var_remote_break_remote.c}

{\stt static int remote\_break}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & remote\_stop() & \ & \cxreffunc{remote_stop}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_desc}
\label{var_remote_desc_remote.c}

{\stt static struct serial* remote\_desc}

\smallskip
\begin{cxreftabiii}
Used in:\ & dump\_packets\_command() & \ & \cxreffunc{dump_packets_command}{remote.c}\\
\ & getpkt\_sane() & \ & \cxreffunc{getpkt_sane}{remote.c}\\
\ & packet\_command() & \ & \cxreffunc{packet_command}{remote.c}\\
\ & putpkt\_binary() & \ & \cxreffunc{putpkt_binary}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & readchar() & \ & \cxreffunc{readchar}{remote.c}\\
\ & remote\_async() & \ & \cxreffunc{remote_async}{remote.c}\\
\ & remote\_async\_kill() & \ & \cxreffunc{remote_async_kill}{remote.c}\\
\ & remote\_can\_async\_p() & \ & \cxreffunc{remote_can_async_p}{remote.c}\\
\ & remote\_close() & \ & \cxreffunc{remote_close}{remote.c}\\
\ & remote\_detach() & \ & \cxreffunc{remote_detach}{remote.c}\\
\ & remote\_disconnect() & \ & \cxreffunc{remote_disconnect}{remote.c}\\
\ & remote\_is\_async\_p() & \ & \cxreffunc{remote_is_async_p}{remote.c}\\
\ & remote\_new\_objfile() & \ & \cxreffunc{remote_new_objfile}{remote.c}\\
\ & remote\_open\_1() & \ & \cxreffunc{remote_open_1}{remote.c}\\
\ & remote\_rcmd() & \ & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_start\_remote() & \ & \cxreffunc{remote_start_remote}{remote.c}\\
\ & remote\_stop() & \ & \cxreffunc{remote_stop}{remote.c}\\
\ & remote\_threads\_extra\_info() & \ & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\ & remote\_threads\_info() & \ & \cxreffunc{remote_threads_info}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_xfer\_partial() & \ & \cxreffunc{remote_xfer_partial}{remote.c}\\
\ & set\_no\_ack\_mode\_cmd() & \ & \cxreffunc{set_no_ack_mode_cmd}{remote.c}\\
\ & set\_remote\_debugflags\_command() & \ & \cxreffunc{set_remote_debugflags_command}{remote.c}\\
\ & show\_no\_ack\_mode\_cmd() & \ & \cxreffunc{show_no_ack_mode_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_address\_size}
\label{var_remote_address_size_remote.c}

{\stt static size\_t remote\_address\_size}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & build\_remote\_gdbarch\_data() & \ & \cxreffunc{build_remote_gdbarch_data}{remote.c}\\
\ & remote\_address\_masked() & \ & \cxreffunc{remote_address_masked}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_async\_terminal\_ours\_p}
\label{var_remote_async_terminal_ours_p_remote.c}

{\stt static int remote\_async\_terminal\_ours\_p}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async\_terminal\_inferior() & \ & \cxreffunc{remote_async_terminal_inferior}{remote.c}\\
\ & remote\_async\_terminal\_ours() & \ & \cxreffunc{remote_async_terminal_ours}{remote.c}\\
\ & remote\_open\_1() & \ & \cxreffunc{remote_open_1}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf memory\_write\_packet\_config}
\label{var_memory_write_packet_config_remote.c}

{\stt static struct memory\_packet\_config memory\_write\_packet\_config}

\smallskip
\begin{cxreftabiii}
Used in:\ & get\_memory\_write\_packet\_size() & \ & \cxreffunc{get_memory_write_packet_size}{remote.c}\\
\ & set\_memory\_write\_packet\_size() & \ & \cxreffunc{set_memory_write_packet_size}{remote.c}\\
\ & show\_memory\_write\_packet\_size() & \ & \cxreffunc{show_memory_write_packet_size}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf memory\_read\_packet\_config}
\label{var_memory_read_packet_config_remote.c}

{\stt static struct memory\_packet\_config memory\_read\_packet\_config}

\smallskip
\begin{cxreftabiii}
Used in:\ & get\_memory\_read\_packet\_size() & \ & \cxreffunc{get_memory_read_packet_size}{remote.c}\\
\ & set\_memory\_read\_packet\_size() & \ & \cxreffunc{set_memory_read_packet_size}{remote.c}\\
\ & show\_memory\_read\_packet\_size() & \ & \cxreffunc{show_memory_read_packet_size}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_protocol\_vcont}
\label{var_remote_protocol_vcont_remote.c}

{\stt static struct packet\_config remote\_protocol\_vcont}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_all\_packet\_configs() & \ & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & remote\_vcont\_probe() & \ & \cxreffunc{remote_vcont_probe}{remote.c}\\
\ & remote\_vcont\_resume() & \ & \cxreffunc{remote_vcont_resume}{remote.c}\\
\ & set\_remote\_protocol\_vcont\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_vcont_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_vcont\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_vcont_packet_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_protocol\_qSymbol}
\label{var_remote_protocol_qSymbol_remote.c}

{\stt static struct packet\_config remote\_protocol\_qSymbol}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_all\_packet\_configs() & \ & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & remote\_check\_symbols() & \ & \cxreffunc{remote_check_symbols}{remote.c}\\
\ & set\_remote\_protocol\_qSymbol\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_qSymbol_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qSymbol\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_qSymbol_packet_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_protocol\_P}
\label{var_remote_protocol_P_remote.c}

{\stt static struct packet\_config remote\_protocol\_P}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_all\_packet\_configs() & \ & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & remote\_prepare\_to\_store() & \ & \cxreffunc{remote_prepare_to_store}{remote.c}\\
\ & remote\_store\_registers() & \ & \cxreffunc{remote_store_registers}{remote.c}\\
\ & set\_remote\_protocol\_P\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_P_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_P\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_P_packet_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_protocol\_Z}
\label{var_remote_protocol_Z_remote.c}

{\stt static struct packet\_config remote\_protocol\_Z[NR\_Z\_PACKET\_TYPES]}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_all\_packet\_configs() & \ & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & remote\_insert\_breakpoint() & \ & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\ & remote\_insert\_hw\_breakpoint() & \ & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_insert\_watchpoint() & \ & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\ & remote\_remove\_breakpoint() & \ & \cxreffunc{remote_remove_breakpoint}{remote.c}\\
\ & remote\_remove\_hw\_breakpoint() & \ & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & \ & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & set\_remote\_protocol\_Z\_access\_wp\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_Z_access_wp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_Z_hardware_bp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_Z_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_read\_wp\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_Z_read_wp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_software\_bp\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_Z_software_bp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_write\_wp\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_Z_write_wp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_access\_wp\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_Z_access_wp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_Z_hardware_bp_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_remote\_protocol\_Z\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_Z_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_read\_wp\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_Z_read_wp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_software\_bp\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_Z_software_bp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_write\_wp\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_Z_write_wp_packet_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_Z\_packet\_detect}
\label{var_remote_Z_packet_detect_remote.c}

{\stt static enum auto\_boolean remote\_Z\_packet\_detect}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & set\_remote\_protocol\_Z\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_Z_packet_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_protocol\_binary\_download}
\label{var_remote_protocol_binary_download_remote.c}

{\stt static struct packet\_config remote\_protocol\_binary\_download}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & check\_binary\_download() & \ & \cxreffunc{check_binary_download}{remote.c}\\
\ & init\_all\_packet\_configs() & \ & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & remote\_write\_bytes() & \ & \cxreffunc{remote_write_bytes}{remote.c}\\
\ & set\_remote\_protocol\_binary\_download\_cmd() & \ & \cxreffunc{set_remote_protocol_binary_download_cmd}{remote.c}\\
\ & show\_remote\_protocol\_binary\_download\_cmd() & \ & \cxreffunc{show_remote_protocol_binary_download_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf use\_threadinfo\_query}
\label{var_use_threadinfo_query_remote.c}

{\stt static int use\_threadinfo\_query}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_open\_1() & \ & \cxreffunc{remote_open_1}{remote.c}\\
\ & remote\_threads\_info() & \ & \cxreffunc{remote_threads_info}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf use\_threadextra\_query}
\label{var_use_threadextra_query_remote.c}

{\stt static int use\_threadextra\_query}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_open\_1() & \ & \cxreffunc{remote_open_1}{remote.c}\\
\ & remote\_threads\_extra\_info() & \ & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_protocol\_qPart\_auxv}
\label{var_remote_protocol_qPart_auxv_remote.c}

{\stt static struct packet\_config remote\_protocol\_qPart\_auxv}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_all\_packet\_configs() & \ & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & remote\_xfer\_partial() & \ & \cxreffunc{remote_xfer_partial}{remote.c}\\
\ & set\_remote\_protocol\_qPart\_auxv\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_qPart_auxv_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qPart\_auxv\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_qPart_auxv_packet_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_protocol\_qGetTLSAddr}
\label{var_remote_protocol_qGetTLSAddr_remote.c}

{\stt static struct packet\_config remote\_protocol\_qGetTLSAddr}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_all\_packet\_configs() & \ & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & remote\_get\_thread\_local\_address() & \ & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\ & set\_remote\_protocol\_qGetTLSAddr\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_qGetTLSAddr_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qGetTLSAddr\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_qGetTLSAddr_packet_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_protocol\_p}
\label{var_remote_protocol_p_remote.c}

{\stt static struct packet\_config remote\_protocol\_p}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_all\_packet\_configs() & \ & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & remote\_fetch\_registers() & \ & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & set\_remote\_protocol\_p\_packet\_cmd() & \ & \cxreffunc{set_remote_protocol_p_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_p\_packet\_cmd() & \ & \cxreffunc{show_remote_protocol_p_packet_cmd}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf sigint\_remote\_twice\_token}
\label{var_sigint_remote_twice_token_remote.c}

{\stt static void* sigint\_remote\_twice\_token}

\smallskip
\begin{cxreftabiii}
Used in:\ & cleanup\_sigint\_signal\_handler() & \ & \cxreffunc{cleanup_sigint_signal_handler}{remote.c}\\
\ & handle\_remote\_sigint() & \ & \cxreffunc{handle_remote_sigint}{remote.c}\\
\ & handle\_remote\_sigint\_twice() & \ & \cxreffunc{handle_remote_sigint_twice}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf sigint\_remote\_token}
\label{var_sigint_remote_token_remote.c}

{\stt static void* sigint\_remote\_token}

\smallskip
\begin{cxreftabiii}
Used in:\ & cleanup\_sigint\_signal\_handler() & \ & \cxreffunc{cleanup_sigint_signal_handler}{remote.c}\\
\ & handle\_remote\_sigint() & \ & \cxreffunc{handle_remote_sigint}{remote.c}\\
\ & initialize\_sigint\_signal\_handler() & \ & \cxreffunc{initialize_sigint_signal_handler}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf general\_thread}
\label{var_general_thread_remote.c}

{\stt static int general\_thread}

\smallskip
\begin{cxreftabiii}
Used in:\ & record\_currthread() & \ & \cxreffunc{record_currthread}{remote.c}\\
\ & remote\_open\_1() & \ & \cxreffunc{remote_open_1}{remote.c}\\
\ & set\_thread() & \ & \cxreffunc{set_thread}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf continue\_thread}
\label{var_continue_thread_remote.c}

{\stt static int continue\_thread}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_open\_1() & \ & \cxreffunc{remote_open_1}{remote.c}\\
\ & set\_thread() & \ & \cxreffunc{set_thread}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf hexchars}
\label{var_hexchars_remote.c}

{\stt static const char hexchars[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & pack\_hex\_byte() & \ & \cxreffunc{pack_hex_byte}{remote.c}\\
\ & pack\_nibble() & \ & \cxreffunc{pack_nibble}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf last\_sent\_signal}
\label{var_last_sent_signal_remote.c}

{\stt static enum target\_signal last\_sent\_signal}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async\_wait() & \ & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_resume() & \ & \cxreffunc{remote_resume}{remote.c}\\
\ & remote\_wait() & \ & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf last\_sent\_step}
\label{var_last_sent_step_remote.c}

{\stt static int last\_sent\_step}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async\_wait() & \ & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_resume() & \ & \cxreffunc{remote_resume}{remote.c}\\
\ & remote\_wait() & \ & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf ofunc}
\label{var_ofunc_remote.c}

{\stt static void (*ofunc)(int)}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async\_wait() & \ & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_interrupt\_twice() & \ & \cxreffunc{remote_interrupt_twice}{remote.c}\\
\ & remote\_wait() & \ & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf register\_bytes\_found}
\label{var_register_bytes_found_remote.c}

{\stt static int register\_bytes\_found}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_fetch\_registers() & \ & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & remote\_store\_registers() & \ & \cxreffunc{remote_store_registers}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf crc32\_table}
\label{var_crc32_table_remote.c}

{\stt static unsigned long crc32\_table[256]}

\smallskip
\begin{cxreftabiii}
Used in:\ & crc32() & \ & \cxreffunc{crc32}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf async\_client\_callback}
\label{var_async_client_callback_remote.c}

{\stt static void (*async\_client\_callback)(enum inferior\_event\_type event\_type,void* context)}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async() & \ & \cxreffunc{remote_async}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf async\_client\_context}
\label{var_async_client_context_remote.c}

{\stt static void* async\_client\_context}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async() & \ & \cxreffunc{remote_async}{remote.c}\\
\ & remote\_async\_serial\_handler() & \ & \cxreffunc{remote_async_serial_handler}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_async\_serial\_handler}
\label{var_remote_async_serial_handler_remote.c}

{\stt static serial\_event\_ftype remote\_async\_serial\_handler}

\smallskip
\begin{cxreftabiii}
Used in:\ & remote\_async() & \ & \cxreffunc{remote_async}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_new\_objfile\_chain}
\label{var_remote_new_objfile_chain_remote.c}

{\stt static void (*remote\_new\_objfile\_chain)(struct objfile*)}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & remote\_new\_objfile() & \ & \cxreffunc{remote_new_objfile}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_macosx\_ops}
\label{var_remote_macosx_ops_remote.c}

{\stt static struct target\_ops remote\_macosx\_ops}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & init\_remote\_macosx\_ops() & \ & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
\ & remote\_macosx\_mourn() & \ & \cxreffunc{remote_macosx_mourn}{remote.c}\\
\ & remote\_macosx\_open() & \ & \cxreffunc{remote_macosx_open}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_macosx\_shortname}
\label{var_remote_macosx_shortname_remote.c}

{\stt static const char* remote\_macosx\_shortname}

\smallskip
\begin{cxreftabiii}
Used in:\ & init\_remote\_macosx\_ops() & \ & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_macosx\_longname}
\label{var_remote_macosx_longname_remote.c}

{\stt static const char* remote\_macosx\_longname}

\smallskip
\begin{cxreftabiii}
Used in:\ & init\_remote\_macosx\_ops() & \ & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_macosx\_doc}
\label{var_remote_macosx_doc_remote.c}

{\stt static const char* remote\_macosx\_doc}

\smallskip
\begin{cxreftabiii}
Used in:\ & init\_remote\_macosx\_ops() & \ & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
\end{cxreftabiii}

\medskip
{\bf remote\_macosx\_exec\_dir}
\label{var_remote_macosx_exec_dir_remote.c}

{\stt static char* remote\_macosx\_exec\_dir}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & \ & \cxreffunc{_initialize_remote}{remote.c}\\
\ & remote\_macosx\_attach() & \ & \cxreffunc{remote_macosx_attach}{remote.c}\\
\ & remote\_macosx\_create\_inferior() & \ & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_remote()}
\label{func__initialize_remote_remote.c}

{\stt void \_initialize\_remote ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & add\_packet\_config\_cmd() & remote.c & \cxreffunc{add_packet_config_cmd}{remote.c}\\
\ & add\_target() & target/target.c & \cxreffunc{add_target}{target/target.c}\\
\ & deprecated\_register\_gdbarch\_swap() & gdbarch.c & \cxreffunc{deprecated_register_gdbarch_swap}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_data\_register\_post\_init() & gdbarch.c & \cxreffunc{gdbarch_data_register_post_init}{gdbarch.c}\\
\ & init\_extended\_async\_remote\_ops() & remote.c & \cxreffunc{init_extended_async_remote_ops}{remote.c}\\
\ & init\_extended\_remote\_ops() & remote.c & \cxreffunc{init_extended_remote_ops}{remote.c}\\
\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_macosx\_ops() & remote.c & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\ & initialize\_remote\_fileio() & remote-fileio.c & \cxreffunc{initialize_remote_fileio}{remote-fileio.c}\\
\ & \cxreftabiiispan{ add\_cmd(), add\_prefix\_cmd(), add\_setshow\_auto\_boolean\_cmd(), add\_setshow\_boolean\_cmd(), add\_setshow\_integer\_cmd(), add\_setshow\_string\_cmd(), add\_setshow\_string\_noescape\_cmd(), add\_setshow\_zinteger\_cmd()} &\\
Refs Func:\ & build\_remote\_gdbarch\_data() & remote.c & \cxreffunc{build_remote_gdbarch_data}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & compare\_sections\_command() & remote.c & \cxreffunc{compare_sections_command}{remote.c}\\
\ & dump\_packets\_command() & remote.c & \cxreffunc{dump_packets_command}{remote.c}\\
\ & init\_remote\_state() & remote.c & \cxreffunc{init_remote_state}{remote.c}\\
\ & packet\_command() & remote.c & \cxreffunc{packet_command}{remote.c}\\
\ & remote\_new\_objfile() & remote.c & \cxreffunc{remote_new_objfile}{remote.c}\\
\ & set\_max\_remote\_packet\_size() & remote.c & \cxreffunc{set_max_remote_packet_size}{remote.c}\\
\ & set\_memory\_read\_packet\_size() & remote.c & \cxreffunc{set_memory_read_packet_size}{remote.c}\\
\ & set\_memory\_write\_packet\_size() & remote.c & \cxreffunc{set_memory_write_packet_size}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_no\_ack\_mode\_cmd() & remote.c & \cxreffunc{set_no_ack_mode_cmd}{remote.c}\\
\ & set\_remote\_cmd() & remote.c & \cxreffunc{set_remote_cmd}{remote.c}\\
\ & set\_remote\_debugflags\_command() & remote.c & \cxreffunc{set_remote_debugflags_command}{remote.c}\\
\ & set\_remote\_protocol\_P\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_P_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_access\_wp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_access_wp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_hardware_bp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_read\_wp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_read_wp_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_remote\_protocol\_Z\_software\_bp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_software_bp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_write\_wp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_write_wp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_binary\_download\_cmd() & remote.c & \cxreffunc{set_remote_protocol_binary_download_cmd}{remote.c}\\
\ & set\_remote\_protocol\_p\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_p_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_qGetTLSAddr\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_qGetTLSAddr_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_qPart\_auxv\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_qPart_auxv_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_qSymbol\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_qSymbol_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_vcont\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_vcont_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_max\_remote\_packet\_size() & remote.c & \cxreffunc{show_max_remote_packet_size}{remote.c}\\
\ & show\_memory\_read\_packet\_size() & remote.c & \cxreffunc{show_memory_read_packet_size}{remote.c}\\
\ & show\_memory\_write\_packet\_size() & remote.c & \cxreffunc{show_memory_write_packet_size}{remote.c}\\
\ & show\_no\_ack\_mode\_cmd() & remote.c & \cxreffunc{show_no_ack_mode_cmd}{remote.c}\\
\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
\ & show\_remote\_debugflags\_command() & remote.c & \cxreffunc{show_remote_debugflags_command}{remote.c}\\
\ & show\_remote\_protocol\_P\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_P_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_access\_wp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_access_wp_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_hardware_bp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_read\_wp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_read_wp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_software\_bp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_software_bp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_write\_wp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_write_wp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_binary\_download\_cmd() & remote.c & \cxreffunc{show_remote_protocol_binary_download_cmd}{remote.c}\\
\ & show\_remote\_protocol\_p\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_p_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qGetTLSAddr\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qGetTLSAddr_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_remote\_protocol\_qPart\_auxv\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qPart_auxv_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qSymbol\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qSymbol_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_vcont\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_vcont_packet_cmd}{remote.c}\\
Refs Var:\ & deprecated\_target\_new\_objfile\_hook & symfile.c & \cxrefvar{deprecated_target_new_objfile_hook}{symfile.c}\\
\ & extended\_async\_remote\_ops & remote.c & \cxrefvar{extended_async_remote_ops}{remote.c}\\
\ & extended\_remote\_ops & remote.c & \cxrefvar{extended_remote_ops}{remote.c}\\
\ & remote\_Z\_packet\_detect & remote.c & \cxrefvar{remote_Z_packet_detect}{remote.c}\\
\ & remote\_address\_size & remote.c & \cxrefvar{remote_address_size}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_async\_ops & remote.c & \cxrefvar{remote_async_ops}{remote.c}\\
\ & remote\_break & remote.c & \cxrefvar{remote_break}{remote.c}\\
\ & remote\_debugflags & remote.c & \cxrefvar{remote_debugflags}{remote.c}\\
\ & remote\_gdbarch\_data\_handle & remote.c & \cxrefvar{remote_gdbarch_data_handle}{remote.c}\\
\ & remote\_hw\_breakpoint\_limit & remote.c & \cxrefvar{remote_hw_breakpoint_limit}{remote.c}\\
\ & remote\_hw\_watchpoint\_limit & remote.c & \cxrefvar{remote_hw_watchpoint_limit}{remote.c}\\
\ & remote\_macosx\_exec\_dir & remote.c & \cxrefvar{remote_macosx_exec_dir}{remote.c}\\
\ & remote\_macosx\_ops & remote.c & \cxrefvar{remote_macosx_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_new\_objfile\_chain & remote.c & \cxrefvar{remote_new_objfile_chain}{remote.c}\\
\ & remote\_ops & remote.c & \cxrefvar{remote_ops}{remote.c}\\
\ & remote\_protocol\_P & remote.c & \cxrefvar{remote_protocol_P}{remote.c}\\
\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\ & remote\_protocol\_binary\_download & remote.c & \cxrefvar{remote_protocol_binary_download}{remote.c}\\
\ & remote\_protocol\_p & remote.c & \cxrefvar{remote_protocol_p}{remote.c}\\
\ & remote\_protocol\_qGetTLSAddr & remote.c & \cxrefvar{remote_protocol_qGetTLSAddr}{remote.c}\\
\ & remote\_protocol\_qPart\_auxv & remote.c & \cxrefvar{remote_protocol_qPart_auxv}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_protocol\_qSymbol & remote.c & \cxrefvar{remote_protocol_qSymbol}{remote.c}\\
\ & remote\_protocol\_vcont & remote.c & \cxrefvar{remote_protocol_vcont}{remote.c}\\
\ & user\_requested\_no\_ack\_mode & remote.c & \cxrefvar{user_requested_no_ack_mode}{remote.c}\\
\ & \cxreftabiiispan{ cmdlist, maintenancelist, setlist, showlist} &\\
\end{cxreftabiii}


\subsubsection{Global Function async\_remote\_interrupt\_twice()}
\label{func_async_remote_interrupt_twice_remote.c}

{\stt void async\_remote\_interrupt\_twice ( gdb\_client\_data arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & interrupt\_query() & remote.c & \cxreffunc{interrupt_query}{remote.c}\\
\ & \cxreftabiiispan{ signal()} &\\
Called by:\ & inferior\_event\_handler() & inf-loop.c & \cxreffunc{inferior_event_handler}{inf-loop.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & handle\_remote\_sigint() & remote.c & \cxreffunc{handle_remote_sigint}{remote.c}\\
Refs Func:\ & handle\_remote\_sigint() & remote.c & \cxreffunc{handle_remote_sigint}{remote.c}\\
Refs Var:\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\ & target\_executing & top.c & \cxrefvar{target_executing}{top.c}\\
\end{cxreftabiii}


\subsubsection{Global Function dump\_packets\_command()}
\label{func_dump_packets_command_remote.c}

{\stt void dump\_packets\_command ( const char* unused, int fromtty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & dump\_protocol\_log() & remote.c & \cxreffunc{dump_protocol_log}{remote.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function getpkt()}
\label{func_getpkt_remote.c}

{\stt void getpkt ( char* buf, long sizeof\_buf, int forever )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
Called by:\ & check\_binary\_download() & remote.c & \cxreffunc{check_binary_download}{remote.c}\\
\ & compare\_sections\_command() & remote.c & \cxreffunc{compare_sections_command}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & extended\_remote\_restart() & remote.c & \cxreffunc{extended_remote_restart}{remote.c}\\
\ & get\_offsets() & remote.c & \cxreffunc{get_offsets}{remote.c}\\
\ & packet\_command() & remote.c & \cxreffunc{packet_command}{remote.c}\\
\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\ & remote\_current\_thread() & remote.c & \cxreffunc{remote_current_thread}{remote.c}\\
\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & remote\_get\_noisy\_reply() & tracepoint.c & \cxreffunc{remote_get_noisy_reply}{tracepoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_get\_thread\_local\_address() & remote.c & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\ & remote\_get\_threadinfo() & remote.c & \cxreffunc{remote_get_threadinfo}{remote.c}\\
\ & remote\_get\_threadlist() & remote.c & \cxreffunc{remote_get_threadlist}{remote.c}\\
\ & remote\_insert\_breakpoint() & remote.c & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\ & remote\_insert\_hw\_breakpoint() & remote.c & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
\ & remote\_macosx\_get\_all\_image\_infos\_addr() & remote.c & \cxreffunc{remote_macosx_get_all_image_infos_addr}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\ & remote\_rcmd() & remote.c & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_read\_bytes() & remote.c & \cxreffunc{remote_read_bytes}{remote.c}\\
\ & remote\_remove\_breakpoint() & remote.c & \cxreffunc{remote_remove_breakpoint}{remote.c}\\
\ & remote\_remove\_hw\_breakpoint() & remote.c & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & remote\_send() & remote.c & \cxreffunc{remote_send}{remote.c}\\
\ & remote\_set\_transparent\_ranges() & tracepoint.c & \cxreffunc{remote_set_transparent_ranges}{tracepoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_thread\_alive() & remote.c & \cxreffunc{remote_thread_alive}{remote.c}\\
\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
\ & remote\_vcont\_probe() & remote.c & \cxreffunc{remote_vcont_probe}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
\ & send\_disable\_aslr() & remote.c & \cxreffunc{send_disable_aslr}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & send\_remote\_debugflags\_pkt() & remote.c & \cxreffunc{send_remote_debugflags_pkt}{remote.c}\\
\ & send\_remote\_max\_payload\_size() & remote.c & \cxreffunc{send_remote_max_payload_size}{remote.c}\\
\ & set\_thread() & remote.c & \cxreffunc{set_thread}{remote.c}\\
\ & start\_no\_ack\_mode() & remote.c & \cxreffunc{start_no_ack_mode}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function int\_to\_threadref()}
\label{func_int_to_threadref_remote.c}

{\stt void int\_to\_threadref ( threadref* id, int value )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function push\_remote\_macosx\_target()}
\label{func_push_remote_macosx_target_remote.c}

{\stt void push\_remote\_macosx\_target ( char* name, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& target.h & \ & \cxreffile{target.h}\\
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & remote\_macosx\_open() & remote.c & \cxreffunc{remote_macosx_open}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function push\_remote\_target()}
\label{func_push_remote_target_remote.c}

{\stt void push\_remote\_target ( const char* name, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& target.h & \ & \cxreffile{target.h}\\
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & remote\_open() & remote.c & \cxreffunc{remote_open}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function putpkt()}
\label{func_putpkt_remote.c}

{\stt int putpkt ( const char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & compare\_sections\_command() & remote.c & \cxreffunc{compare_sections_command}{remote.c}\\
\ & extended\_remote\_restart() & remote.c & \cxreffunc{extended_remote_restart}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & finish\_tfind\_command() & tracepoint.c & \cxreffunc{finish_tfind_command}{tracepoint.c}\\
\ & get\_offsets() & remote.c & \cxreffunc{get_offsets}{remote.c}\\
\ & packet\_command() & remote.c & \cxreffunc{packet_command}{remote.c}\\
\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\ & remote\_current\_thread() & remote.c & \cxreffunc{remote_current_thread}{remote.c}\\
\ & remote\_fileio\_reply() & remote-fileio.c & \cxreffunc{remote_fileio_reply}{remote-fileio.c}\\
\ & remote\_get\_thread\_local\_address() & remote.c & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_get\_threadinfo() & remote.c & \cxreffunc{remote_get_threadinfo}{remote.c}\\
\ & remote\_get\_threadlist() & remote.c & \cxreffunc{remote_get_threadlist}{remote.c}\\
\ & remote\_insert\_breakpoint() & remote.c & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\ & remote\_insert\_hw\_breakpoint() & remote.c & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\ & remote\_macosx\_attach() & remote.c & \cxreffunc{remote_macosx_attach}{remote.c}\\
\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
\ & remote\_macosx\_get\_all\_image\_infos\_addr() & remote.c & \cxreffunc{remote_macosx_get_all_image_infos_addr}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_macosx\_query\_qenvironment\_hex\_packet\_supported() & remote.c & \cxreffunc{remote_macosx_query_qenvironment_hex_packet_supported}{remote.c}\\
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\ & remote\_rcmd() & remote.c & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_read\_bytes() & remote.c & \cxreffunc{remote_read_bytes}{remote.c}\\
\ & remote\_remove\_breakpoint() & remote.c & \cxreffunc{remote_remove_breakpoint}{remote.c}\\
\ & remote\_remove\_hw\_breakpoint() & remote.c & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_send() & remote.c & \cxreffunc{remote_send}{remote.c}\\
\ & remote\_set\_transparent\_ranges() & tracepoint.c & \cxreffunc{remote_set_transparent_ranges}{tracepoint.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & remote\_thread\_alive() & remote.c & \cxreffunc{remote_thread_alive}{remote.c}\\
\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
\ & remote\_vcont\_probe() & remote.c & \cxreffunc{remote_vcont_probe}{remote.c}\\
\ & remote\_vcont\_resume() & remote.c & \cxreffunc{remote_vcont_resume}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
\ & send\_disable\_aslr() & remote.c & \cxreffunc{send_disable_aslr}{remote.c}\\
\ & send\_remote\_debugflags\_pkt() & remote.c & \cxreffunc{send_remote_debugflags_pkt}{remote.c}\\
\ & send\_remote\_max\_payload\_size() & remote.c & \cxreffunc{send_remote_max_payload_size}{remote.c}\\
\ & set\_thread() & remote.c & \cxreffunc{set_thread}{remote.c}\\
\ & start\_no\_ack\_mode() & remote.c & \cxreffunc{start_no_ack_mode}{remote.c}\\
\ & trace\_start\_command() & tracepoint.c & \cxreffunc{trace_start_command}{tracepoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & trace\_status\_command() & tracepoint.c & \cxreffunc{trace_status_command}{tracepoint.c}\\
\ & trace\_stop\_command() & tracepoint.c & \cxreffunc{trace_stop_command}{tracepoint.c}\\
Used in:\ & remote\_async\_kill() & remote.c & \cxreffunc{remote_async_kill}{remote.c}\\
\ & remote\_kill() & remote.c & \cxreffunc{remote_kill}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remote\_console\_output()}
\label{func_remote_console_output_remote.c}

{\stt void remote\_console\_output ( char* msg )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & fputs\_unfiltered() & ui-file.c & \cxreffunc{fputs_unfiltered}{ui-file.c}\\
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_get\_noisy\_reply() & tracepoint.c & \cxreffunc{remote_get_noisy_reply}{tracepoint.c}\\
\ & remote\_rcmd() & remote.c & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
Refs Var:\ & gdb\_stdtarg & main.c & \cxrefvar{gdb_stdtarg}{main.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remote\_macosx\_attach()}
\label{func_remote_macosx_attach_remote.c}

{\stt void remote\_macosx\_attach ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & pack\_hex\_byte() & remote.c & \cxreffunc{pack_hex_byte}{remote.c}\\
\ & pack\_string\_as\_ascii\_hex() & remote.c & \cxreffunc{pack_string_as_ascii_hex}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_macosx\_complete\_create\_or\_attach() & remote.c & \cxreffunc{remote_macosx_complete_create_or_attach}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), strchr(), strlen(), strstr(), strtol()} &\\
Used in:\ & init\_remote\_macosx\_ops() & remote.c & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
Refs Var:\ & remote\_macosx\_exec\_dir & remote.c & \cxrefvar{remote_macosx_exec_dir}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remote\_macosx\_create\_inferior()}
\label{func_remote_macosx_create_inferior_remote.c}

{\stt void remote\_macosx\_create\_inferior ( char* exec\_file, char* allargs, char** env, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & breakup\_args() & utils.c & \cxreffunc{breakup_args}{utils.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & pack\_hex\_byte() & remote.c & \cxreffunc{pack_hex_byte}{remote.c}\\
\ & pack\_string\_as\_ascii\_hex() & remote.c & \cxreffunc{pack_string_as_ascii_hex}{remote.c}\\
\ & pop\_target() & target/target.c & \cxreffunc{pop_target}{target/target.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_macosx\_complete\_create\_or\_attach() & remote.c & \cxreffunc{remote_macosx_complete_create_or_attach}{remote.c}\\
\ & remote\_macosx\_query\_qenvironment\_hex\_packet\_supported() & remote.c & \cxreffunc{remote_macosx_query_qenvironment_hex_packet_supported}{remote.c}\\
\ & send\_disable\_aslr() & remote.c & \cxreffunc{send_disable_aslr}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), basename(), strlen(), xstrdup()} &\\
Used in:\ & init\_remote\_macosx\_ops() & remote.c & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & remote\_macosx\_exec\_dir & remote.c & \cxrefvar{remote_macosx_exec_dir}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_timeout & top.c & \cxrefvar{remote_timeout}{top.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remote\_macosx\_get\_all\_image\_infos\_addr()}
\label{func_remote_macosx_get_all_image_infos_addr_remote.c}

{\stt CORE\_ADDR remote\_macosx\_get\_all\_image\_infos\_addr ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & unpack\_varlen\_hex() & remote.c & \cxreffunc{unpack_varlen_hex}{remote.c}\\
\ & \cxreftabiiispan{ isxdigit()} &\\
Called by:\ & remote\_macosx\_complete\_create\_or\_attach() & remote.c & \cxreffunc{remote_macosx_complete_create_or_attach}{remote.c}\\
\ & remote\_macosx\_open() & remote.c & \cxreffunc{remote_macosx_open}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remote\_read\_bytes()}
\label{func_remote_read_bytes_remote.c}

{\stt int remote\_read\_bytes ( CORE\_ADDR memaddr, char* myaddr, int len )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & get\_memory\_read\_packet\_size() & remote.c & \cxreffunc{get_memory_read_packet_size}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hex2bin() & remote.c & \cxreffunc{hex2bin}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_address\_masked() & remote.c & \cxreffunc{remote_address_masked}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), \_\_error(), isxdigit()} &\\
Called by:\ & remote\_fileio\_func\_open() & remote-fileio.c & \cxreffunc{remote_fileio_func_open}{remote-fileio.c}\\
\ & remote\_fileio\_func\_rename() & remote-fileio.c & \cxreffunc{remote_fileio_func_rename}{remote-fileio.c}\\
\ & remote\_fileio\_func\_stat() & remote-fileio.c & \cxreffunc{remote_fileio_func_stat}{remote-fileio.c}\\
\ & remote\_fileio\_func\_system() & remote-fileio.c & \cxreffunc{remote_fileio_func_system}{remote-fileio.c}\\
\ & remote\_fileio\_func\_unlink() & remote-fileio.c & \cxreffunc{remote_fileio_func_unlink}{remote-fileio.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_fileio\_func\_write() & remote-fileio.c & \cxreffunc{remote_fileio_func_write}{remote-fileio.c}\\
\ & remote\_xfer\_memory() & remote.c & \cxreffunc{remote_xfer_memory}{remote.c}\\
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remote\_write\_bytes()}
\label{func_remote_write_bytes_remote.c}

{\stt int remote\_write\_bytes ( CORE\_ADDR memaddr, const gdb\_byte* myaddr, int len )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.h & \ & \cxreffile{remote.h}\\
Calls:\ & bin2hex() & remote.c & \cxreffunc{bin2hex}{remote.c}\\
\ & check\_binary\_download() & remote.c & \cxreffunc{check_binary_download}{remote.c}\\
\ & get\_memory\_write\_packet\_size() & remote.c & \cxreffunc{get_memory_write_packet_size}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hexnumlen() & remote.c & \cxreffunc{hexnumlen}{remote.c}\\
\ & hexnumnstr() & remote.c & \cxreffunc{hexnumnstr}{remote.c}\\
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & remote\_address\_masked() & remote.c & \cxreffunc{remote_address_masked}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), \_\_error(), strlen()} &\\
Called by:\ & remote\_fileio\_write\_bytes() & remote-fileio.c & \cxreffunc{remote_fileio_write_bytes}{remote-fileio.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_xfer\_memory() & remote.c & \cxreffunc{remote_xfer_memory}{remote.c}\\
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
Refs Var:\ & remote\_protocol\_binary\_download & remote.c & \cxrefvar{remote_protocol_binary_download}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Global Function unpack\_varlen\_hex()}
\label{func_unpack_varlen_hex_remote.c}

{\stt char* unpack\_varlen\_hex ( char* buff, unsigned long* result )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & ishex() & remote.c & \cxreffunc{ishex}{remote.c}\\
Called by:\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_get\_thread\_local\_address() & remote.c & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_macosx\_get\_all\_image\_infos\_addr() & remote.c & \cxreffunc{remote_macosx_get_all_image_infos_addr}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_incoming\_pkt\_to\_protocol\_log()}
\label{func_add_incoming_pkt_to_protocol_log_remote.c}

{\stt static void add\_incoming\_pkt\_to\_protocol\_log ( const char* p )}

\smallskip
\begin{cxreftabiii}
Calls:\ & add\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_pkt_to_protocol_log}{remote.c}\\
Called by:\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_outgoing\_pkt\_to\_protocol\_log()}
\label{func_add_outgoing_pkt_to_protocol_log_remote.c}

{\stt static void add\_outgoing\_pkt\_to\_protocol\_log ( const char* p )}

\smallskip
\begin{cxreftabiii}
Calls:\ & add\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_pkt_to_protocol_log}{remote.c}\\
Called by:\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & remote\_stop() & remote.c & \cxreffunc{remote_stop}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function add\_packet\_config\_cmd()}
\label{func_add_packet_config_cmd_remote.c}

{\stt static void add\_packet\_config\_cmd ( struct packet\_config* config, const char* name, const char* title, cmd\_sfunc\_ftype* set\_func, show\_value\_ftype* show\_func, struct cmd\_list\_element** set\_remote\_list, struct cmd\_list\_element** show\_remote\_list, int legacy )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ add\_alias\_cmd(), add\_setshow\_auto\_boolean\_cmd()} &\\
Called by:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_pkt\_to\_protocol\_log()}
\label{func_add_pkt_to_protocol_log_remote.c}

{\stt static void add\_pkt\_to\_protocol\_log ( const char* p, enum pkt\_direction direction )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), \_\_inline\_strncpy\_chk(), gettimeofday()} &\\
Called by:\ & add\_incoming\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_incoming_pkt_to_protocol_log}{remote.c}\\
\ & add\_outgoing\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_outgoing_pkt_to_protocol_log}{remote.c}\\
Refs Var:\ & current\_remote\_stats & remote.c & \cxrefvar{current_remote_stats}{remote.c}\\
\ & protocol\_log & remote.c & \cxrefvar{protocol_log}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function async\_remote\_interrupt()}
\label{func_async_remote_interrupt_remote.c}

{\stt static void async\_remote\_interrupt ( gdb\_client\_data arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
Used in:\ & initialize\_sigint\_signal\_handler() & remote.c & \cxreffunc{initialize_sigint_signal_handler}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function bin2hex()}
\label{func_bin2hex_remote.c}

{\stt static int bin2hex ( const char* bin, char* hex, int count )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & tohex() & remote.c & \cxreffunc{tohex}{remote.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & remote\_rcmd() & remote.c & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_store\_registers() & remote.c & \cxreffunc{remote_store_registers}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
\ & store\_register\_using\_P() & remote.c & \cxreffunc{store_register_using_P}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function build\_remote\_gdbarch\_data()}
\label{func_build_remote_gdbarch_data_remote.c}

{\stt static void build\_remote\_gdbarch\_data ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & gdbarch\_addr\_bit() & gdbarch.c & \cxreffunc{gdbarch_addr_bit}{gdbarch.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_address\_size & remote.c & \cxrefvar{remote_address_size}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function check\_binary\_download()}
\label{func_check_binary_download_remote.c}

{\stt static void check\_binary\_download ( CORE\_ADDR addr )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
Refs Var:\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\ & remote\_protocol\_binary\_download & remote.c & \cxrefvar{remote_protocol_binary_download}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cleanup\_sigint\_signal\_handler()}
\label{func_cleanup_sigint_signal_handler_remote.c}

{\stt static void cleanup\_sigint\_signal\_handler ( void* dummy )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & delete\_async\_signal\_handler() & event-loop.c & \cxreffunc{delete_async_signal_handler}{event-loop.c}\\
\ & \cxreftabiiispan{ signal()} &\\
Called by:\ & remote\_async\_terminal\_ours() & remote.c & \cxreffunc{remote_async_terminal_ours}{remote.c}\\
Refs Func:\ & handle\_sigint() & event-top.c & \cxreffunc{handle_sigint}{event-top.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & sigint\_remote\_token & remote.c & \cxrefvar{sigint_remote_token}{remote.c}\\
\ & sigint\_remote\_twice\_token & remote.c & \cxrefvar{sigint_remote_twice_token}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function compare\_sections\_command()}
\label{func_compare_sections_command_remote.c}

{\stt static void compare\_sections\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & crc32() & remote.c & \cxreffunc{crc32}{remote.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & paddr() & utils.c & \cxreffunc{paddr}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xsnprintf() & utils.c & \cxreffunc{xsnprintf}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), bfd\_get\_section\_contents(), strcmp()} &\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & \cxreftabiiispan{ exec\_bfd} &\\
\end{cxreftabiii}


\subsubsection{Local Function copy\_threadref()}
\label{func_copy_threadref_remote.c}

{\stt static void copy\_threadref ( threadref* dest, threadref* src )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & remote\_threadlist\_iterator() & remote.c & \cxreffunc{remote_threadlist_iterator}{remote.c}\\
\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function crc32()}
\label{func_crc32_remote.c}

{\stt static unsigned long crc32 ( unsigned char* buf, int len, unsigned int crc )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & compare\_sections\_command() & remote.c & \cxreffunc{compare_sections_command}{remote.c}\\
Refs Var:\ & crc32\_table & remote.c & \cxrefvar{crc32_table}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dump\_protocol\_log()}
\label{func_dump_protocol_log_remote.c}

{\stt static void dump\_protocol\_log ( const char* message )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
\ & \cxreftabiiispan{ isprint()} &\\
Called by:\ & dump\_packets\_command() & remote.c & \cxreffunc{dump_packets_command}{remote.c}\\
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\ & protocol\_log & remote.c & \cxrefvar{protocol_log}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function end\_remote\_timer()}
\label{func_end_remote_timer_remote.c}

{\stt static void end\_remote\_timer ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), gettimeofday()} &\\
Called by:\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & readchar() & remote.c & \cxreffunc{readchar}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & remote\_stop() & remote.c & \cxreffunc{remote_stop}{remote.c}\\
Refs Var:\ & current\_remote\_stats & remote.c & \cxrefvar{current_remote_stats}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function extended\_remote\_async\_create\_inferior()}
\label{func_extended_remote_async_create_inferior_remote.c}

{\stt static void extended\_remote\_async\_create\_inferior ( char* exec\_file, char* args, char** env, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & clear\_proceed\_status() & infrun.c & \cxreffunc{clear_proceed_status}{infrun.c}\\
\ & extended\_remote\_restart() & remote.c & \cxreffunc{extended_remote_restart}{remote.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & remove\_breakpoints() & breakpoint.c & \cxreffunc{remove_breakpoints}{breakpoint.c}\\
Used in:\ & init\_extended\_async\_remote\_ops() & remote.c & \cxreffunc{init_extended_async_remote_ops}{remote.c}\\
Refs Func:\ & inferior\_event\_handler() & inf-loop.c & \cxreffunc{inferior_event_handler}{inf-loop.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & gdb\_override\_async & target/target.c & \cxrefvar{gdb_override_async}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Local Function extended\_remote\_async\_open()}
\label{func_extended_remote_async_open_remote.c}

{\stt static void extended\_remote\_async\_open ( const char* name, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
Used in:\ & init\_extended\_async\_remote\_ops() & remote.c & \cxreffunc{init_extended_async_remote_ops}{remote.c}\\
Refs Var:\ & extended\_async\_remote\_ops & remote.c & \cxrefvar{extended_async_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function extended\_remote\_create\_inferior()}
\label{func_extended_remote_create_inferior_remote.c}

{\stt static void extended\_remote\_create\_inferior ( char* exec\_file, char* args, char** env, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & clear\_proceed\_status() & infrun.c & \cxreffunc{clear_proceed_status}{infrun.c}\\
\ & extended\_remote\_restart() & remote.c & \cxreffunc{extended_remote_restart}{remote.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & remove\_breakpoints() & breakpoint.c & \cxreffunc{remove_breakpoints}{breakpoint.c}\\
Used in:\ & init\_extended\_remote\_ops() & remote.c & \cxreffunc{init_extended_remote_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function extended\_remote\_mourn()}
\label{func_extended_remote_mourn_remote.c}

{\stt static void extended\_remote\_mourn ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Used in:\ & init\_extended\_async\_remote\_ops() & remote.c & \cxreffunc{init_extended_async_remote_ops}{remote.c}\\
\ & init\_extended\_remote\_ops() & remote.c & \cxreffunc{init_extended_remote_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function extended\_remote\_open()}
\label{func_extended_remote_open_remote.c}

{\stt static void extended\_remote\_open ( const char* name, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
Used in:\ & init\_extended\_remote\_ops() & remote.c & \cxreffunc{init_extended_remote_ops}{remote.c}\\
Refs Var:\ & extended\_remote\_ops & remote.c & \cxrefvar{extended_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function extended\_remote\_restart()}
\label{func_extended_remote_restart_remote.c}

{\stt static void extended\_remote\_restart ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & xsnprintf() & utils.c & \cxreffunc{xsnprintf}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & extended\_remote\_async\_create\_inferior() & remote.c & \cxreffunc{extended_remote_async_create_inferior}{remote.c}\\
\ & extended\_remote\_create\_inferior() & remote.c & \cxreffunc{extended_remote_create_inferior}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fetch\_register\_using\_p()}
\label{func_fetch_register_using_p_remote.c}

{\stt static int fetch\_register\_using\_p ( int regnum )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & regcache\_raw\_supply() & regcache.c & \cxreffunc{regcache_raw_supply}{regcache.c}\\
\ & remote\_send() & remote.c & \cxreffunc{remote_send}{remote.c}\\
\ & set\_register\_cached() & regcache.c & \cxreffunc{set_register_cached}{regcache.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
Refs Var:\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fromhex()}
\label{func_fromhex_remote.c}

{\stt static int fromhex ( int a )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & dump\_protocol\_log() & remote.c & \cxreffunc{dump_protocol_log}{remote.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & remote\_backtrace\_self() & remote.c & \cxreffunc{remote_backtrace_self}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & compare\_sections\_command() & remote.c & \cxreffunc{compare_sections_command}{remote.c}\\
\ & fetch\_register\_using\_p() & remote.c & \cxreffunc{fetch_register_using_p}{remote.c}\\
\ & get\_offsets() & remote.c & \cxreffunc{get_offsets}{remote.c}\\
\ & hex2bin() & remote.c & \cxreffunc{hex2bin}{remote.c}\\
\ & read\_frame() & remote.c & \cxreffunc{read_frame}{remote.c}\\
\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_console\_output() & remote.c & \cxreffunc{remote_console_output}{remote.c}\\
\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_rcmd() & remote.c & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_memory\_packet\_size()}
\label{func_get_memory_packet_size_remote.c}

{\stt static size\_t get\_memory\_packet\_size ( struct memory\_packet\_config* config )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
Called by:\ & get\_memory\_read\_packet\_size() & remote.c & \cxreffunc{get_memory_read_packet_size}{remote.c}\\
\ & get\_memory\_write\_packet\_size() & remote.c & \cxreffunc{get_memory_write_packet_size}{remote.c}\\
\ & show\_memory\_packet\_size() & remote.c & \cxreffunc{show_memory_packet_size}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function get\_memory\_read\_packet\_size()}
\label{func_get_memory_read_packet_size_remote.c}

{\stt static size\_t get\_memory\_read\_packet\_size ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_memory\_packet\_size() & remote.c & \cxreffunc{get_memory_packet_size}{remote.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
Called by:\ & remote\_read\_bytes() & remote.c & \cxreffunc{remote_read_bytes}{remote.c}\\
Refs Var:\ & memory\_read\_packet\_config & remote.c & \cxrefvar{memory_read_packet_config}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function get\_memory\_write\_packet\_size()}
\label{func_get_memory_write_packet_size_remote.c}

{\stt static long get\_memory\_write\_packet\_size ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_memory\_packet\_size() & remote.c & \cxreffunc{get_memory_packet_size}{remote.c}\\
Called by:\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
Refs Var:\ & memory\_write\_packet\_config & remote.c & \cxrefvar{memory_write_packet_config}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_offsets()}
\label{func_get_offsets_remote.c}

{\stt static void get\_offsets ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & executable\_objfile() & objfiles.c & \cxreffunc{executable_objfile}{objfiles.c}\\
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objfile\_relocate() & objfiles.c & \cxreffunc{objfile_relocate}{objfiles.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), strncmp()} &\\
Called by:\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
Refs Var:\ & symfile\_objfile & objfiles.c & \cxrefvar{symfile_objfile}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function get\_remote\_state()}
\label{func_get_remote_state_remote.c}

{\stt static struct remote\_state* get\_remote\_state ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & new\_gdbarch\_data() & gdbarch.c & \cxreffunc{new_gdbarch_data}{gdbarch.c}\\
Called by:\ & check\_binary\_download() & remote.c & \cxreffunc{check_binary_download}{remote.c}\\
\ & compare\_sections\_command() & remote.c & \cxreffunc{compare_sections_command}{remote.c}\\
\ & extended\_remote\_restart() & remote.c & \cxreffunc{extended_remote_restart}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & fetch\_register\_using\_p() & remote.c & \cxreffunc{fetch_register_using_p}{remote.c}\\
\ & get\_memory\_packet\_size() & remote.c & \cxreffunc{get_memory_packet_size}{remote.c}\\
\ & get\_memory\_read\_packet\_size() & remote.c & \cxreffunc{get_memory_read_packet_size}{remote.c}\\
\ & get\_offsets() & remote.c & \cxreffunc{get_offsets}{remote.c}\\
\ & packet\_command() & remote.c & \cxreffunc{packet_command}{remote.c}\\
\ & parse\_threadlist\_response() & remote.c & \cxreffunc{parse_threadlist_response}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\ & remote\_current\_thread() & remote.c & \cxreffunc{remote_current_thread}{remote.c}\\
\ & remote\_detach() & remote.c & \cxreffunc{remote_detach}{remote.c}\\
\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & remote\_get\_thread\_local\_address() & remote.c & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\ & remote\_get\_threadinfo() & remote.c & \cxreffunc{remote_get_threadinfo}{remote.c}\\
\ & remote\_get\_threadlist() & remote.c & \cxreffunc{remote_get_threadlist}{remote.c}\\
\ & remote\_insert\_breakpoint() & remote.c & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_insert\_hw\_breakpoint() & remote.c & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\ & remote\_macosx\_attach() & remote.c & \cxreffunc{remote_macosx_attach}{remote.c}\\
\ & remote\_macosx\_complete\_create\_or\_attach() & remote.c & \cxreffunc{remote_macosx_complete_create_or_attach}{remote.c}\\
\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
\ & remote\_macosx\_get\_all\_image\_infos\_addr() & remote.c & \cxreffunc{remote_macosx_get_all_image_infos_addr}{remote.c}\\
\ & remote\_macosx\_query\_qenvironment\_hex\_packet\_supported() & remote.c & \cxreffunc{remote_macosx_query_qenvironment_hex_packet_supported}{remote.c}\\
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_prepare\_to\_store() & remote.c & \cxreffunc{remote_prepare_to_store}{remote.c}\\
\ & remote\_rcmd() & remote.c & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_remove\_breakpoint() & remote.c & \cxreffunc{remote_remove_breakpoint}{remote.c}\\
\ & remote\_remove\_hw\_breakpoint() & remote.c & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & remote\_store\_registers() & remote.c & \cxreffunc{remote_store_registers}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\ & remote\_vcont\_resume() & remote.c & \cxreffunc{remote_vcont_resume}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
\ & send\_disable\_aslr() & remote.c & \cxreffunc{send_disable_aslr}{remote.c}\\
\ & send\_remote\_max\_payload\_size() & remote.c & \cxreffunc{send_remote_max_payload_size}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_thread() & remote.c & \cxreffunc{set_thread}{remote.c}\\
\ & store\_register\_using\_P() & remote.c & \cxreffunc{store_register_using_P}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & remote\_gdbarch\_data\_handle & remote.c & \cxrefvar{remote_gdbarch_data_handle}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function getpkt\_sane()}
\label{func_getpkt_sane_remote.c}

{\stt static int getpkt\_sane ( char* buf, long sizeof\_buf, int forever )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & add\_incoming\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_incoming_pkt_to_protocol_log}{remote.c}\\
\ & end\_remote\_timer() & remote.c & \cxreffunc{end_remote_timer}{remote.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & fputs\_filtered() & utils.c & \cxreffunc{fputs_filtered}{utils.c}\\
\ & fputstr\_unfiltered() & utils.c & \cxreffunc{fputstr_unfiltered}{utils.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & quit() & utils.c & \cxreffunc{quit}{utils.c}\\
\ & read\_frame() & remote.c & \cxreffunc{read_frame}{remote.c}\\
\ & readchar() & remote.c & \cxreffunc{readchar}{remote.c}\\
\ & serial\_write() & serial.c & \cxreffunc{serial_write}{serial.c}\\
\cxreftabbreak{cxreftabiii}
\ & start\_remote\_timer() & remote.c & \cxreffunc{start_remote_timer}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk()} &\\
Called by:\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & remote\_macosx\_attach() & remote.c & \cxreffunc{remote_macosx_attach}{remote.c}\\
\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
\ & remote\_macosx\_query\_qenvironment\_hex\_packet\_supported() & remote.c & \cxreffunc{remote_macosx_query_qenvironment_hex_packet_supported}{remote.c}\\
Refs Var:\ & current\_remote\_stats & remote.c & \cxrefvar{current_remote_stats}{remote.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\cxreftabbreak{cxreftabiii}
\ & no\_ack\_mode & remote.c & \cxrefvar{no_ack_mode}{remote.c}\\
\ & quit\_flag & utils.c & \cxrefvar{quit_flag}{utils.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\ & remote\_timeout & top.c & \cxrefvar{remote_timeout}{top.c}\\
\ & total\_packets\_received & remote.c & \cxrefvar{total_packets_received}{remote.c}\\
\ & watchdog & maint.c & \cxrefvar{watchdog}{maint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function handle\_remote\_sigint()}
\label{func_handle_remote_sigint_remote.c}

{\stt static void handle\_remote\_sigint ( int sig )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & create\_async\_signal\_handler() & event-loop.c & \cxreffunc{create_async_signal_handler}{event-loop.c}\\
\ & mark\_async\_signal\_handler\_wrapper() & event-top.c & \cxreffunc{mark_async_signal_handler_wrapper}{event-top.c}\\
\ & \cxreftabiiispan{ signal()} &\\
Used in:\ & async\_remote\_interrupt\_twice() & remote.c & \cxreffunc{async_remote_interrupt_twice}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & initialize\_sigint\_signal\_handler() & remote.c & \cxreffunc{initialize_sigint_signal_handler}{remote.c}\\
Refs Func:\ & async\_remote\_interrupt\_twice() & remote.c & \cxreffunc{async_remote_interrupt_twice}{remote.c}\\
\ & handle\_remote\_sigint\_twice() & remote.c & \cxreffunc{handle_remote_sigint_twice}{remote.c}\\
Refs Var:\ & sigint\_remote\_token & remote.c & \cxrefvar{sigint_remote_token}{remote.c}\\
\ & sigint\_remote\_twice\_token & remote.c & \cxrefvar{sigint_remote_twice_token}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function handle\_remote\_sigint\_twice()}
\label{func_handle_remote_sigint_twice_remote.c}

{\stt static void handle\_remote\_sigint\_twice ( int sig )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & create\_async\_signal\_handler() & event-loop.c & \cxreffunc{create_async_signal_handler}{event-loop.c}\\
\ & mark\_async\_signal\_handler\_wrapper() & event-top.c & \cxreffunc{mark_async_signal_handler_wrapper}{event-top.c}\\
\ & \cxreftabiiispan{ signal()} &\\
Used in:\ & handle\_remote\_sigint() & remote.c & \cxreffunc{handle_remote_sigint}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & handle\_sigint() & event-top.c & \cxreffunc{handle_sigint}{event-top.c}\\
\ & inferior\_event\_handler\_wrapper() & inf-loop.c & \cxreffunc{inferior_event_handler_wrapper}{inf-loop.c}\\
Refs Var:\ & sigint\_remote\_twice\_token & remote.c & \cxrefvar{sigint_remote_twice_token}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function hex2bin()}
\label{func_hex2bin_remote.c}

{\stt static int hex2bin ( const char* hex, char* bin, int count )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
Called by:\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_read\_bytes() & remote.c & \cxreffunc{remote_read_bytes}{remote.c}\\
\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function hexnumlen()}
\label{func_hexnumlen_remote.c}

{\stt static int hexnumlen ( unsigned long num )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function hexnumnstr()}
\label{func_hexnumnstr_remote.c}

{\stt static int hexnumnstr ( char* buf, unsigned long num, int width )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function hexnumstr()}
\label{func_hexnumstr_remote.c}

{\stt static int hexnumstr ( char* buf, unsigned long num )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & hexnumlen() & remote.c & \cxreffunc{hexnumlen}{remote.c}\\
\ & hexnumnstr() & remote.c & \cxreffunc{hexnumnstr}{remote.c}\\
Called by:\ & check\_binary\_download() & remote.c & \cxreffunc{check_binary_download}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & fetch\_register\_using\_p() & remote.c & \cxreffunc{fetch_register_using_p}{remote.c}\\
\ & remote\_get\_thread\_local\_address() & remote.c & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\ & remote\_insert\_breakpoint() & remote.c & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\ & remote\_insert\_hw\_breakpoint() & remote.c & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\ & remote\_read\_bytes() & remote.c & \cxreffunc{remote_read_bytes}{remote.c}\\
\ & remote\_remove\_breakpoint() & remote.c & \cxreffunc{remote_remove_breakpoint}{remote.c}\\
\ & remote\_remove\_hw\_breakpoint() & remote.c & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function init\_all\_packet\_configs()}
\label{func_init_all_packet_configs_remote.c}

{\stt static void init\_all\_packet\_configs ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Called by:\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
Refs Var:\ & remote\_protocol\_P & remote.c & \cxrefvar{remote_protocol_P}{remote.c}\\
\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_protocol\_binary\_download & remote.c & \cxrefvar{remote_protocol_binary_download}{remote.c}\\
\ & remote\_protocol\_p & remote.c & \cxrefvar{remote_protocol_p}{remote.c}\\
\ & remote\_protocol\_qGetTLSAddr & remote.c & \cxrefvar{remote_protocol_qGetTLSAddr}{remote.c}\\
\ & remote\_protocol\_qPart\_auxv & remote.c & \cxrefvar{remote_protocol_qPart_auxv}{remote.c}\\
\ & remote\_protocol\_qSymbol & remote.c & \cxrefvar{remote_protocol_qSymbol}{remote.c}\\
\ & remote\_protocol\_vcont & remote.c & \cxrefvar{remote_protocol_vcont}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function init\_extended\_async\_remote\_ops()}
\label{func_init_extended_async_remote_ops_remote.c}

{\stt static void init\_extended\_async\_remote\_ops ( void )}

\smallskip
\begin{cxreftabiii}
Called by:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Func:\ & extended\_remote\_async\_create\_inferior() & remote.c & \cxreffunc{extended_remote_async_create_inferior}{remote.c}\\
\ & extended\_remote\_async\_open() & remote.c & \cxreffunc{extended_remote_async_open}{remote.c}\\
\ & extended\_remote\_mourn() & remote.c & \cxreffunc{extended_remote_mourn}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & extended\_async\_remote\_ops & remote.c & \cxrefvar{extended_async_remote_ops}{remote.c}\\
\ & remote\_async\_ops & remote.c & \cxrefvar{remote_async_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function init\_extended\_remote\_ops()}
\label{func_init_extended_remote_ops_remote.c}

{\stt static void init\_extended\_remote\_ops ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Func:\ & extended\_remote\_create\_inferior() & remote.c & \cxreffunc{extended_remote_create_inferior}{remote.c}\\
\ & extended\_remote\_mourn() & remote.c & \cxreffunc{extended_remote_mourn}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & extended\_remote\_open() & remote.c & \cxreffunc{extended_remote_open}{remote.c}\\
Refs Var:\ & extended\_remote\_ops & remote.c & \cxrefvar{extended_remote_ops}{remote.c}\\
\ & remote\_ops & remote.c & \cxrefvar{remote_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function init\_remote\_async\_ops()}
\label{func_init_remote_async_ops_remote.c}

{\stt static void init\_remote\_async\_ops ( void )}

\smallskip
\begin{cxreftabiii}
Called by:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Func:\ & generic\_load() & symfile.c & \cxreffunc{generic_load}{symfile.c}\\
\ & remote\_async() & remote.c & \cxreffunc{remote_async}{remote.c}\\
\ & remote\_async\_kill() & remote.c & \cxreffunc{remote_async_kill}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_async\_mourn() & remote.c & \cxreffunc{remote_async_mourn}{remote.c}\\
\ & remote\_async\_open() & remote.c & \cxreffunc{remote_async_open}{remote.c}\\
\ & remote\_async\_resume() & remote.c & \cxreffunc{remote_async_resume}{remote.c}\\
\ & remote\_async\_terminal\_inferior() & remote.c & \cxreffunc{remote_async_terminal_inferior}{remote.c}\\
\ & remote\_async\_terminal\_ours() & remote.c & \cxreffunc{remote_async_terminal_ours}{remote.c}\\
\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_can\_async\_p() & remote.c & \cxreffunc{remote_can_async_p}{remote.c}\\
\ & remote\_check\_watch\_resources() & remote.c & \cxreffunc{remote_check_watch_resources}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_close() & remote.c & \cxreffunc{remote_close}{remote.c}\\
\ & remote\_detach() & remote.c & \cxreffunc{remote_detach}{remote.c}\\
\ & remote\_disconnect() & remote.c & \cxreffunc{remote_disconnect}{remote.c}\\
\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & remote\_files\_info() & remote.c & \cxreffunc{remote_files_info}{remote.c}\\
\ & remote\_insert\_breakpoint() & remote.c & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\ & remote\_insert\_hw\_breakpoint() & remote.c & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_is\_async\_p() & remote.c & \cxreffunc{remote_is_async_p}{remote.c}\\
\ & remote\_pid\_to\_str() & remote.c & \cxreffunc{remote_pid_to_str}{remote.c}\\
\ & remote\_prepare\_to\_store() & remote.c & \cxreffunc{remote_prepare_to_store}{remote.c}\\
\ & remote\_rcmd() & remote.c & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_remove\_breakpoint() & remote.c & \cxreffunc{remote_remove_breakpoint}{remote.c}\\
\ & remote\_remove\_hw\_breakpoint() & remote.c & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & remote\_stop() & remote.c & \cxreffunc{remote_stop}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_stopped\_by\_watchpoint() & remote.c & \cxreffunc{remote_stopped_by_watchpoint}{remote.c}\\
\ & remote\_stopped\_data\_address() & remote.c & \cxreffunc{remote_stopped_data_address}{remote.c}\\
\ & remote\_store\_registers() & remote.c & \cxreffunc{remote_store_registers}{remote.c}\\
\ & remote\_thread\_alive() & remote.c & \cxreffunc{remote_thread_alive}{remote.c}\\
\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
\ & remote\_xfer\_memory() & remote.c & \cxreffunc{remote_xfer_memory}{remote.c}\\
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_async\_ops & remote.c & \cxrefvar{remote_async_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function init\_remote\_macosx\_ops()}
\label{func_init_remote_macosx_ops_remote.c}

{\stt static void init\_remote\_macosx\_ops ( void )}

\smallskip
\begin{cxreftabiii}
Called by:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Func:\ & objc\_setup\_safe\_print() & objc-lang.c & \cxreffunc{objc_setup_safe_print}{objc-lang.c}\\
\ & remote\_detach() & remote.c & \cxreffunc{remote_detach}{remote.c}\\
\ & remote\_macosx\_attach() & remote.c & \cxreffunc{remote_macosx_attach}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
\ & remote\_macosx\_mourn() & remote.c & \cxreffunc{remote_macosx_mourn}{remote.c}\\
\ & remote\_macosx\_open() & remote.c & \cxreffunc{remote_macosx_open}{remote.c}\\
\ & \cxreftabiiispan{ dyld\_is\_objfile\_loaded(), dyld\_lookup\_and\_bind\_function(), macosx\_check\_safe\_call(), macosx\_enable\_exception\_callback(), macosx\_find\_exception\_catchpoints(), macosx\_get\_current\_exception\_event(), macosx\_load\_dylib()} &\\
Refs Var:\ & remote\_macosx\_doc & remote.c & \cxrefvar{remote_macosx_doc}{remote.c}\\
\ & remote\_macosx\_longname & remote.c & \cxrefvar{remote_macosx_longname}{remote.c}\\
\ & remote\_macosx\_ops & remote.c & \cxrefvar{remote_macosx_ops}{remote.c}\\
\ & remote\_macosx\_shortname & remote.c & \cxrefvar{remote_macosx_shortname}{remote.c}\\
\ & remote\_ops & remote.c & \cxrefvar{remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function init\_remote\_ops()}
\label{func_init_remote_ops_remote.c}

{\stt static void init\_remote\_ops ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Func:\ & generic\_load() & symfile.c & \cxreffunc{generic_load}{symfile.c}\\
\ & remote\_check\_watch\_resources() & remote.c & \cxreffunc{remote_check_watch_resources}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_close() & remote.c & \cxreffunc{remote_close}{remote.c}\\
\ & remote\_detach() & remote.c & \cxreffunc{remote_detach}{remote.c}\\
\ & remote\_disconnect() & remote.c & \cxreffunc{remote_disconnect}{remote.c}\\
\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & remote\_files\_info() & remote.c & \cxreffunc{remote_files_info}{remote.c}\\
\ & remote\_get\_thread\_local\_address() & remote.c & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\ & remote\_insert\_breakpoint() & remote.c & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\ & remote\_insert\_hw\_breakpoint() & remote.c & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\ & remote\_kill() & remote.c & \cxreffunc{remote_kill}{remote.c}\\
\ & remote\_mourn() & remote.c & \cxreffunc{remote_mourn}{remote.c}\\
\ & remote\_open() & remote.c & \cxreffunc{remote_open}{remote.c}\\
\ & remote\_pid\_to\_str() & remote.c & \cxreffunc{remote_pid_to_str}{remote.c}\\
\ & remote\_prepare\_to\_store() & remote.c & \cxreffunc{remote_prepare_to_store}{remote.c}\\
\ & remote\_rcmd() & remote.c & \cxreffunc{remote_rcmd}{remote.c}\\
\ & remote\_remove\_breakpoint() & remote.c & \cxreffunc{remote_remove_breakpoint}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_remove\_hw\_breakpoint() & remote.c & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
\ & remote\_stop() & remote.c & \cxreffunc{remote_stop}{remote.c}\\
\ & remote\_stopped\_by\_watchpoint() & remote.c & \cxreffunc{remote_stopped_by_watchpoint}{remote.c}\\
\ & remote\_stopped\_data\_address() & remote.c & \cxreffunc{remote_stopped_data_address}{remote.c}\\
\ & remote\_store\_registers() & remote.c & \cxreffunc{remote_store_registers}{remote.c}\\
\ & remote\_thread\_alive() & remote.c & \cxreffunc{remote_thread_alive}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\ & remote\_xfer\_memory() & remote.c & \cxreffunc{remote_xfer_memory}{remote.c}\\
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
Refs Var:\ & remote\_ops & remote.c & \cxrefvar{remote_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function init\_remote\_state()}
\label{func_init_remote_state_remote.c}

{\stt static void* init\_remote\_state ( struct gdbarch* gdbarch )}

\smallskip
\begin{cxreftabiii}
Calls:\ & gdbarch\_deprecated\_register\_byte() & gdbarch.c & \cxreffunc{gdbarch_deprecated_register_byte}{gdbarch.c}\\
\ & gdbarch\_num\_pseudo\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_pseudo_regs}{gdbarch.c}\\
\ & gdbarch\_num\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_regs}{gdbarch.c}\\
\ & gdbarch\_obstack\_zalloc() & gdbarch.c & \cxreffunc{gdbarch_obstack_zalloc}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & initialize\_protocol\_log() & remote.c & \cxreffunc{initialize_protocol_log}{remote.c}\\
\ & register\_size() & regcache.c & \cxreffunc{register_size}{regcache.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & g\_max\_remote\_packet\_size & remote.c & \cxrefvar{g_max_remote_packet_size}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function initialize\_protocol\_log()}
\label{func_initialize_protocol_log_remote.c}

{\stt static void initialize\_protocol\_log ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & init\_remote\_state() & remote.c & \cxreffunc{init_remote_state}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & protocol\_log & remote.c & \cxrefvar{protocol_log}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function initialize\_sigint\_signal\_handler()}
\label{func_initialize_sigint_signal_handler_remote.c}

{\stt static void initialize\_sigint\_signal\_handler ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & create\_async\_signal\_handler() & event-loop.c & \cxreffunc{create_async_signal_handler}{event-loop.c}\\
\ & \cxreftabiiispan{ signal()} &\\
Called by:\ & remote\_async\_terminal\_inferior() & remote.c & \cxreffunc{remote_async_terminal_inferior}{remote.c}\\
Refs Func:\ & async\_remote\_interrupt() & remote.c & \cxreffunc{async_remote_interrupt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & handle\_remote\_sigint() & remote.c & \cxreffunc{handle_remote_sigint}{remote.c}\\
Refs Var:\ & sigint\_remote\_token & remote.c & \cxrefvar{sigint_remote_token}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function interrupt\_query()}
\label{func_interrupt_query_remote.c}

{\stt static void interrupt\_query ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & query() & utils.c & \cxreffunc{query}{utils.c}\\
\ & \cxreftabiiispan{ deprecated\_throw\_reason()} &\\
Called by:\ & async\_remote\_interrupt\_twice() & remote.c & \cxreffunc{async_remote_interrupt_twice}{remote.c}\\
\ & remote\_interrupt\_twice() & remote.c & \cxreffunc{remote_interrupt_twice}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ishex()}
\label{func_ishex_remote.c}

{\stt static int ishex ( int ch, int* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & unpack\_nibble() & remote.c & \cxreffunc{unpack_nibble}{remote.c}\\
\ & unpack\_varlen\_hex() & remote.c & \cxreffunc{unpack_varlen_hex}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function pack\_hex\_byte()}
\label{func_pack_hex_byte_remote.c}

{\stt static char* pack\_hex\_byte ( char* pkt, int byte )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & pack\_int() & remote.c & \cxreffunc{pack_int}{remote.c}\\
\ & pack\_string\_as\_ascii\_hex() & remote.c & \cxreffunc{pack_string_as_ascii_hex}{remote.c}\\
\ & pack\_threadid() & remote.c & \cxreffunc{pack_threadid}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & pack\_threadlist\_request() & remote.c & \cxreffunc{pack_threadlist_request}{remote.c}\\
\ & remote\_macosx\_attach() & remote.c & \cxreffunc{remote_macosx_attach}{remote.c}\\
\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
Refs Var:\ & hexchars & remote.c & \cxrefvar{hexchars}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function pack\_int()}
\label{func_pack_int_remote.c}

{\stt static char* pack\_int ( char* buf, int value )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & pack\_hex\_byte() & remote.c & \cxreffunc{pack_hex_byte}{remote.c}\\
Called by:\ & pack\_threadinfo\_request() & remote.c & \cxreffunc{pack_threadinfo_request}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function pack\_nibble()}
\label{func_pack_nibble_remote.c}

{\stt static char* pack\_nibble ( char* buf, int nibble )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & pack\_threadlist\_request() & remote.c & \cxreffunc{pack_threadlist_request}{remote.c}\\
Refs Var:\ & hexchars & remote.c & \cxrefvar{hexchars}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function pack\_string\_as\_ascii\_hex()}
\label{func_pack_string_as_ascii_hex_remote.c}

{\stt static char* pack\_string\_as\_ascii\_hex ( char* pkt, const char* str, const char* end )}

\smallskip
\begin{cxreftabiii}
Calls:\ & pack\_hex\_byte() & remote.c & \cxreffunc{pack_hex_byte}{remote.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & remote\_macosx\_attach() & remote.c & \cxreffunc{remote_macosx_attach}{remote.c}\\
\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function pack\_threadid()}
\label{func_pack_threadid_remote.c}

{\stt static char* pack\_threadid ( char* pkt, threadref* id )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & pack\_hex\_byte() & remote.c & \cxreffunc{pack_hex_byte}{remote.c}\\
Called by:\ & pack\_threadinfo\_request() & remote.c & \cxreffunc{pack_threadinfo_request}{remote.c}\\
\ & pack\_threadlist\_request() & remote.c & \cxreffunc{pack_threadlist_request}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function pack\_threadinfo\_request()}
\label{func_pack_threadinfo_request_remote.c}

{\stt static char* pack\_threadinfo\_request ( char* pkt, int mode, threadref* id )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & pack\_int() & remote.c & \cxreffunc{pack_int}{remote.c}\\
\ & pack\_threadid() & remote.c & \cxreffunc{pack_threadid}{remote.c}\\
Called by:\ & remote\_get\_threadinfo() & remote.c & \cxreffunc{remote_get_threadinfo}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function pack\_threadlist\_request()}
\label{func_pack_threadlist_request_remote.c}

{\stt static char* pack\_threadlist\_request ( char* pkt, int startflag, int threadcount, threadref* nextthread )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & pack\_hex\_byte() & remote.c & \cxreffunc{pack_hex_byte}{remote.c}\\
\ & pack\_nibble() & remote.c & \cxreffunc{pack_nibble}{remote.c}\\
\ & pack\_threadid() & remote.c & \cxreffunc{pack_threadid}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & remote\_get\_threadlist() & remote.c & \cxreffunc{remote_get_threadlist}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function packet\_command()}
\label{func_packet_command_remote.c}

{\stt static void packet\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_packet() & remote.c & \cxreffunc{print_packet}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & puts\_filtered() & utils.c & \cxreffunc{puts_filtered}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function packet\_ok()}
\label{func_packet_ok_remote.c}

{\stt static enum packet\_result packet\_ok ( const char* buf, struct packet\_config* config )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & gdb\_check\_fatal() & utils.c & \cxreffunc{gdb_check_fatal}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ isxdigit()} &\\
Called by:\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\ & remote\_get\_thread\_local\_address() & remote.c & \cxreffunc{remote_get_thread_local_address}{remote.c}\\
\ & remote\_insert\_breakpoint() & remote.c & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\ & remote\_insert\_hw\_breakpoint() & remote.c & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\ & remote\_remove\_hw\_breakpoint() & remote.c & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & remote\_vcont\_probe() & remote.c & \cxreffunc{remote_vcont_probe}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_xfer\_partial() & remote.c & \cxreffunc{remote_xfer_partial}{remote.c}\\
Refs Var:\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function packet\_reg\_from\_pnum()}
\label{func_packet_reg_from_pnum_remote.c}

{\stt static struct packet\_reg* packet\_reg\_from\_pnum ( struct remote\_state* rs, long pnum )}

\smallskip
\begin{cxreftabiii}
Calls:\ & gdbarch\_num\_pseudo\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_pseudo_regs}{gdbarch.c}\\
\ & gdbarch\_num\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_regs}{gdbarch.c}\\
Called by:\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function packet\_reg\_from\_regnum()}
\label{func_packet_reg_from_regnum_remote.c}

{\stt static struct packet\_reg* packet\_reg\_from\_regnum ( struct remote\_state* rs, long regnum )}

\smallskip
\begin{cxreftabiii}
Calls:\ & gdbarch\_num\_pseudo\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_pseudo_regs}{gdbarch.c}\\
\ & gdbarch\_num\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_regs}{gdbarch.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & store\_register\_using\_P() & remote.c & \cxreffunc{store_register_using_P}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function parse\_threadlist\_response()}
\label{func_parse_threadlist_response_remote.c}

{\stt static int parse\_threadlist\_response ( char* pkt, int result\_limit, threadref* original\_echo, threadref* resultlist, int* doneflag )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & unpack\_byte() & remote.c & \cxreffunc{unpack_byte}{remote.c}\\
\ & unpack\_nibble() & remote.c & \cxreffunc{unpack_nibble}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & unpack\_threadid() & remote.c & \cxreffunc{unpack_threadid}{remote.c}\\
Called by:\ & remote\_get\_threadlist() & remote.c & \cxreffunc{remote_get_threadlist}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function print\_packet()}
\label{func_print_packet_remote.c}

{\stt static void print\_packet ( const char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & fputstr\_filtered() & utils.c & \cxreffunc{fputstr_filtered}{utils.c}\\
\ & puts\_filtered() & utils.c & \cxreffunc{puts_filtered}{utils.c}\\
Called by:\ & packet\_command() & remote.c & \cxreffunc{packet_command}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function putpkt\_binary()}
\label{func_putpkt_binary_remote.c}

{\stt static int putpkt\_binary ( const char* buf, int cnt )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & add\_outgoing\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_outgoing_pkt_to_protocol_log}{remote.c}\\
\ & dump\_protocol\_log() & remote.c & \cxreffunc{dump_protocol_log}{remote.c}\\
\ & end\_remote\_timer() & remote.c & \cxreffunc{end_remote_timer}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & fputc\_unfiltered() & utils.c & \cxreffunc{fputc_unfiltered}{utils.c}\\
\ & fputstrn\_unfiltered() & utils.c & \cxreffunc{fputstrn_unfiltered}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & perror\_with\_name() & utils.c & \cxreffunc{perror_with_name}{utils.c}\\
\ & putchar\_unfiltered() & utils.c & \cxreffunc{putchar_unfiltered}{utils.c}\\
\ & read\_frame() & remote.c & \cxreffunc{read_frame}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & readchar() & remote.c & \cxreffunc{readchar}{remote.c}\\
\ & remote\_backtrace\_self() & remote.c & \cxreffunc{remote_backtrace_self}{remote.c}\\
\ & serial\_write() & serial.c & \cxreffunc{serial_write}{serial.c}\\
\ & start\_remote\_timer() & remote.c & \cxreffunc{start_remote_timer}{remote.c}\\
\ & tohex() & remote.c & \cxreffunc{tohex}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & check\_binary\_download() & remote.c & \cxreffunc{check_binary_download}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_remote\_stats & remote.c & \cxrefvar{current_remote_stats}{remote.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & no\_ack\_mode & remote.c & \cxrefvar{no_ack_mode}{remote.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\ & remote\_timeout & top.c & \cxrefvar{remote_timeout}{top.c}\\
\ & total\_packets\_sent & remote.c & \cxrefvar{total_packets_sent}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_frame()}
\label{func_read_frame_remote.c}

{\stt static long read\_frame ( char* buf, long sizeof\_buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
\ & fputs\_filtered() & utils.c & \cxreffunc{fputs_filtered}{utils.c}\\
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & puts\_filtered() & utils.c & \cxreffunc{puts_filtered}{utils.c}\\
\ & readchar() & remote.c & \cxreffunc{readchar}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
Refs Var:\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & no\_ack\_mode & remote.c & \cxrefvar{no_ack_mode}{remote.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_timeout & top.c & \cxrefvar{remote_timeout}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function readchar()}
\label{func_readchar_remote.c}

{\stt static int readchar ( int timeout )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & end\_remote\_timer() & remote.c & \cxreffunc{end_remote_timer}{remote.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & perror\_with\_name() & utils.c & \cxreffunc{perror_with_name}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & serial\_readchar() & serial.c & \cxreffunc{serial_readchar}{serial.c}\\
\ & start\_remote\_timer() & remote.c & \cxreffunc{start_remote_timer}{remote.c}\\
Called by:\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & read\_frame() & remote.c & \cxreffunc{read_frame}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function record\_currthread()}
\label{func_record_currthread_remote.c}

{\stt static void record\_currthread ( int currthread )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & add\_thread() & thread.c & \cxreffunc{add_thread}{thread.c}\\
\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & ptid\_build() & infrun.c & \cxreffunc{ptid_build}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
Called by:\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & general\_thread & remote.c & \cxrefvar{general_thread}{remote.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_address\_masked()}
\label{func_remote_address_masked_remote.c}

{\stt static CORE\_ADDR remote\_address\_masked ( CORE\_ADDR addr )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & remote\_insert\_breakpoint() & remote.c & \cxreffunc{remote_insert_breakpoint}{remote.c}\\
\ & remote\_insert\_hw\_breakpoint() & remote.c & \cxreffunc{remote_insert_hw_breakpoint}{remote.c}\\
\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_read\_bytes() & remote.c & \cxreffunc{remote_read_bytes}{remote.c}\\
\ & remote\_remove\_breakpoint() & remote.c & \cxreffunc{remote_remove_breakpoint}{remote.c}\\
\ & remote\_remove\_hw\_breakpoint() & remote.c & \cxreffunc{remote_remove_hw_breakpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
Refs Var:\ & remote\_address\_size & remote.c & \cxrefvar{remote_address_size}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_async()}
\label{func_remote_async_remote.c}

{\stt static void remote\_async ( void (*callback)(enum inferior\_event\_type event\_type,void* context), void* context )}

\smallskip
\begin{cxreftabiii}
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & serial\_async() & serial.c & \cxreffunc{serial_async}{serial.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Var:\ & async\_client\_callback & remote.c & \cxrefvar{async_client_callback}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & async\_client\_context & remote.c & \cxrefvar{async_client_context}{remote.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & remote\_async\_serial\_handler & remote.c & \cxrefvar{remote_async_serial_handler}{remote.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_async\_kill()}
\label{func_remote_async_kill_remote.c}

{\stt static void remote\_async\_kill ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & serial\_async() & serial.c & \cxreffunc{serial_async}{serial.c}\\
\ & \cxreftabiiispan{ catch\_errors()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Func:\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & kill\_kludge & remote.c & \cxrefvar{kill_kludge}{remote.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_async\_mourn()}
\label{func_remote_async_mourn_remote.c}

{\stt static void remote\_async\_mourn ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & remote\_mourn\_1() & remote.c & \cxreffunc{remote_mourn_1}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Var:\ & remote\_async\_ops & remote.c & \cxrefvar{remote_async_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_async\_open()}
\label{func_remote_async_open_remote.c}

{\stt static void remote\_async\_open ( const char* name, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Var:\ & remote\_async\_ops & remote.c & \cxrefvar{remote_async_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_async\_resume()}
\label{func_remote_async_resume_remote.c}

{\stt static void remote\_async\_resume ( ptid\_t ptid, int step, enum target\_signal siggnal )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Func:\ & inferior\_event\_handler() & inf-loop.c & \cxreffunc{inferior_event_handler}{inf-loop.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & gdb\_override\_async & target/target.c & \cxrefvar{gdb_override_async}{target/target.c}\\
\ & target\_executing & top.c & \cxrefvar{target_executing}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_async\_serial\_handler()}
\label{func_remote_async_serial_handler_remote.c}

{\stt static void remote\_async\_serial\_handler ( struct serial* scb, void* context )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ async\_client\_callback()} &\\
Refs Var:\ & async\_client\_context & remote.c & \cxrefvar{async_client_context}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_async\_terminal\_inferior()}
\label{func_remote_async_terminal_inferior_remote.c}

{\stt static void remote\_async\_terminal\_inferior ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & delete\_file\_handler() & event-loop.c & \cxreffunc{delete_file_handler}{event-loop.c}\\
\ & initialize\_sigint\_signal\_handler() & remote.c & \cxreffunc{initialize_sigint_signal_handler}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Var:\ & input\_fd & event-top.c & \cxrefvar{input_fd}{event-top.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_async\_terminal\_ours\_p & remote.c & \cxrefvar{remote_async_terminal_ours_p}{remote.c}\\
\ & sync\_execution & infrun.c & \cxrefvar{sync_execution}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_async\_terminal\_ours()}
\label{func_remote_async_terminal_ours_remote.c}

{\stt static void remote\_async\_terminal\_ours ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & add\_file\_handler() & event-loop.c & \cxreffunc{add_file_handler}{event-loop.c}\\
\ & cleanup\_sigint\_signal\_handler() & remote.c & \cxreffunc{cleanup_sigint_signal_handler}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Func:\ & stdin\_event\_handler() & event-top.c & \cxreffunc{stdin_event_handler}{event-top.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & input\_fd & event-top.c & \cxrefvar{input_fd}{event-top.c}\\
\ & remote\_async\_terminal\_ours\_p & remote.c & \cxrefvar{remote_async_terminal_ours_p}{remote.c}\\
\ & sync\_execution & infrun.c & \cxrefvar{sync_execution}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_async\_wait()}
\label{func_remote_async_wait_remote.c}

{\stt static ptid\_t remote\_async\_wait ( ptid\_t ptid, struct target\_waitstatus* status, gdb\_client\_data client\_data )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hex2bin() & remote.c & \cxreffunc{hex2bin}{remote.c}\\
\ & packet\_reg\_from\_pnum() & remote.c & \cxreffunc{packet_reg_from_pnum}{remote.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & ptid\_build() & infrun.c & \cxreffunc{ptid_build}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & record\_currthread() & remote.c & \cxreffunc{record_currthread}{remote.c}\\
\ & regcache\_raw\_supply() & regcache.c & \cxreffunc{regcache_raw_supply}{regcache.c}\\
\cxreftabbreak{cxreftabiii}
\ & register\_size() & regcache.c & \cxreffunc{register_size}{regcache.c}\\
\ & remote\_console\_output() & remote.c & \cxreffunc{remote_console_output}{remote.c}\\
\ & remote\_fileio\_request() & remote-fileio.c & \cxreffunc{remote_fileio_request}{remote-fileio.c}\\
\ & unpack\_varlen\_hex() & remote.c & \cxreffunc{unpack_varlen_hex}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), signal(), strchr(), strlen(), strncmp(), strtol(), target\_signal\_to\_name()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Func:\ & remote\_interrupt() & remote.c & \cxreffunc{remote_interrupt}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & deprecated\_target\_wait\_loop\_hook & remote.c & \cxrefvar{deprecated_target_wait_loop_hook}{remote.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & kill\_kludge & remote.c & \cxrefvar{kill_kludge}{remote.c}\\
\ & last\_sent\_signal & remote.c & \cxrefvar{last_sent_signal}{remote.c}\\
\ & last\_sent\_step & remote.c & \cxrefvar{last_sent_step}{remote.c}\\
\ & ofunc & remote.c & \cxrefvar{ofunc}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_stopped\_by\_watchpoint\_p & remote.c & \cxrefvar{remote_stopped_by_watchpoint_p}{remote.c}\\
\ & remote\_watch\_data\_address & remote.c & \cxrefvar{remote_watch_data_address}{remote.c}\\
\ & wait\_forever\_enabled\_p & remote.c & \cxrefvar{wait_forever_enabled_p}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_backtrace\_self()}
\label{func_remote_backtrace_self_remote.c}

{\stt static void remote\_backtrace\_self ( const char* message )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
\ & \cxreftabiiispan{ backtrace(), backtrace\_symbols\_fd()} &\\
Called by:\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
Refs Var:\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_can\_async\_p()}
\label{func_remote_can_async_p_remote.c}

{\stt static int remote\_can\_async\_p ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & serial\_can\_async\_p() & serial.c & \cxreffunc{serial_can_async_p}{serial.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_check\_symbols()}
\label{func_remote_check_symbols_remote.c}

{\stt static void remote\_check\_symbols ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hex2bin() & remote.c & \cxreffunc{hex2bin}{remote.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\cxreftabbreak{cxreftabiii}
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & xsnprintf() & utils.c & \cxreffunc{xsnprintf}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), strlen(), strncmp()} &\\
Called by:\ & remote\_macosx\_complete\_create\_or\_attach() & remote.c & \cxreffunc{remote_macosx_complete_create_or_attach}{remote.c}\\
\ & remote\_macosx\_open() & remote.c & \cxreffunc{remote_macosx_open}{remote.c}\\
\ & remote\_new\_objfile() & remote.c & \cxreffunc{remote_new_objfile}{remote.c}\\
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_protocol\_qSymbol & remote.c & \cxrefvar{remote_protocol_qSymbol}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_check\_watch\_resources()}
\label{func_remote_check_watch_resources_remote.c}

{\stt static int remote\_check\_watch\_resources ( int type, int cnt, int ot )}

\smallskip
\begin{cxreftabiii}
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & remote\_hw\_breakpoint\_limit & remote.c & \cxrefvar{remote_hw_breakpoint_limit}{remote.c}\\
\ & remote\_hw\_watchpoint\_limit & remote.c & \cxrefvar{remote_hw_watchpoint_limit}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_close()}
\label{func_remote_close_remote.c}

{\stt static void remote\_close ( int quitting )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & serial\_close() & serial.c & \cxreffunc{serial_close}{serial.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_current\_thread()}
\label{func_remote_current_thread_remote.c}

{\stt static ptid\_t remote\_current\_thread ( ptid\_t oldpid )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), strtoul()} &\\
Called by:\ & remote\_find\_new\_threads() & remote.c & \cxreffunc{remote_find_new_threads}{remote.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_detach()}
\label{func_remote_detach_remote.c}

{\stt static void remote\_detach ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & puts\_filtered() & utils.c & \cxreffunc{puts_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_send() & remote.c & \cxreffunc{remote_send}{remote.c}\\
\ & serial\_async() & serial.c & \cxreffunc{serial_async}{serial.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_macosx\_ops() & remote.c & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_disconnect()}
\label{func_remote_disconnect_remote.c}

{\stt static void remote\_disconnect ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & puts\_filtered() & utils.c & \cxreffunc{puts_filtered}{utils.c}\\
\ & serial\_async() & serial.c & \cxreffunc{serial_async}{serial.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_fetch\_registers()}
\label{func_remote_fetch_registers_remote.c}

{\stt static void remote\_fetch\_registers ( int regnum )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & fetch\_register\_using\_p() & remote.c & \cxreffunc{fetch_register_using_p}{remote.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\ & gdbarch\_num\_pseudo\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_pseudo_regs}{gdbarch.c}\\
\ & gdbarch\_num\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_regs}{gdbarch.c}\\
\ & gdbarch\_register\_bytes\_ok() & gdbarch.c & \cxreffunc{gdbarch_register_bytes_ok}{gdbarch.c}\\
\ & gdbarch\_register\_bytes\_ok\_p() & gdbarch.c & \cxreffunc{gdbarch_register_bytes_ok_p}{gdbarch.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & packet\_reg\_from\_regnum() & remote.c & \cxreffunc{packet_reg_from_regnum}{remote.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & regcache\_raw\_supply() & regcache.c & \cxreffunc{regcache_raw_supply}{regcache.c}\\
\ & remote\_send() & remote.c & \cxreffunc{remote_send}{remote.c}\\
\ & set\_register\_cached() & regcache.c & \cxreffunc{set_register_cached}{regcache.c}\\
\ & set\_thread() & remote.c & \cxreffunc{set_thread}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), strlen()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & register\_bytes\_found & remote.c & \cxrefvar{register_bytes_found}{remote.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\ & remote\_protocol\_p & remote.c & \cxrefvar{remote_protocol_p}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_files\_info()}
\label{func_remote_files_info_remote.c}

{\stt static void remote\_files\_info ( struct target\_ops* ignore )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & puts\_filtered() & utils.c & \cxreffunc{puts_filtered}{utils.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_find\_new\_threads()}
\label{func_remote_find_new_threads_remote.c}

{\stt static void remote\_find\_new\_threads ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & remote\_current\_thread() & remote.c & \cxreffunc{remote_current_thread}{remote.c}\\
\ & remote\_threadlist\_iterator() & remote.c & \cxreffunc{remote_threadlist_iterator}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & remote\_threads\_info() & remote.c & \cxreffunc{remote_threads_info}{remote.c}\\
Refs Func:\ & remote\_newthread\_step() & remote.c & \cxreffunc{remote_newthread_step}{remote.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_get\_thread\_local\_address()}
\label{func_remote_get_thread_local_address_remote.c}

{\stt static CORE\_ADDR remote\_get\_thread\_local\_address ( ptid\_t ptid, CORE\_ADDR lm, CORE\_ADDR offset )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & unpack\_varlen\_hex() & remote.c & \cxreffunc{unpack_varlen_hex}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), strlen(), throw\_error()} &\\
Used in:\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & remote\_protocol\_qGetTLSAddr & remote.c & \cxrefvar{remote_protocol_qGetTLSAddr}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_get\_threadinfo()}
\label{func_remote_get_threadinfo_remote.c}

{\stt static int remote\_get\_threadinfo ( threadref* threadid, int fieldset, struct gdb\_ext\_thread\_info* info )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & pack\_threadinfo\_request() & remote.c & \cxreffunc{pack_threadinfo_request}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & remote\_threads\_extra\_info() & remote.c & \cxreffunc{remote_threads_extra_info}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_get\_threadlist()}
\label{func_remote_get_threadlist_remote.c}

{\stt static int remote\_get\_threadlist ( int startflag, threadref* nextthread, int result\_limit, int* done, int* result\_count, threadref* threadlist )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & pack\_threadlist\_request() & remote.c & \cxreffunc{pack_threadlist_request}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_threadlist\_response() & remote.c & \cxreffunc{parse_threadlist_response}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & threadmatch() & remote.c & \cxreffunc{threadmatch}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & remote\_threadlist\_iterator() & remote.c & \cxreffunc{remote_threadlist_iterator}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_insert\_breakpoint()}
\label{func_remote_insert_breakpoint_remote.c}

{\stt static int remote\_insert\_breakpoint ( CORE\_ADDR addr, bfd\_byte* contents\_cache )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & gdbarch\_breakpoint\_from\_pc() & gdbarch.c & \cxreffunc{gdbarch_breakpoint_from_pc}{gdbarch.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & memory\_insert\_breakpoint() & mem-break.c & \cxreffunc{memory_insert_breakpoint}{mem-break.c}\\
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_address\_masked() & remote.c & \cxreffunc{remote_address_masked}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_insert\_hw\_breakpoint()}
\label{func_remote_insert_hw_breakpoint_remote.c}

{\stt static int remote\_insert\_hw\_breakpoint ( CORE\_ADDR addr, gdb\_byte* shadow )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_breakpoint\_from\_pc() & gdbarch.c & \cxreffunc{gdbarch_breakpoint_from_pc}{gdbarch.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_address\_masked() & remote.c & \cxreffunc{remote_address_masked}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_insert\_watchpoint()}
\label{func_remote_insert_watchpoint_remote.c}

{\stt static int remote\_insert\_watchpoint ( CORE\_ADDR addr, int len, int type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_address\_masked() & remote.c & \cxreffunc{remote_address_masked}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & watchpoint\_to\_Z\_packet() & remote.c & \cxreffunc{watchpoint_to_Z_packet}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), strchr()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_interrupt()}
\label{func_remote_interrupt_remote.c}

{\stt static void remote\_interrupt ( int signo )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & \cxreftabiiispan{ signal()} &\\
Used in:\ & remote\_async\_wait() & remote.c & \cxreffunc{remote_async_wait}{remote.c}\\
\ & remote\_interrupt\_twice() & remote.c & \cxreffunc{remote_interrupt_twice}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_wait() & remote.c & \cxreffunc{remote_wait}{remote.c}\\
Refs Func:\ & remote\_interrupt\_twice() & remote.c & \cxreffunc{remote_interrupt_twice}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_interrupt\_twice()}
\label{func_remote_interrupt_twice_remote.c}

{\stt static void remote\_interrupt\_twice ( int signo )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & interrupt\_query() & remote.c & \cxreffunc{interrupt_query}{remote.c}\\
\ & \cxreftabiiispan{ signal()} &\\
Used in:\ & remote\_interrupt() & remote.c & \cxreffunc{remote_interrupt}{remote.c}\\
Refs Func:\ & remote\_interrupt() & remote.c & \cxreffunc{remote_interrupt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & ofunc & remote.c & \cxrefvar{ofunc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_is\_async\_p()}
\label{func_remote_is_async_p_remote.c}

{\stt static int remote\_is\_async\_p ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & serial\_is\_async\_p() & serial.c & \cxreffunc{serial_is_async_p}{serial.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_kill()}
\label{func_remote_kill_remote.c}

{\stt static void remote\_kill ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & \cxreftabiiispan{ catch\_errors()} &\\
Used in:\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Func:\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & kill\_kludge & remote.c & \cxrefvar{kill_kludge}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_macosx\_complete\_create\_or\_attach()}
\label{func_remote_macosx_complete_create_or_attach_remote.c}

{\stt static void remote\_macosx\_complete\_create\_or\_attach ( int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & observer\_notify\_inferior\_created() & observer.c & \cxreffunc{observer_notify_inferior_created}{observer.c}\\
\ & pop\_target() & target/target.c & \cxreffunc{pop_target}{target/target.c}\\
\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_macosx\_get\_all\_image\_infos\_addr() & remote.c & \cxreffunc{remote_macosx_get_all_image_infos_addr}{remote.c}\\
\ & \cxreftabiiispan{ catch\_exception(), macosx\_dyld\_create\_inferior\_hook(), macosx\_solib\_add(), throw\_exception()} &\\
Called by:\ & remote\_macosx\_attach() & remote.c & \cxreffunc{remote_macosx_attach}{remote.c}\\
\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
Refs Func:\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
Refs Var:\ & auto\_solib\_add & symfile.c & \cxrefvar{auto_solib_add}{symfile.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & symfile\_objfile & objfiles.c & \cxrefvar{symfile_objfile}{objfiles.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ exec\_bfd} &\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_macosx\_mourn()}
\label{func_remote_macosx_mourn_remote.c}

{\stt static void remote\_macosx\_mourn ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & remote\_mourn\_1() & remote.c & \cxreffunc{remote_mourn_1}{remote.c}\\
\ & \cxreftabiiispan{ macosx\_dyld\_mourn\_inferior()} &\\
Used in:\ & init\_remote\_macosx\_ops() & remote.c & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
Refs Var:\ & remote\_macosx\_ops & remote.c & \cxrefvar{remote_macosx_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_macosx\_open()}
\label{func_remote_macosx_open_remote.c}

{\stt static void remote\_macosx\_open ( const char* name, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\ & remote\_macosx\_get\_all\_image\_infos\_addr() & remote.c & \cxreffunc{remote_macosx_get_all_image_infos_addr}{remote.c}\\
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ macosx\_dyld\_create\_inferior\_hook(), macosx\_solib\_add()} &\\
Called by:\ & push\_remote\_macosx\_target() & remote.c & \cxreffunc{push_remote_macosx_target}{remote.c}\\
Used in:\ & init\_remote\_macosx\_ops() & remote.c & \cxreffunc{init_remote_macosx_ops}{remote.c}\\
Refs Var:\ & auto\_solib\_add & symfile.c & \cxrefvar{auto_solib_add}{symfile.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & null\_ptid & infrun.c & \cxrefvar{null_ptid}{infrun.c}\\
\ & remote\_macosx\_ops & remote.c & \cxrefvar{remote_macosx_ops}{remote.c}\\
\ & symfile\_objfile & objfiles.c & \cxrefvar{symfile_objfile}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ exec\_bfd} &\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_macosx\_query\_qenvironment\_hex\_packet\_supported()}
\label{func_remote_macosx_query_qenvironment_hex_packet_supported_remote.c}

{\stt static int remote\_macosx\_query\_qenvironment\_hex\_packet\_supported ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
Refs Var:\ & remote\_timeout & top.c & \cxrefvar{remote_timeout}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_mourn()}
\label{func_remote_mourn_remote.c}

{\stt static void remote\_mourn ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & remote\_mourn\_1() & remote.c & \cxreffunc{remote_mourn_1}{remote.c}\\
Used in:\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & remote\_ops & remote.c & \cxrefvar{remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_mourn\_1()}
\label{func_remote_mourn_1_remote.c}

{\stt static void remote\_mourn\_1 ( struct target\_ops* target )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & generic\_mourn\_inferior() & target/target.c & \cxreffunc{generic_mourn_inferior}{target/target.c}\\
\ & unpush\_target() & target/target.c & \cxreffunc{unpush_target}{target/target.c}\\
Called by:\ & remote\_async\_mourn() & remote.c & \cxreffunc{remote_async_mourn}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_macosx\_mourn() & remote.c & \cxreffunc{remote_macosx_mourn}{remote.c}\\
\ & remote\_mourn() & remote.c & \cxreffunc{remote_mourn}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_new\_objfile()}
\label{func_remote_new_objfile_remote.c}

{\stt static void remote\_new\_objfile ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Calls:\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\ & \cxreftabiiispan{ remote\_new\_objfile\_chain()} &\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\ & remote\_new\_objfile\_chain & remote.c & \cxrefvar{remote_new_objfile_chain}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_newthread\_step()}
\label{func_remote_newthread_step_remote.c}

{\stt static int remote\_newthread\_step ( threadref* ref, void* context )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & add\_thread() & thread.c & \cxreffunc{add_thread}{thread.c}\\
\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & ptid\_build() & infrun.c & \cxreffunc{ptid_build}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & threadref\_to\_int() & remote.c & \cxreffunc{threadref_to_int}{remote.c}\\
Used in:\ & remote\_find\_new\_threads() & remote.c & \cxreffunc{remote_find_new_threads}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_open()}
\label{func_remote_open_remote.c}

{\stt static void remote\_open ( const char* name, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
Called by:\ & push\_remote\_target() & remote.c & \cxreffunc{push_remote_target}{remote.c}\\
Used in:\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_ops & remote.c & \cxrefvar{remote_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_open\_1()}
\label{func_remote_open_1_remote.c}

{\stt static void remote\_open\_1 ( const char* name, int from\_tty, struct target\_ops* target, int extended\_p, int async\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_all\_packet\_configs() & remote.c & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & no\_shared\_libraries() & solib.c & \cxreffunc{no_shared_libraries}{solib.c}\\
\ & observer\_notify\_inferior\_created() & observer.c & \cxreffunc{observer_notify_inferior_created}{observer.c}\\
\ & perror\_with\_name() & utils.c & \cxreffunc{perror_with_name}{utils.c}\\
\ & pop\_target() & target/target.c & \cxreffunc{pop_target}{target/target.c}\\
\ & ptid\_build() & infrun.c & \cxreffunc{ptid_build}{infrun.c}\\
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\ & push\_target() & target/target.c & \cxreffunc{push_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & puts\_filtered() & utils.c & \cxreffunc{puts_filtered}{utils.c}\\
\ & re\_enable\_breakpoints\_in\_shlibs() & breakpoint.c & \cxreffunc{re_enable_breakpoints_in_shlibs}{breakpoint.c}\\
\ & remote\_check\_symbols() & remote.c & \cxreffunc{remote_check_symbols}{remote.c}\\
\ & remote\_serial\_open() & remote.c & \cxreffunc{remote_serial_open}{remote.c}\\
\ & reopen\_exec\_file() & corefile.c & \cxreffunc{reopen_exec_file}{corefile.c}\\
\ & reread\_symbols() & symfile.c & \cxreffunc{reread_symbols}{symfile.c}\\
\ & serial\_close() & serial.c & \cxreffunc{serial_close}{serial.c}\\
\cxreftabbreak{cxreftabiii}
\ & serial\_flush\_input() & serial.c & \cxreffunc{serial_flush_input}{serial.c}\\
\ & serial\_raw() & serial.c & \cxreffunc{serial_raw}{serial.c}\\
\ & serial\_setbaudrate() & serial.c & \cxreffunc{serial_setbaudrate}{serial.c}\\
\ & solib\_create\_inferior\_hook() & solib.c & \cxreffunc{solib_create_inferior_hook}{solib.c}\\
\ & target\_preopen() & target/target.c & \cxreffunc{target_preopen}{target/target.c}\\
\ & unpush\_target() & target/target.c & \cxreffunc{unpush_target}{target/target.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), catch\_exception(), exhaustive\_search\_for\_kernel\_in\_mem(), strcmp(), throw\_exception()} &\\
Called by:\ & extended\_remote\_async\_open() & remote.c & \cxreffunc{extended_remote_async_open}{remote.c}\\
\ & extended\_remote\_open() & remote.c & \cxreffunc{extended_remote_open}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_async\_open() & remote.c & \cxreffunc{remote_async_open}{remote.c}\\
\ & remote\_macosx\_open() & remote.c & \cxreffunc{remote_macosx_open}{remote.c}\\
\ & remote\_open() & remote.c & \cxreffunc{remote_open}{remote.c}\\
Refs Func:\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
Refs Var:\ & baud\_rate & top.c & \cxrefvar{baud_rate}{top.c}\\
\ & continue\_thread & remote.c & \cxrefvar{continue_thread}{remote.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & general\_thread & remote.c & \cxrefvar{general_thread}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & null\_ptid & infrun.c & \cxrefvar{null_ptid}{infrun.c}\\
\ & remote\_async\_terminal\_ours\_p & remote.c & \cxrefvar{remote_async_terminal_ours_p}{remote.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\ & symfile\_objfile & objfiles.c & \cxrefvar{symfile_objfile}{objfiles.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\ & use\_threadextra\_query & remote.c & \cxrefvar{use_threadextra_query}{remote.c}\\
\ & use\_threadinfo\_query & remote.c & \cxrefvar{use_threadinfo_query}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & wait\_forever\_enabled\_p & remote.c & \cxrefvar{wait_forever_enabled_p}{remote.c}\\
\ & \cxreftabiiispan{ exec\_bfd} &\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_pid\_to\_str()}
\label{func_remote_pid_to_str_remote.c}

{\stt static char* remote\_pid\_to\_str ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & xsnprintf() & utils.c & \cxreffunc{xsnprintf}{utils.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_prepare\_to\_store()}
\label{func_remote_prepare_to_store_remote.c}

{\stt static void remote\_prepare\_to\_store ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & gdbarch\_num\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_regs}{gdbarch.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & regcache\_raw\_read() & regcache.c & \cxreffunc{regcache_raw_read}{regcache.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\ & remote\_protocol\_P & remote.c & \cxrefvar{remote_protocol_P}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_rcmd()}
\label{func_remote_rcmd_remote.c}

{\stt static void remote\_rcmd ( const char* command, struct ui\_file* outbuf )}

\smallskip
\begin{cxreftabiii}
Calls:\ & bin2hex() & remote.c & \cxreffunc{bin2hex}{remote.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & fputc\_unfiltered() & utils.c & \cxreffunc{fputc_unfiltered}{utils.c}\\
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_console\_output() & remote.c & \cxreffunc{remote_console_output}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), isdigit(), strchr(), strcmp(), strlen()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_remove\_breakpoint()}
\label{func_remote_remove_breakpoint_remote.c}

{\stt static int remote\_remove\_breakpoint ( CORE\_ADDR addr, bfd\_byte* contents\_cache )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & gdbarch\_breakpoint\_from\_pc() & gdbarch.c & \cxreffunc{gdbarch_breakpoint_from_pc}{gdbarch.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & memory\_remove\_breakpoint() & mem-break.c & \cxreffunc{memory_remove_breakpoint}{mem-break.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_address\_masked() & remote.c & \cxreffunc{remote_address_masked}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_remove\_hw\_breakpoint()}
\label{func_remote_remove_hw_breakpoint_remote.c}

{\stt static int remote\_remove\_hw\_breakpoint ( CORE\_ADDR addr, gdb\_byte* shadow )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_breakpoint\_from\_pc() & gdbarch.c & \cxreffunc{gdbarch_breakpoint_from_pc}{gdbarch.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_address\_masked() & remote.c & \cxreffunc{remote_address_masked}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_remove\_watchpoint()}
\label{func_remote_remove_watchpoint_remote.c}

{\stt static int remote\_remove\_watchpoint ( CORE\_ADDR addr, int len, int type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hexnumstr() & remote.c & \cxreffunc{hexnumstr}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_address\_masked() & remote.c & \cxreffunc{remote_address_masked}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & watchpoint\_to\_Z\_packet() & remote.c & \cxreffunc{watchpoint_to_Z_packet}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), strchr()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_resume()}
\label{func_remote_resume_remote.c}

{\stt static void remote\_resume ( ptid\_t ptid, int step, enum target\_signal siggnal )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_vcont\_resume() & remote.c & \cxreffunc{remote_vcont_resume}{remote.c}\\
\ & set\_thread() & remote.c & \cxreffunc{set_thread}{remote.c}\\
\ & tohex() & remote.c & \cxreffunc{tohex}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk()} &\\
Called by:\ & remote\_async\_resume() & remote.c & \cxreffunc{remote_async_resume}{remote.c}\\
Used in:\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & deprecated\_target\_resume\_hook & remote.c & \cxrefvar{deprecated_target_resume_hook}{remote.c}\\
\ & last\_sent\_signal & remote.c & \cxrefvar{last_sent_signal}{remote.c}\\
\ & last\_sent\_step & remote.c & \cxrefvar{last_sent_step}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_send()}
\label{func_remote_send_remote.c}

{\stt static void remote\_send ( char* buf, long sizeof\_buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & fetch\_register\_using\_p() & remote.c & \cxreffunc{fetch_register_using_p}{remote.c}\\
\ & remote\_detach() & remote.c & \cxreffunc{remote_detach}{remote.c}\\
\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & remote\_store\_registers() & remote.c & \cxreffunc{remote_store_registers}{remote.c}\\
\ & store\_register\_using\_P() & remote.c & \cxreffunc{store_register_using_P}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_serial\_open()}
\label{func_remote_serial_open_remote.c}

{\stt static struct serial* remote\_serial\_open ( const char* name )}

\smallskip
\begin{cxreftabiii}
Calls:\ & serial\_open() & serial.c & \cxreffunc{serial_open}{serial.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ strncmp()} &\\
Called by:\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_start\_remote()}
\label{func_remote_start_remote_remote.c}

{\stt static void remote\_start\_remote ( struct ui\_out* uiout, void* dummy )}

\smallskip
\begin{cxreftabiii}
Calls:\ & add\_outgoing\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_outgoing_pkt_to_protocol_log}{remote.c}\\
\ & end\_remote\_timer() & remote.c & \cxreffunc{end_remote_timer}{remote.c}\\
\ & get\_offsets() & remote.c & \cxreffunc{get_offsets}{remote.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & ptid\_equal() & infrun.c & \cxreffunc{ptid_equal}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_current\_thread() & remote.c & \cxreffunc{remote_current_thread}{remote.c}\\
\ & remote\_start\_remote\_dummy() & remote.c & \cxreffunc{remote_start_remote_dummy}{remote.c}\\
\ & send\_remote\_debugflags\_pkt() & remote.c & \cxreffunc{send_remote_debugflags_pkt}{remote.c}\\
\ & send\_remote\_max\_payload\_size() & remote.c & \cxreffunc{send_remote_max_payload_size}{remote.c}\\
\ & serial\_write() & serial.c & \cxreffunc{serial_write}{serial.c}\\
\ & set\_thread() & remote.c & \cxreffunc{set_thread}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & start\_no\_ack\_mode() & remote.c & \cxreffunc{start_no_ack_mode}{remote.c}\\
\ & start\_remote\_timer() & remote.c & \cxreffunc{start_remote_timer}{remote.c}\\
Used in:\ & remote\_macosx\_complete\_create\_or\_attach() & remote.c & \cxreffunc{remote_macosx_complete_create_or_attach}{remote.c}\\
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
Refs Var:\ & current\_remote\_stats & remote.c & \cxrefvar{current_remote_stats}{remote.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & immediate\_quit & utils.c & \cxrefvar{immediate_quit}{utils.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & null\_ptid & infrun.c & \cxrefvar{null_ptid}{infrun.c}\\
\ & remote\_debugflags & remote.c & \cxrefvar{remote_debugflags}{remote.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\ & user\_requested\_no\_ack\_mode & remote.c & \cxrefvar{user_requested_no_ack_mode}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_start\_remote\_dummy()}
\label{func_remote_start_remote_dummy_remote.c}

{\stt static int remote\_start\_remote\_dummy ( struct ui\_out* uiout, void* dummy )}

\smallskip
\begin{cxreftabiii}
Calls:\ & start\_remote() & infrun.c & \cxreffunc{start_remote}{infrun.c}\\
Called by:\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_stop()}
\label{func_remote_stop_remote.c}

{\stt static void remote\_stop ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & add\_outgoing\_pkt\_to\_protocol\_log() & remote.c & \cxreffunc{add_outgoing_pkt_to_protocol_log}{remote.c}\\
\ & end\_remote\_timer() & remote.c & \cxreffunc{end_remote_timer}{remote.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & serial\_send\_break() & serial.c & \cxreffunc{serial_send_break}{serial.c}\\
\ & serial\_write() & serial.c & \cxreffunc{serial_write}{serial.c}\\
\ & start\_remote\_timer() & remote.c & \cxreffunc{start_remote_timer}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_remote\_stats & remote.c & \cxrefvar{current_remote_stats}{remote.c}\\
\ & gdb\_stdlog & main.c & \cxrefvar{gdb_stdlog}{main.c}\\
\ & remote\_break & remote.c & \cxrefvar{remote_break}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_debug & top.c & \cxrefvar{remote_debug}{top.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_stopped\_by\_watchpoint()}
\label{func_remote_stopped_by_watchpoint_remote.c}

{\stt static int remote\_stopped\_by\_watchpoint ( void )}

\smallskip
\begin{cxreftabiii}
Called by:\ & remote\_stopped\_data\_address() & remote.c & \cxreffunc{remote_stopped_data_address}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & remote\_stopped\_by\_watchpoint\_p & remote.c & \cxrefvar{remote_stopped_by_watchpoint_p}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_stopped\_data\_address()}
\label{func_remote_stopped_data_address_remote.c}

{\stt static int remote\_stopped\_data\_address ( struct target\_ops* target, CORE\_ADDR* addr\_p )}

\smallskip
\begin{cxreftabiii}
Calls:\ & remote\_stopped\_by\_watchpoint() & remote.c & \cxreffunc{remote_stopped_by_watchpoint}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & remote\_watch\_data\_address & remote.c & \cxrefvar{remote_watch_data_address}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & stepped\_after\_stopped\_by\_watchpoint & infrun.c & \cxrefvar{stepped_after_stopped_by_watchpoint}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_store\_registers()}
\label{func_remote_store_registers_remote.c}

{\stt static void remote\_store\_registers ( int regnum )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & bin2hex() & remote.c & \cxreffunc{bin2hex}{remote.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_num\_pseudo\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_pseudo_regs}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_num\_regs() & gdbarch.c & \cxreffunc{gdbarch_num_regs}{gdbarch.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & regcache\_raw\_collect() & regcache.c & \cxreffunc{regcache_raw_collect}{regcache.c}\\
\ & remote\_send() & remote.c & \cxreffunc{remote_send}{remote.c}\\
\ & set\_thread() & remote.c & \cxreffunc{set_thread}{remote.c}\\
\ & store\_register\_using\_P() & remote.c & \cxreffunc{store_register_using_P}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & register\_bytes\_found & remote.c & \cxrefvar{register_bytes_found}{remote.c}\\
\ & remote\_protocol\_P & remote.c & \cxrefvar{remote_protocol_P}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_thread\_alive()}
\label{func_remote_thread_alive_remote.c}

{\stt static int remote\_thread\_alive ( ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & xsnprintf() & utils.c & \cxreffunc{xsnprintf}{utils.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_threadlist\_iterator()}
\label{func_remote_threadlist_iterator_remote.c}

{\stt static int remote\_threadlist\_iterator ( rmt\_thread\_action stepfunction, void* context, int looplimit )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & copy\_threadref() & remote.c & \cxreffunc{copy_threadref}{remote.c}\\
\ & remote\_get\_threadlist() & remote.c & \cxreffunc{remote_get_threadlist}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & remote\_find\_new\_threads() & remote.c & \cxreffunc{remote_find_new_threads}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_threads\_extra\_info()}
\label{func_remote_threads_extra_info_remote.c}

{\stt static const char* remote\_threads\_extra\_info ( struct thread\_info* tp )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hex2bin() & remote.c & \cxreffunc{hex2bin}{remote.c}\\
\ & int\_to\_threadref() & remote.c & \cxreffunc{int_to_threadref}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_get\_threadinfo() & remote.c & \cxreffunc{remote_get_threadinfo}{remote.c}\\
\ & xsnprintf() & utils.c & \cxreffunc{xsnprintf}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), strlen()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & use\_threadextra\_query & remote.c & \cxrefvar{use_threadextra_query}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_threads\_info()}
\label{func_remote_threads_info_remote.c}

{\stt static void remote\_threads\_info ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & add\_thread() & thread.c & \cxreffunc{add_thread}{thread.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & ptid\_build() & infrun.c & \cxreffunc{ptid_build}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_find\_new\_threads() & remote.c & \cxreffunc{remote_find_new_threads}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), strtoul()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\ & use\_threadinfo\_query & remote.c & \cxrefvar{use_threadinfo_query}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_unpack\_thread\_info\_response()}
\label{func_remote_unpack_thread_info_response_remote.c}

{\stt static int remote\_unpack\_thread\_info\_response ( char* pkt, threadref* expectedref, struct gdb\_ext\_thread\_info* info )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & copy\_threadref() & remote.c & \cxreffunc{copy_threadref}{remote.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & stub\_unpack\_int() & remote.c & \cxreffunc{stub_unpack_int}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & threadmatch() & remote.c & \cxreffunc{threadmatch}{remote.c}\\
\ & unpack\_byte() & remote.c & \cxreffunc{unpack_byte}{remote.c}\\
\ & unpack\_int() & remote.c & \cxreffunc{unpack_int}{remote.c}\\
\ & unpack\_string() & remote.c & \cxreffunc{unpack_string}{remote.c}\\
\ & unpack\_threadid() & remote.c & \cxreffunc{unpack_threadid}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & remote\_get\_threadinfo() & remote.c & \cxreffunc{remote_get_threadinfo}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_vcont\_probe()}
\label{func_remote_vcont_probe_remote.c}

{\stt static void remote\_vcont\_probe ( struct remote\_state* rs, char* buf )}

\smallskip
\begin{cxreftabiii}
Calls:\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), strchr(), strncmp()} &\\
Called by:\ & remote\_vcont\_resume() & remote.c & \cxreffunc{remote_vcont_resume}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_protocol\_vcont & remote.c & \cxrefvar{remote_protocol_vcont}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_vcont\_resume()}
\label{func_remote_vcont_resume_remote.c}

{\stt static int remote\_vcont\_resume ( ptid\_t ptid, int step, enum target\_signal siggnal )}

\smallskip
\begin{cxreftabiii}
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_vcont\_probe() & remote.c & \cxreffunc{remote_vcont_probe}{remote.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_protocol\_vcont & remote.c & \cxrefvar{remote_protocol_vcont}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_wait()}
\label{func_remote_wait_remote.c}

{\stt static ptid\_t remote\_wait ( ptid\_t ptid, struct target\_waitstatus* status, gdb\_client\_data client\_data )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & fromhex() & remote.c & \cxreffunc{fromhex}{remote.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hex2bin() & remote.c & \cxreffunc{hex2bin}{remote.c}\\
\ & packet\_reg\_from\_pnum() & remote.c & \cxreffunc{packet_reg_from_pnum}{remote.c}\\
\ & phex\_nz() & utils.c & \cxreffunc{phex_nz}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & ptid\_build() & infrun.c & \cxreffunc{ptid_build}{infrun.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & record\_currthread() & remote.c & \cxreffunc{record_currthread}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & regcache\_raw\_supply() & regcache.c & \cxreffunc{regcache_raw_supply}{regcache.c}\\
\ & register\_size() & regcache.c & \cxreffunc{register_size}{regcache.c}\\
\ & remote\_console\_output() & remote.c & \cxreffunc{remote_console_output}{remote.c}\\
\ & remote\_fileio\_request() & remote-fileio.c & \cxreffunc{remote_fileio_request}{remote-fileio.c}\\
\ & unpack\_varlen\_hex() & remote.c & \cxreffunc{unpack_varlen_hex}{remote.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), signal(), strchr(), strlen(), strncmp(), strtol(), target\_signal\_to\_name()} &\\
Used in:\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
Refs Func:\ & remote\_interrupt() & remote.c & \cxreffunc{remote_interrupt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & deprecated\_target\_wait\_loop\_hook & remote.c & \cxrefvar{deprecated_target_wait_loop_hook}{remote.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & kill\_kludge & remote.c & \cxrefvar{kill_kludge}{remote.c}\\
\ & last\_sent\_signal & remote.c & \cxrefvar{last_sent_signal}{remote.c}\\
\ & last\_sent\_step & remote.c & \cxrefvar{last_sent_step}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & ofunc & remote.c & \cxrefvar{ofunc}{remote.c}\\
\ & remote\_stopped\_by\_watchpoint\_p & remote.c & \cxrefvar{remote_stopped_by_watchpoint_p}{remote.c}\\
\ & remote\_watch\_data\_address & remote.c & \cxrefvar{remote_watch_data_address}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remote\_xfer\_memory()}
\label{func_remote_xfer_memory_remote.c}

{\stt static int remote\_xfer\_memory ( CORE\_ADDR mem\_addr, gdb\_byte* buffer, int mem\_len, int should\_write, struct mem\_attrib* attrib, struct target\_ops* target )}

\smallskip
\begin{cxreftabiii}
Calls:\ & remote\_read\_bytes() & remote.c & \cxreffunc{remote_read_bytes}{remote.c}\\
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function remote\_xfer\_partial()}
\label{func_remote_xfer_partial_remote.c}

{\stt static long remote\_xfer\_partial ( struct target\_ops* ops, enum target\_object object, const char* annex, gdb\_byte* readbuf, const gdb\_byte* writebuf, unsigned long offset, long len )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & hex2bin() & remote.c & \cxreffunc{hex2bin}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & packet\_ok() & remote.c & \cxreffunc{packet_ok}{remote.c}\\
\ & phex\_nz() & utils.c & \cxreffunc{phex_nz}{utils.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & remote\_read\_bytes() & remote.c & \cxreffunc{remote_read_bytes}{remote.c}\\
\ & remote\_write\_bytes() & remote.c & \cxreffunc{remote_write_bytes}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_error(), isprint(), strlen()} &\\
Used in:\ & init\_remote\_async\_ops() & remote.c & \cxreffunc{init_remote_async_ops}{remote.c}\\
\ & init\_remote\_ops() & remote.c & \cxreffunc{init_remote_ops}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\ & remote\_protocol\_qPart\_auxv & remote.c & \cxrefvar{remote_protocol_qPart_auxv}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function send\_disable\_aslr()}
\label{func_send_disable_aslr_remote.c}

{\stt static int send\_disable\_aslr ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size()} &\\
Called by:\ & remote\_macosx\_create\_inferior() & remote.c & \cxreffunc{remote_macosx_create_inferior}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & \cxreftabiiispan{ disable\_aslr\_flag} &\\
\end{cxreftabiii}


\subsubsection{Local Function send\_remote\_debugflags\_pkt()}
\label{func_send_remote_debugflags_pkt_remote.c}

{\stt static int send\_remote\_debugflags\_pkt ( const char* flags )}

\smallskip
\begin{cxreftabiii}
Calls:\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcat\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strcat\_chk(), \_\_inline\_strcpy\_chk(), strlen()} &\\
Called by:\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & set\_remote\_debugflags\_command() & remote.c & \cxreffunc{set_remote_debugflags_command}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function send\_remote\_max\_payload\_size()}
\label{func_send_remote_max_payload_size_remote.c}

{\stt static int send\_remote\_max\_payload\_size ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size()} &\\
Called by:\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function set\_max\_remote\_packet\_size()}
\label{func_set_max_remote_packet_size_remote.c}

{\stt static void set\_max\_remote\_packet\_size ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & \cxreftabiiispan{ strtol()} &\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & g\_max\_remote\_packet\_size & remote.c & \cxrefvar{g_max_remote_packet_size}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_memory\_packet\_size()}
\label{func_set_memory_packet_size_remote.c}

{\stt static void set\_memory\_packet\_size ( const char* args, struct memory\_packet\_config* config )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & query() & utils.c & \cxreffunc{query}{utils.c}\\
\ & \cxreftabiiispan{ strcmp(), strtoul()} &\\
Called by:\ & set\_memory\_read\_packet\_size() & remote.c & \cxreffunc{set_memory_read_packet_size}{remote.c}\\
\ & set\_memory\_write\_packet\_size() & remote.c & \cxreffunc{set_memory_write_packet_size}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function set\_memory\_read\_packet\_size()}
\label{func_set_memory_read_packet_size_remote.c}

{\stt static void set\_memory\_read\_packet\_size ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & set\_memory\_packet\_size() & remote.c & \cxreffunc{set_memory_packet_size}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & memory\_read\_packet\_config & remote.c & \cxrefvar{memory_read_packet_config}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_memory\_write\_packet\_size()}
\label{func_set_memory_write_packet_size_remote.c}

{\stt static void set\_memory\_write\_packet\_size ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & set\_memory\_packet\_size() & remote.c & \cxreffunc{set_memory_packet_size}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & memory\_write\_packet\_config & remote.c & \cxrefvar{memory_write_packet_config}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_no\_ack\_mode\_cmd()}
\label{func_set_no_ack_mode_cmd_remote.c}

{\stt static void set\_no\_ack\_mode\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & start\_no\_ack\_mode() & remote.c & \cxreffunc{start_no_ack_mode}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\ & user\_requested\_no\_ack\_mode & remote.c & \cxrefvar{user_requested_no_ack_mode}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_cmd()}
\label{func_set_remote_cmd_remote.c}

{\stt static void set\_remote\_cmd ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_debugflags\_command()}
\label{func_set_remote_debugflags_command_remote.c}

{\stt static void set\_remote\_debugflags\_command ( const char* ignore, int from\_tty, struct cmd\_list\_element* unused )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & send\_remote\_debugflags\_pkt() & remote.c & \cxreffunc{send_remote_debugflags_pkt}{remote.c}\\
\ & \cxreftabiiispan{ isupper()} &\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_debugflags & remote.c & \cxrefvar{remote_debugflags}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_P\_packet\_cmd()}
\label{func_set_remote_protocol_P_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_P\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_P & remote.c & \cxrefvar{remote_protocol_P}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_Z\_access\_wp\_packet\_cmd()}
\label{func_set_remote_protocol_Z_access_wp_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_Z\_access\_wp\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd()}
\label{func_set_remote_protocol_Z_hardware_bp_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_Z\_packet\_cmd()}
\label{func_set_remote_protocol_Z_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_Z\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_Z\_packet\_detect & remote.c & \cxrefvar{remote_Z_packet_detect}{remote.c}\\
\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_Z\_read\_wp\_packet\_cmd()}
\label{func_set_remote_protocol_Z_read_wp_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_Z\_read\_wp\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_Z\_software\_bp\_packet\_cmd()}
\label{func_set_remote_protocol_Z_software_bp_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_Z\_software\_bp\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_Z\_write\_wp\_packet\_cmd()}
\label{func_set_remote_protocol_Z_write_wp_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_Z\_write\_wp\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_binary\_download\_cmd()}
\label{func_set_remote_protocol_binary_download_cmd_remote.c}

{\stt static void set\_remote\_protocol\_binary\_download\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_binary\_download & remote.c & \cxrefvar{remote_protocol_binary_download}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_p\_packet\_cmd()}
\label{func_set_remote_protocol_p_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_p\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_p & remote.c & \cxrefvar{remote_protocol_p}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_qGetTLSAddr\_packet\_cmd()}
\label{func_set_remote_protocol_qGetTLSAddr_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_qGetTLSAddr\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_qGetTLSAddr & remote.c & \cxrefvar{remote_protocol_qGetTLSAddr}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_qPart\_auxv\_packet\_cmd()}
\label{func_set_remote_protocol_qPart_auxv_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_qPart\_auxv\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_qPart\_auxv & remote.c & \cxrefvar{remote_protocol_qPart_auxv}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_qSymbol\_packet\_cmd()}
\label{func_set_remote_protocol_qSymbol_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_qSymbol\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_qSymbol & remote.c & \cxrefvar{remote_protocol_qSymbol}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_remote\_protocol\_vcont\_packet\_cmd()}
\label{func_set_remote_protocol_vcont_packet_cmd_remote.c}

{\stt static void set\_remote\_protocol\_vcont\_packet\_cmd ( const char* args, int from\_tty, struct cmd\_list\_element* c )}

\smallskip
\begin{cxreftabiii}
Calls:\ & update\_packet\_config() & remote.c & \cxreffunc{update_packet_config}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_vcont & remote.c & \cxrefvar{remote_protocol_vcont}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_thread()}
\label{func_set_thread_remote.c}

{\stt static void set\_thread ( int th, int gen )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & xsnprintf() & utils.c & \cxreffunc{xsnprintf}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & remote\_fetch\_registers() & remote.c & \cxreffunc{remote_fetch_registers}{remote.c}\\
\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & remote\_store\_registers() & remote.c & \cxreffunc{remote_store_registers}{remote.c}\\
Refs Var:\ & continue\_thread & remote.c & \cxrefvar{continue_thread}{remote.c}\\
\ & general\_thread & remote.c & \cxrefvar{general_thread}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_max\_remote\_packet\_size()}
\label{func_show_max_remote_packet_size_remote.c}

{\stt static void show\_max\_remote\_packet\_size ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & g\_max\_remote\_packet\_size & remote.c & \cxrefvar{g_max_remote_packet_size}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_memory\_packet\_size()}
\label{func_show_memory_packet_size_remote.c}

{\stt static void show\_memory\_packet\_size ( struct memory\_packet\_config* config )}

\smallskip
\begin{cxreftabiii}
Calls:\ & get\_memory\_packet\_size() & remote.c & \cxreffunc{get_memory_packet_size}{remote.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
Called by:\ & show\_memory\_read\_packet\_size() & remote.c & \cxreffunc{show_memory_read_packet_size}{remote.c}\\
\ & show\_memory\_write\_packet\_size() & remote.c & \cxreffunc{show_memory_write_packet_size}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_memory\_read\_packet\_size()}
\label{func_show_memory_read_packet_size_remote.c}

{\stt static void show\_memory\_read\_packet\_size ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_memory\_packet\_size() & remote.c & \cxreffunc{show_memory_packet_size}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & memory\_read\_packet\_config & remote.c & \cxrefvar{memory_read_packet_config}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_memory\_write\_packet\_size()}
\label{func_show_memory_write_packet_size_remote.c}

{\stt static void show\_memory\_write\_packet\_size ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_memory\_packet\_size() & remote.c & \cxreffunc{show_memory_packet_size}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & memory\_write\_packet\_config & remote.c & \cxrefvar{memory_write_packet_config}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_no\_ack\_mode\_cmd()}
\label{func_show_no_ack_mode_cmd_remote.c}

{\stt static void show\_no\_ack\_mode\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & no\_ack\_mode & remote.c & \cxrefvar{no_ack_mode}{remote.c}\\
\ & remote\_desc & remote.c & \cxrefvar{remote_desc}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & user\_requested\_no\_ack\_mode & remote.c & \cxrefvar{user_requested_no_ack_mode}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_packet\_config\_cmd()}
\label{func_show_packet_config_cmd_remote.c}

{\stt static void show\_packet\_config\_cmd ( struct packet\_config* config )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
Called by:\ & show\_remote\_protocol\_P\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_P_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_access\_wp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_access_wp_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_hardware_bp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_read\_wp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_read_wp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_software\_bp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_software_bp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_write\_wp\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_write_wp_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_binary\_download\_cmd() & remote.c & \cxreffunc{show_remote_protocol_binary_download_cmd}{remote.c}\\
\ & show\_remote\_protocol\_p\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_p_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qGetTLSAddr\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qGetTLSAddr_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_remote\_protocol\_qPart\_auxv\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qPart_auxv_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qSymbol\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qSymbol_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_vcont\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_vcont_packet_cmd}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_cmd()}
\label{func_show_remote_cmd_remote.c}

{\stt static void show\_remote\_cmd ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_max\_remote\_packet\_size() & remote.c & \cxreffunc{show_max_remote_packet_size}{remote.c}\\
\ & show\_remote\_protocol\_P\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_P_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_Z\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_Z_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_binary\_download\_cmd() & remote.c & \cxreffunc{show_remote_protocol_binary_download_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & show\_remote\_protocol\_p\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_p_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qGetTLSAddr\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qGetTLSAddr_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qPart\_auxv\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qPart_auxv_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_qSymbol\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_qSymbol_packet_cmd}{remote.c}\\
\ & show\_remote\_protocol\_vcont\_packet\_cmd() & remote.c & \cxreffunc{show_remote_protocol_vcont_packet_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_debugflags\_command()}
\label{func_show_remote_debugflags_command_remote.c}

{\stt static void show\_remote\_debugflags\_command ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_debugflags & remote.c & \cxrefvar{remote_debugflags}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_P\_packet\_cmd()}
\label{func_show_remote_protocol_P_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_P\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_P & remote.c & \cxrefvar{remote_protocol_P}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_Z\_access\_wp\_packet\_cmd()}
\label{func_show_remote_protocol_Z_access_wp_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_Z\_access\_wp\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd()}
\label{func_show_remote_protocol_Z_hardware_bp_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_Z\_packet\_cmd()}
\label{func_show_remote_protocol_Z_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_Z\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_Z\_read\_wp\_packet\_cmd()}
\label{func_show_remote_protocol_Z_read_wp_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_Z\_read\_wp\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_Z\_software\_bp\_packet\_cmd()}
\label{func_show_remote_protocol_Z_software_bp_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_Z\_software\_bp\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_Z\_write\_wp\_packet\_cmd()}
\label{func_show_remote_protocol_Z_write_wp_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_Z\_write\_wp\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_Z & remote.c & \cxrefvar{remote_protocol_Z}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_binary\_download\_cmd()}
\label{func_show_remote_protocol_binary_download_cmd_remote.c}

{\stt static void show\_remote\_protocol\_binary\_download\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_binary\_download & remote.c & \cxrefvar{remote_protocol_binary_download}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_p\_packet\_cmd()}
\label{func_show_remote_protocol_p_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_p\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_p & remote.c & \cxrefvar{remote_protocol_p}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_qGetTLSAddr\_packet\_cmd()}
\label{func_show_remote_protocol_qGetTLSAddr_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_qGetTLSAddr\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_qGetTLSAddr & remote.c & \cxrefvar{remote_protocol_qGetTLSAddr}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_qPart\_auxv\_packet\_cmd()}
\label{func_show_remote_protocol_qPart_auxv_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_qPart\_auxv\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_qPart\_auxv & remote.c & \cxrefvar{remote_protocol_qPart_auxv}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_qSymbol\_packet\_cmd()}
\label{func_show_remote_protocol_qSymbol_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_qSymbol\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_qSymbol & remote.c & \cxrefvar{remote_protocol_qSymbol}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function show\_remote\_protocol\_vcont\_packet\_cmd()}
\label{func_show_remote_protocol_vcont_packet_cmd_remote.c}

{\stt static void show\_remote\_protocol\_vcont\_packet\_cmd ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & show\_packet\_config\_cmd() & remote.c & \cxreffunc{show_packet_config_cmd}{remote.c}\\
Called by:\ & show\_remote\_cmd() & remote.c & \cxreffunc{show_remote_cmd}{remote.c}\\
Used in:\ & \_initialize\_remote() & remote.c & \cxreffunc{_initialize_remote}{remote.c}\\
Refs Var:\ & remote\_protocol\_vcont & remote.c & \cxrefvar{remote_protocol_vcont}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function start\_no\_ack\_mode()}
\label{func_start_no_ack_mode_remote.c}

{\stt static void start\_no\_ack\_mode ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & getpkt() & remote.c & \cxreffunc{getpkt}{remote.c}\\
\ & putpkt() & remote.c & \cxreffunc{putpkt}{remote.c}\\
Called by:\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & set\_no\_ack\_mode\_cmd() & remote.c & \cxreffunc{set_no_ack_mode_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & no\_ack\_mode & remote.c & \cxrefvar{no_ack_mode}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function start\_remote\_timer()}
\label{func_start_remote_timer_remote.c}

{\stt static void start\_remote\_timer ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & \cxreftabiiispan{ gettimeofday()} &\\
Called by:\ & getpkt\_sane() & remote.c & \cxreffunc{getpkt_sane}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & readchar() & remote.c & \cxreffunc{readchar}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & remote\_start\_remote() & remote.c & \cxreffunc{remote_start_remote}{remote.c}\\
\ & remote\_stop() & remote.c & \cxreffunc{remote_stop}{remote.c}\\
Refs Var:\ & current\_remote\_stats & remote.c & \cxrefvar{current_remote_stats}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function store\_register\_using\_P()}
\label{func_store_register_using_P_remote.c}

{\stt static int store\_register\_using\_P ( int regnum )}

\smallskip
\begin{cxreftabiii}
Calls:\ & bin2hex() & remote.c & \cxreffunc{bin2hex}{remote.c}\\
\ & get\_remote\_state() & remote.c & \cxreffunc{get_remote_state}{remote.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & packet\_reg\_from\_regnum() & remote.c & \cxreffunc{packet_reg_from_regnum}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & phex\_nz() & utils.c & \cxreffunc{phex_nz}{utils.c}\\
\ & regcache\_raw\_collect() & regcache.c & \cxreffunc{regcache_raw_collect}{regcache.c}\\
\ & register\_size() & regcache.c & \cxreffunc{register_size}{regcache.c}\\
\ & remote\_send() & remote.c & \cxreffunc{remote_send}{remote.c}\\
\ & xsnprintf() & utils.c & \cxreffunc{xsnprintf}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), strlen()} &\\
Called by:\ & remote\_store\_registers() & remote.c & \cxreffunc{remote_store_registers}{remote.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_regcache & regcache.c & \cxrefvar{current_regcache}{regcache.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function stub\_unpack\_int()}
\label{func_stub_unpack_int_remote.c}

{\stt static int stub\_unpack\_int ( char* buff, int fieldlength )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & stubhex() & remote.c & \cxreffunc{stubhex}{remote.c}\\
Called by:\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\ & unpack\_byte() & remote.c & \cxreffunc{unpack_byte}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & unpack\_int() & remote.c & \cxreffunc{unpack_int}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function stubhex()}
\label{func_stubhex_remote.c}

{\stt static int stubhex ( int ch )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & stub\_unpack\_int() & remote.c & \cxreffunc{stub_unpack_int}{remote.c}\\
\ & unpack\_threadid() & remote.c & \cxreffunc{unpack_threadid}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function threadmatch()}
\label{func_threadmatch_remote.c}

{\stt static int threadmatch ( threadref* dest, threadref* src )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & remote\_get\_threadlist() & remote.c & \cxreffunc{remote_get_threadlist}{remote.c}\\
\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function threadref\_to\_int()}
\label{func_threadref_to_int_remote.c}

{\stt static int threadref\_to\_int ( threadref* ref )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & remote\_newthread\_step() & remote.c & \cxreffunc{remote_newthread_step}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function tohex()}
\label{func_tohex_remote.c}

{\stt static int tohex ( int nib )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & bin2hex() & remote.c & \cxreffunc{bin2hex}{remote.c}\\
\ & putpkt\_binary() & remote.c & \cxreffunc{putpkt_binary}{remote.c}\\
\ & remote\_resume() & remote.c & \cxreffunc{remote_resume}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function unpack\_byte()}
\label{func_unpack_byte_remote.c}

{\stt static char* unpack\_byte ( char* buf, int* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & stub\_unpack\_int() & remote.c & \cxreffunc{stub_unpack_int}{remote.c}\\
Called by:\ & parse\_threadlist\_response() & remote.c & \cxreffunc{parse_threadlist_response}{remote.c}\\
\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function unpack\_int()}
\label{func_unpack_int_remote.c}

{\stt static char* unpack\_int ( char* buf, int* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & stub\_unpack\_int() & remote.c & \cxreffunc{stub_unpack_int}{remote.c}\\
Called by:\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function unpack\_nibble()}
\label{func_unpack_nibble_remote.c}

{\stt static char* unpack\_nibble ( char* buf, int* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & ishex() & remote.c & \cxreffunc{ishex}{remote.c}\\
Called by:\ & parse\_threadlist\_response() & remote.c & \cxreffunc{parse_threadlist_response}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function unpack\_string()}
\label{func_unpack_string_remote.c}

{\stt static char* unpack\_string ( char* src, char* dest, int length )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function unpack\_threadid()}
\label{func_unpack_threadid_remote.c}

{\stt static char* unpack\_threadid ( char* inbuf, threadref* id )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Calls:\ & stubhex() & remote.c & \cxreffunc{stubhex}{remote.c}\\
Called by:\ & parse\_threadlist\_response() & remote.c & \cxreffunc{parse_threadlist_response}{remote.c}\\
\ & remote\_unpack\_thread\_info\_response() & remote.c & \cxreffunc{remote_unpack_thread_info_response}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function update\_packet\_config()}
\label{func_update_packet_config_remote.c}

{\stt static void update\_packet\_config ( struct packet\_config* config )}

\smallskip
\begin{cxreftabiii}
Prototype:& remote.c & \ & \cxreffile{remote.c}\\
Called by:\ & init\_all\_packet\_configs() & remote.c & \cxreffunc{init_all_packet_configs}{remote.c}\\
\ & set\_remote\_protocol\_P\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_P_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_access\_wp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_access_wp_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_remote\_protocol\_Z\_hardware\_bp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_hardware_bp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_read\_wp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_read_wp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_software\_bp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_software_bp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_Z\_write\_wp\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_Z_write_wp_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_binary\_download\_cmd() & remote.c & \cxreffunc{set_remote_protocol_binary_download_cmd}{remote.c}\\
\ & set\_remote\_protocol\_p\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_p_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_qGetTLSAddr\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_qGetTLSAddr_packet_cmd}{remote.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_remote\_protocol\_qPart\_auxv\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_qPart_auxv_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_qSymbol\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_qSymbol_packet_cmd}{remote.c}\\
\ & set\_remote\_protocol\_vcont\_packet\_cmd() & remote.c & \cxreffunc{set_remote_protocol_vcont_packet_cmd}{remote.c}\\
\end{cxreftabiii}


\subsubsection{Local Function watchpoint\_to\_Z\_packet()}
\label{func_watchpoint_to_Z_packet_remote.c}

{\stt static int watchpoint\_to\_Z\_packet ( int type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & remote\_insert\_watchpoint() & remote.c & \cxreffunc{remote_insert_watchpoint}{remote.c}\\
\ & remote\_remove\_watchpoint() & remote.c & \cxreffunc{remote_remove_watchpoint}{remote.c}\\
\end{cxreftabiii}

