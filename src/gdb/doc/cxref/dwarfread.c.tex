% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF dwarfread.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File dwarfread.c}{File dwarfread.c}
\section{File dwarfread.c}
\label{file_dwarfread.c}

\smallskip
\begin{cxreftabiii}
Refs Var:\ & file\_symbols & buildsym.c & \cxrefvar{file_symbols}{buildsym.c}\\
\end{cxreftabiii}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <uuid/uuid.h>} &\\
\hspace*{0.2in}{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/obstack.h"} &\cxreffile{../include/obstack.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.8in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{1.0in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{1.0in}{\stt \#include <regex.h>} &\\
\hspace*{0.8in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.8in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.8in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{1.0in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/elf/dwarf.h"} &\cxreffile{../include/elf/dwarf.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "buildsym.h"} &\cxreffile{buildsym.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/demangle.h"} &\cxreffile{../include/demangle.h}\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "complaints.h"} &\cxreffile{complaints.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <fcntl.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define DIE\_ID}

\medskip
{\stt \#define DIE\_NAME}

\medskip
{\stt \#define GCC\_PRODUCER "GNU C "}

\medskip
{\stt \#define GPLUS\_PRODUCER "GNU C++ "}

\medskip
{\stt \#define LCC\_PRODUCER "NCR C/C++"}

\medskip
{\stt \#define GET\_UNSIGNED 0}

\medskip
{\stt \#define GET\_SIGNED 1}

\medskip
{\stt \#define SIZEOF\_DIE\_LENGTH 4}

\medskip
{\stt \#define SIZEOF\_DIE\_TAG 2}

\medskip
{\stt \#define SIZEOF\_ATTRIBUTE 2}

\medskip
{\stt \#define SIZEOF\_FORMAT\_SPECIFIER 1}

\medskip
{\stt \#define SIZEOF\_FMT\_FT 2}

\medskip
{\stt \#define SIZEOF\_LINETBL\_LENGTH 4}

\medskip
{\stt \#define SIZEOF\_LINETBL\_LINENO 4}

\medskip
{\stt \#define SIZEOF\_LINETBL\_STMT 2}

\medskip
{\stt \#define SIZEOF\_LINETBL\_DELTA 4}

\medskip
{\stt \#define SIZEOF\_LOC\_ATOM\_CODE 1}

\medskip
{\stt \#define FORM\_FROM\_ATTR( attr )}

\medskip
{\stt \#define TARGET\_FT\_POINTER\_SIZE( objfile )}

\medskip
{\stt \#define TARGET\_FT\_LONG\_SIZE( objfile )}

\medskip
{\stt \#define AT\_short\_element\_list}

\medskip
{\stt \#define DBFOFF( p )}

\medskip
{\stt \#define DBROFF( p )}

\medskip
{\stt \#define DBLENGTH( p )}

\medskip
{\stt \#define LNFOFF( p )}

\medskip
{\stt \#define AUTO\_AS\_IN\_THE\_C\_MEANING\_OF\_IT auto}


\subsection{Type definitions}


\subsubsection{Typedef DIE\_REF}
\label{type_DIE_REF_dwarfread.c}

{\stt typedef unsigned int DIE\_REF}


\subsubsection{Typedef BLOCK}
\label{type_BLOCK_dwarfread.c}

{\stt typedef char BLOCK}


\subsubsection{Type struct dieinfo}
\label{type_struct_dieinfo_dwarfread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct dieinfo} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* die;} &\\
\hspace*{0.2in}{\stt unsigned long die\_length;} &\\
\hspace*{0.2in}{\stt DIE\_REF die\_ref;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned short die\_tag;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_padding;} &\\
\hspace*{0.2in}{\stt unsigned long at\_sibling;} &\\
\hspace*{0.2in}{\stt BLOCK* at\_location;} &\\
\hspace*{0.2in}{\stt char* at\_name;} &\\
\hspace*{0.2in}{\stt unsigned short at\_fund\_type;} &\\
\hspace*{0.2in}{\stt BLOCK* at\_mod\_fund\_type;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_user\_def\_type;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt BLOCK* at\_mod\_u\_d\_type;} &\\
\hspace*{0.2in}{\stt unsigned short at\_ordering;} &\\
\hspace*{0.2in}{\stt BLOCK* at\_subscr\_data;} &\\
\hspace*{0.2in}{\stt size\_t at\_byte\_size;} &\\
\hspace*{0.2in}{\stt unsigned short at\_bit\_offset;} &\\
\hspace*{0.2in}{\stt size\_t at\_bit\_size;} &\\
\hspace*{0.2in}{\stt BLOCK* at\_element\_list;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_stmt\_list;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt CORE\_ADDR at\_low\_pc;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_high\_pc;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_language;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_member;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_discr;} &\\
\hspace*{0.2in}{\stt BLOCK* at\_discr\_value;} &\\
\hspace*{0.2in}{\stt BLOCK* at\_string\_length;} &\\
\hspace*{0.2in}{\stt char* at\_comp\_dir;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt char* at\_producer;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_start\_scope;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_stride\_size;} &\\
\hspace*{0.2in}{\stt CORE\_ADDR at\_src\_info;} &\\
\hspace*{0.2in}{\stt char* at\_prototyped;} &\\
\hspace*{0.2in}{\stt unsigned int has\_at\_low\_pc:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_at\_stmt\_list:1;} &\\
\hspace*{0.2in}{\stt unsigned int has\_at\_byte\_size:1;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt unsigned int short\_element\_list:1;} &\\
\hspace*{0.2in}{\stt unsigned int isreg;} &\\
\hspace*{0.2in}{\stt unsigned int optimized\_out;} &\\
\hspace*{0.2in}{\stt unsigned int offreg;} &\\
\hspace*{0.2in}{\stt unsigned int basereg;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct dwfinfo}
\label{type_struct_dwfinfo_dwarfread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct dwfinfo} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt file\_ptr dbfoff;} &\\
\hspace*{0.2in}{\stt int dbroff;} &\\
\hspace*{0.2in}{\stt int dblength;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt file\_ptr lnfoff;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct nextfield}
\label{type_struct_nextfield_dwarfread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct nextfield} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct nextfield* next;} &\\
\hspace*{0.2in}{\stt struct field field;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct nextfield}
\label{type_struct_nextfield_dwarfread.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct nextfield} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct nextfield* next;} &\\
\hspace*{0.2in}{\stt struct field field;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable list\_in\_scope}
\label{var_list_in_scope_dwarfread.c}

{\stt struct pending** list\_in\_scope}

\smallskip
\begin{cxreftabiii}
Visible in:\ & dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Used in:\ & enum\_type() & dwarfread.c & \cxreffunc{enum_type}{dwarfread.c}\\
\ & new\_symbol() & dwarfread.c & \cxreffunc{new_symbol}{dwarfread.c}\\
\ & read\_func\_scope() & dwarfread.c & \cxreffunc{read_func_scope}{dwarfread.c}\\
\ & synthesize\_typedef() & dwarfread.c & \cxreffunc{synthesize_typedef}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf diecount}
\label{var_diecount_dwarfread.c}

{\stt static int diecount}

\smallskip
\begin{cxreftabiii}
Used in:\ & completedieinfo() & \ & \cxreffunc{completedieinfo}{dwarfread.c}\\
\ & psymtab\_to\_symtab\_1() & \ & \cxreffunc{psymtab_to_symtab_1}{dwarfread.c}\\
\ & read\_ofile\_symtab() & \ & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf curdie}
\label{var_curdie_dwarfread.c}

{\stt static struct dieinfo* curdie}

\smallskip
\begin{cxreftabiii}
Used in:\ & alloc\_utype() & \ & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & attribute\_size() & \ & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & basicdieinfo() & \ & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\ & completedieinfo() & \ & \cxreffunc{completedieinfo}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_array\_element\_type() & \ & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_fund\_type() & \ & \cxreffunc{decode_fund_type}{dwarfread.c}\\
\ & decode\_modified\_type() & \ & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & decode\_subscript\_data\_item() & \ & \cxreffunc{decode_subscript_data_item}{dwarfread.c}\\
\ & dwarf\_read\_array\_type() & \ & \cxreffunc{dwarf_read_array_type}{dwarfread.c}\\
\ & locval() & \ & \cxreffunc{locval}{dwarfread.c}\\
\ & lookup\_utype() & \ & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & read\_func\_scope() & \ & \cxreffunc{read_func_scope}{dwarfread.c}\\
\ & read\_subroutine\_type() & \ & \cxreffunc{read_subroutine_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_tag\_string\_type() & \ & \cxreffunc{read_tag_string_type}{dwarfread.c}\\
\ & scan\_partial\_symbols() & \ & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
\ & struct\_type() & \ & \cxreffunc{struct_type}{dwarfread.c}\\
\ & target\_to\_host() & \ & \cxreffunc{target_to_host}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf dbbase}
\label{var_dbbase_dwarfread.c}

{\stt static char* dbbase}

\smallskip
\begin{cxreftabiii}
Used in:\ & basicdieinfo() & \ & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\ & dwarf\_build\_psymtabs() & \ & \cxreffunc{dwarf_build_psymtabs}{dwarfread.c}\\
\ & process\_dies() & \ & \cxreffunc{process_dies}{dwarfread.c}\\
\ & read\_ofile\_symtab() & \ & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\ & scan\_compilation\_units() & \ & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
\ & scan\_partial\_symbols() & \ & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
\ & struct\_type() & \ & \cxreffunc{struct_type}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf dbsize}
\label{var_dbsize_dwarfread.c}

{\stt static int dbsize}

\smallskip
\begin{cxreftabiii}
Used in:\ & basicdieinfo() & \ & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\ & dwarf\_build\_psymtabs() & \ & \cxreffunc{dwarf_build_psymtabs}{dwarfread.c}\\
\ & read\_ofile\_symtab() & \ & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf dbroff}
\label{var_dbroff_dwarfread.c}

{\stt static int dbroff}

\smallskip
\begin{cxreftabiii}
Used in:\ & alloc\_utype() & \ & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & basicdieinfo() & \ & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\ & dwarf\_build\_psymtabs() & \ & \cxreffunc{dwarf_build_psymtabs}{dwarfread.c}\\
\ & lookup\_utype() & \ & \cxreffunc{lookup_utype}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_dies() & \ & \cxreffunc{process_dies}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_ofile\_symtab() & \ & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\ & scan\_compilation\_units() & \ & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
\ & scan\_partial\_symbols() & \ & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
\ & struct\_type() & \ & \cxreffunc{struct_type}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf lnbase}
\label{var_lnbase_dwarfread.c}

{\stt static char* lnbase}

\smallskip
\begin{cxreftabiii}
Used in:\ & read\_file\_scope() & \ & \cxreffunc{read_file_scope}{dwarfread.c}\\
\ & read\_ofile\_symtab() & \ & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf baseaddr}
\label{var_baseaddr_dwarfread.c}

{\stt static CORE\_ADDR baseaddr}

\smallskip
\begin{cxreftabiii}
Used in:\ & completedieinfo() & \ & \cxreffunc{completedieinfo}{dwarfread.c}\\
\ & decode\_line\_numbers() & \ & \cxreffunc{decode_line_numbers}{dwarfread.c}\\
\ & dwarf\_build\_psymtabs() & \ & \cxreffunc{dwarf_build_psymtabs}{dwarfread.c}\\
\ & new\_symbol() & \ & \cxreffunc{new_symbol}{dwarfread.c}\\
\ & read\_ofile\_symtab() & \ & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf base\_section\_offsets}
\label{var_base_section_offsets_dwarfread.c}

{\stt static struct section\_offsets* base\_section\_offsets}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf\_build\_psymtabs() & \ & \cxreffunc{dwarf_build_psymtabs}{dwarfread.c}\\
\ & read\_ofile\_symtab() & \ & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\ & scan\_compilation\_units() & \ & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf utypes}
\label{var_utypes_dwarfread.c}

{\stt static struct type** utypes}

\smallskip
\begin{cxreftabiii}
Used in:\ & alloc\_utype() & \ & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & free\_utypes() & \ & \cxreffunc{free_utypes}{dwarfread.c}\\
\ & lookup\_utype() & \ & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & read\_file\_scope() & \ & \cxreffunc{read_file_scope}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf numutypes}
\label{var_numutypes_dwarfread.c}

{\stt static int numutypes}

\smallskip
\begin{cxreftabiii}
Used in:\ & alloc\_utype() & \ & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & free\_utypes() & \ & \cxreffunc{free_utypes}{dwarfread.c}\\
\ & lookup\_utype() & \ & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & read\_file\_scope() & \ & \cxreffunc{read_file_scope}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf ftypes}
\label{var_ftypes_dwarfread.c}

{\stt static struct type* ftypes[29]}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf\_fundamental\_type() & \ & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
\ & read\_file\_scope() & \ & \cxreffunc{read_file_scope}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf cu\_language}
\label{var_cu_language_dwarfread.c}

{\stt static enum language cu\_language}

\smallskip
\begin{cxreftabiii}
Used in:\ & add\_enum\_psymbol() & \ & \cxreffunc{add_enum_psymbol}{dwarfread.c}\\
\ & add\_partial\_symbol() & \ & \cxreffunc{add_partial_symbol}{dwarfread.c}\\
\ & enum\_type() & \ & \cxreffunc{enum_type}{dwarfread.c}\\
\ & new\_symbol() & \ & \cxreffunc{new_symbol}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_enumeration() & \ & \cxreffunc{read_enumeration}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_file\_scope() & \ & \cxreffunc{read_file_scope}{dwarfread.c}\\
\ & read\_structure\_scope() & \ & \cxreffunc{read_structure_scope}{dwarfread.c}\\
\ & set\_cu\_language() & \ & \cxreffunc{set_cu_language}{dwarfread.c}\\
\ & synthesize\_typedef() & \ & \cxreffunc{synthesize_typedef}{dwarfread.c}\\
\end{cxreftabiii}

\medskip
{\bf cu\_language\_defn}
\label{var_cu_language_defn_dwarfread.c}

{\stt static const struct language\_defn* cu\_language\_defn}

\smallskip
\begin{cxreftabiii}
Used in:\ & dwarf\_fundamental\_type() & \ & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
\ & set\_cu\_language() & \ & \cxreffunc{set_cu_language}{dwarfread.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function dwarf\_build\_psymtabs()}
\label{func_dwarf_build_psymtabs_dwarfread.c}

{\stt void dwarf\_build\_psymtabs ( struct objfile* objfile, int mainline, file\_ptr dbfoff, unsigned int dbfsize, file\_ptr lnoffset, unsigned int lnsize )}

\smallskip
\begin{cxreftabiii}
Prototype:& symfile.h & \ & \cxreffile{symfile.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & init\_psymbol\_list() & symfile.c & \cxreffunc{init_psymbol_list}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & scan\_compilation\_units() & dwarfread.c & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ bfd\_bread(), bfd\_seek()} &\\
Called by:\ & elf\_symfile\_read() & elfread.c & \cxreffunc{elf_symfile_read}{elfread.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & base\_section\_offsets & dwarfread.c & \cxrefvar{base_section_offsets}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & baseaddr & dwarfread.c & \cxrefvar{baseaddr}{dwarfread.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & dbbase & dwarfread.c & \cxrefvar{dbbase}{dwarfread.c}\\
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\ & dbsize & dwarfread.c & \cxrefvar{dbsize}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_enum\_psymbol()}
\label{func_add_enum_psymbol_dwarfread.c}

{\stt static void add\_enum\_psymbol ( struct dieinfo* dip, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & gdbarch\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_bit}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & scan\_partial\_symbols() & dwarfread.c & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
Refs Var:\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_partial\_symbol()}
\label{func_add_partial_symbol_dwarfread.c}

{\stt static void add\_partial\_symbol ( struct dieinfo* dip, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & add\_psymbol\_to\_list() & symfile.c & \cxreffunc{add_psymbol_to_list}{symfile.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & scan\_partial\_symbols() & dwarfread.c & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
Refs Var:\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function alloc\_utype()}
\label{func_alloc_utype_dwarfread.c}

{\stt static struct type* alloc\_utype ( DIE\_REF die\_ref, struct type* utypep )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & bad\_die\_ref\_complaint() & dwarfread.c & \cxreffunc{bad_die_ref_complaint}{dwarfread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf\_fundamental\_type() & dwarfread.c & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
Called by:\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & dwarf\_read\_array\_type() & dwarfread.c & \cxreffunc{dwarf_read_array_type}{dwarfread.c}\\
\ & enum\_type() & dwarfread.c & \cxreffunc{enum_type}{dwarfread.c}\\
\ & read\_subroutine\_type() & dwarfread.c & \cxreffunc{read_subroutine_type}{dwarfread.c}\\
\ & read\_tag\_pointer\_type() & dwarfread.c & \cxreffunc{read_tag_pointer_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_tag\_string\_type() & dwarfread.c & \cxreffunc{read_tag_string_type}{dwarfread.c}\\
\ & struct\_type() & dwarfread.c & \cxreffunc{struct_type}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\ & numutypes & dwarfread.c & \cxrefvar{numutypes}{dwarfread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\ & utypes & dwarfread.c & \cxrefvar{utypes}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function attribute\_size()}
\label{func_attribute_size_dwarfread.c}

{\stt static int attribute\_size ( unsigned int attr )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & gdbarch\_ptr\_bit() & gdbarch.c & \cxreffunc{gdbarch_ptr_bit}{gdbarch.c}\\
\ & unknown\_attribute\_form\_complaint() & dwarfread.c & \cxreffunc{unknown_attribute_form_complaint}{dwarfread.c}\\
Called by:\ & add\_enum\_psymbol() & dwarfread.c & \cxreffunc{add_enum_psymbol}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & completedieinfo() & dwarfread.c & \cxreffunc{completedieinfo}{dwarfread.c}\\
\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_mod\_fund\_type() & dwarfread.c & \cxreffunc{decode_mod_fund_type}{dwarfread.c}\\
\ & decode\_mod\_u\_d\_type() & dwarfread.c & \cxreffunc{decode_mod_u_d_type}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & dwarf\_read\_array\_type() & dwarfread.c & \cxreffunc{dwarf_read_array_type}{dwarfread.c}\\
\ & enum\_type() & dwarfread.c & \cxreffunc{enum_type}{dwarfread.c}\\
\ & locval() & dwarfread.c & \cxreffunc{locval}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function bad\_array\_element\_type\_complaint()}
\label{func_bad_array_element_type_complaint_dwarfread.c}

{\stt static void bad\_array\_element\_type\_complaint ( int arg1, const char* arg2, int arg3 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function bad\_die\_ref\_complaint()}
\label{func_bad_die_ref_complaint_dwarfread.c}

{\stt static void bad\_die\_ref\_complaint ( int arg1, const char* arg2, int arg3 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & scan\_partial\_symbols() & dwarfread.c & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function basicdieinfo()}
\label{func_basicdieinfo_dwarfread.c}

{\stt static void basicdieinfo ( struct dieinfo* dip, char* diep, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & scan\_compilation\_units() & dwarfread.c & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
\ & scan\_partial\_symbols() & dwarfread.c & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
\ & struct\_type() & dwarfread.c & \cxreffunc{struct_type}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & dbbase & dwarfread.c & \cxrefvar{dbbase}{dwarfread.c}\\
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\ & dbsize & dwarfread.c & \cxrefvar{dbsize}{dwarfread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function completedieinfo()}
\label{func_completedieinfo_dwarfread.c}

{\stt static void completedieinfo ( struct dieinfo* dip, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & gdbarch\_ptr\_bit() & gdbarch.c & \cxreffunc{gdbarch_ptr_bit}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
\ & unknown\_attribute\_form\_complaint() & dwarfread.c & \cxreffunc{unknown_attribute_form_complaint}{dwarfread.c}\\
\ & \cxreftabiiispan{ strlen(), strrchr()} &\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\ & scan\_compilation\_units() & dwarfread.c & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
\ & scan\_partial\_symbols() & dwarfread.c & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
\ & struct\_type() & dwarfread.c & \cxreffunc{struct_type}{dwarfread.c}\\
Refs Var:\ & baseaddr & dwarfread.c & \cxrefvar{baseaddr}{dwarfread.c}\\
\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & diecount & dwarfread.c & \cxrefvar{diecount}{dwarfread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function create\_name()}
\label{func_create_name_dwarfread.c}

{\stt static char* create\_name ( const char* name, struct obstack* obstackp )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), \_obstack\_newchunk(), strlen()} &\\
Called by:\ & enum\_type() & dwarfread.c & \cxreffunc{enum_type}{dwarfread.c}\\
\ & synthesize\_typedef() & dwarfread.c & \cxreffunc{synthesize_typedef}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function decode\_array\_element\_type()}
\label{func_decode_array_element_type_dwarfread.c}

{\stt static struct type* decode\_array\_element\_type ( char* scan )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & bad\_array\_element\_type\_complaint() & dwarfread.c & \cxreffunc{bad_array_element_type_complaint}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_fund\_type() & dwarfread.c & \cxreffunc{decode_fund_type}{dwarfread.c}\\
\ & decode\_mod\_fund\_type() & dwarfread.c & \cxreffunc{decode_mod_fund_type}{dwarfread.c}\\
\ & decode\_mod\_u\_d\_type() & dwarfread.c & \cxreffunc{decode_mod_u_d_type}{dwarfread.c}\\
\ & dwarf\_fundamental\_type() & dwarfread.c & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
Called by:\ & decode\_subscript\_data\_item() & dwarfread.c & \cxreffunc{decode_subscript_data_item}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_die\_type()}
\label{func_decode_die_type_dwarfread.c}

{\stt static struct type* decode\_die\_type ( struct dieinfo* dip )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & decode\_fund\_type() & dwarfread.c & \cxreffunc{decode_fund_type}{dwarfread.c}\\
\ & decode\_mod\_fund\_type() & dwarfread.c & \cxreffunc{decode_mod_fund_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_mod\_u\_d\_type() & dwarfread.c & \cxreffunc{decode_mod_u_d_type}{dwarfread.c}\\
\ & dwarf\_fundamental\_type() & dwarfread.c & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
Called by:\ & new\_symbol() & dwarfread.c & \cxreffunc{new_symbol}{dwarfread.c}\\
\ & read\_subroutine\_type() & dwarfread.c & \cxreffunc{read_subroutine_type}{dwarfread.c}\\
\ & read\_tag\_pointer\_type() & dwarfread.c & \cxreffunc{read_tag_pointer_type}{dwarfread.c}\\
\ & struct\_type() & dwarfread.c & \cxreffunc{struct_type}{dwarfread.c}\\
Refs Var:\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function decode\_fund\_type()}
\label{func_decode_fund_type_dwarfread.c}

{\stt static struct type* decode\_fund\_type ( unsigned int fundtype )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & dwarf\_fundamental\_type() & dwarfread.c & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & decode\_subscript\_data\_item() & dwarfread.c & \cxreffunc{decode_subscript_data_item}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_line\_numbers()}
\label{func_decode_line_numbers_dwarfread.c}

{\stt static void decode\_line\_numbers ( char* linetable )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & gdbarch\_ptr\_bit() & gdbarch.c & \cxreffunc{gdbarch_ptr_bit}{gdbarch.c}\\
\ & record\_line() & buildsym.c & \cxreffunc{record_line}{buildsym.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & read\_file\_scope() & dwarfread.c & \cxreffunc{read_file_scope}{dwarfread.c}\\
Refs Var:\ & baseaddr & dwarfread.c & \cxrefvar{baseaddr}{dwarfread.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & current\_subfile & buildsym.c & \cxrefvar{current_subfile}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_mod\_fund\_type()}
\label{func_decode_mod_fund_type_dwarfread.c}

{\stt static struct type* decode\_mod\_fund\_type ( char* typedata )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
Refs Var:\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_mod\_u\_d\_type()}
\label{func_decode_mod_u_d_type_dwarfread.c}

{\stt static struct type* decode\_mod\_u\_d\_type ( char* typedata )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
Refs Var:\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_modified\_type()}
\label{func_decode_modified_type_dwarfread.c}

{\stt static struct type* decode\_modified\_type ( char* modifiers, unsigned int modcount, int mtype )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_fund\_type() & dwarfread.c & \cxreffunc{decode_fund_type}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & dwarf\_fundamental\_type() & dwarfread.c & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
Called by:\ & decode\_mod\_fund\_type() & dwarfread.c & \cxreffunc{decode_mod_fund_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_mod\_u\_d\_type() & dwarfread.c & \cxreffunc{decode_mod_u_d_type}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_subscript\_data\_item()}
\label{func_decode_subscript_data_item_dwarfread.c}

{\stt static struct type* decode\_subscript\_data\_item ( char* scan, char* end )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_fund\_type() & dwarfread.c & \cxreffunc{decode_fund_type}{dwarfread.c}\\
\ & decode\_subscript\_data\_item() & dwarfread.c & \cxreffunc{decode_subscript_data_item}{dwarfread.c}\\
\ & dwarf\_fundamental\_type() & dwarfread.c & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
\ & gdbarch\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_bit}{gdbarch.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
Called by:\ & decode\_subscript\_data\_item() & dwarfread.c & \cxreffunc{decode_subscript_data_item}{dwarfread.c}\\
\ & dwarf\_read\_array\_type() & dwarfread.c & \cxreffunc{dwarf_read_array_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dup\_user\_type\_definition\_complaint()}
\label{func_dup_user_type_definition_complaint_dwarfread.c}

{\stt static void dup\_user\_type\_definition\_complaint ( int arg1, const char* arg2 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & dwarf\_read\_array\_type() & dwarfread.c & \cxreffunc{dwarf_read_array_type}{dwarfread.c}\\
\ & read\_subroutine\_type() & dwarfread.c & \cxreffunc{read_subroutine_type}{dwarfread.c}\\
\ & read\_tag\_string\_type() & dwarfread.c & \cxreffunc{read_tag_string_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_fundamental\_type()}
\label{func_dwarf_fundamental_type_dwarfread.c}

{\stt static struct type* dwarf\_fundamental\_type ( struct objfile* objfile, int type\_id )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
Called by:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
\ & decode\_fund\_type() & dwarfread.c & \cxreffunc{decode_fund_type}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & decode\_subscript\_data\_item() & dwarfread.c & \cxreffunc{decode_subscript_data_item}{dwarfread.c}\\
\ & read\_tag\_string\_type() & dwarfread.c & \cxreffunc{read_tag_string_type}{dwarfread.c}\\
Refs Var:\ & cu\_language\_defn & dwarfread.c & \cxrefvar{cu_language_defn}{dwarfread.c}\\
\ & ftypes & dwarfread.c & \cxrefvar{ftypes}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_psymtab\_to\_symtab()}
\label{func_dwarf_psymtab_to_symtab_dwarfread.c}

{\stt static void dwarf\_psymtab\_to\_symtab ( struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & psymtab\_to\_symtab\_1() & dwarfread.c & \cxreffunc{psymtab_to_symtab_1}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Used in:\ & scan\_compilation\_units() & dwarfread.c & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function dwarf\_read\_array\_type()}
\label{func_dwarf_read_array_type_dwarfread.c}

{\stt static void dwarf\_read\_array\_type ( struct dieinfo* dip )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_subscript\_data\_item() & dwarfread.c & \cxreffunc{decode_subscript_data_item}{dwarfread.c}\\
\ & dup\_user\_type\_definition\_complaint() & dwarfread.c & \cxreffunc{dup_user_type_definition_complaint}{dwarfread.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function enum\_type()}
\label{func_enum_type_dwarfread.c}

{\stt static struct type* enum\_type ( struct dieinfo* dip, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & add\_symbol\_to\_list() & buildsym.c & \cxreffunc{add_symbol_to_list}{buildsym.c}\\
\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_name() & dwarfread.c & \cxreffunc{create_name}{dwarfread.c}\\
\ & gdbarch\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_bit}{gdbarch.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & obconcat() & symfile.c & \cxreffunc{obconcat}{symfile.c}\\
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
\ & symbol\_init\_language\_specific() & symtab.c & \cxreffunc{symbol_init_language_specific}{symtab.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk(), strlen()} &\\
Called by:\ & read\_enumeration() & dwarfread.c & \cxreffunc{read_enumeration}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & list\_in\_scope & dwarfread.c & \cxrefvar{list_in_scope}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_utypes()}
\label{func_free_utypes_dwarfread.c}

{\stt static void free\_utypes ( void* dummy )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Used in:\ & read\_file\_scope() & dwarfread.c & \cxreffunc{read_file_scope}{dwarfread.c}\\
Refs Var:\ & numutypes & dwarfread.c & \cxrefvar{numutypes}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & utypes & dwarfread.c & \cxrefvar{utypes}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function handle\_producer()}
\label{func_handle_producer_dwarfread.c}

{\stt static void handle\_producer ( char* producer )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & set\_demangling\_style() & demangle.c & \cxreffunc{set_demangling_style}{demangle.c}\\
\ & \cxreftabiiispan{ strlen(), strncmp()} &\\
Called by:\ & read\_file\_scope() & dwarfread.c & \cxreffunc{read_file_scope}{dwarfread.c}\\
Refs Var:\ & processing\_gcc\_compilation & buildsym.c & \cxrefvar{processing_gcc_compilation}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ current\_demangling\_style} &\\
\end{cxreftabiii}


\subsubsection{Local Function locval()}
\label{func_locval_dwarfread.c}

{\stt static int locval ( struct dieinfo* dip )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & gdbarch\_dwarf\_reg\_to\_regnum() & gdbarch.c & \cxreffunc{gdbarch_dwarf_reg_to_regnum}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_bit}{gdbarch.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
Called by:\ & new\_symbol() & dwarfread.c & \cxreffunc{new_symbol}{dwarfread.c}\\
\ & struct\_type() & dwarfread.c & \cxreffunc{struct_type}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function lookup\_utype()}
\label{func_lookup_utype_dwarfread.c}

{\stt static struct type* lookup\_utype ( DIE\_REF die\_ref )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & bad\_die\_ref\_complaint() & dwarfread.c & \cxreffunc{bad_die_ref_complaint}{dwarfread.c}\\
Called by:\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & dwarf\_read\_array\_type() & dwarfread.c & \cxreffunc{dwarf_read_array_type}{dwarfread.c}\\
\ & enum\_type() & dwarfread.c & \cxreffunc{enum_type}{dwarfread.c}\\
\ & read\_subroutine\_type() & dwarfread.c & \cxreffunc{read_subroutine_type}{dwarfread.c}\\
\ & read\_tag\_pointer\_type() & dwarfread.c & \cxreffunc{read_tag_pointer_type}{dwarfread.c}\\
\ & read\_tag\_string\_type() & dwarfread.c & \cxreffunc{read_tag_string_type}{dwarfread.c}\\
\ & struct\_type() & dwarfread.c & \cxreffunc{struct_type}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\ & numutypes & dwarfread.c & \cxrefvar{numutypes}{dwarfread.c}\\
\ & utypes & dwarfread.c & \cxrefvar{utypes}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function new\_symbol()}
\label{func_new_symbol_dwarfread.c}

{\stt static struct symbol* new\_symbol ( struct dieinfo* dip, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & add\_symbol\_to\_list() & buildsym.c & \cxreffunc{add_symbol_to_list}{buildsym.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
\ & locval() & dwarfread.c & \cxreffunc{locval}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_function\_type() & gdbtypes.c & \cxreffunc{lookup_function_type}{gdbtypes.c}\\
\ & symbol\_set\_names() & symtab.c & \cxreffunc{symbol_set_names}{symtab.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk(), strlen()} &\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\ & read\_enumeration() & dwarfread.c & \cxreffunc{read_enumeration}{dwarfread.c}\\
\ & read\_func\_scope() & dwarfread.c & \cxreffunc{read_func_scope}{dwarfread.c}\\
\ & read\_structure\_scope() & dwarfread.c & \cxreffunc{read_structure_scope}{dwarfread.c}\\
Refs Var:\ & baseaddr & dwarfread.c & \cxrefvar{baseaddr}{dwarfread.c}\\
\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & global\_symbols & buildsym.c & \cxrefvar{global_symbols}{buildsym.c}\\
\ & list\_in\_scope & dwarfread.c & \cxrefvar{list_in_scope}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function process\_dies()}
\label{func_process_dies_dwarfread.c}

{\stt static void process\_dies ( char* thisdie, char* enddie, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & basicdieinfo() & dwarfread.c & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\ & completedieinfo() & dwarfread.c & \cxreffunc{completedieinfo}{dwarfread.c}\\
\ & dwarf\_read\_array\_type() & dwarfread.c & \cxreffunc{dwarf_read_array_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_smash\_text\_address() & gdbarch.c & \cxreffunc{gdbarch_smash_text_address}{gdbarch.c}\\
\ & new\_symbol() & dwarfread.c & \cxreffunc{new_symbol}{dwarfread.c}\\
\ & read\_enumeration() & dwarfread.c & \cxreffunc{read_enumeration}{dwarfread.c}\\
\ & read\_file\_scope() & dwarfread.c & \cxreffunc{read_file_scope}{dwarfread.c}\\
\ & read\_func\_scope() & dwarfread.c & \cxreffunc{read_func_scope}{dwarfread.c}\\
\ & read\_lexical\_block\_scope() & dwarfread.c & \cxreffunc{read_lexical_block_scope}{dwarfread.c}\\
\ & read\_structure\_scope() & dwarfread.c & \cxreffunc{read_structure_scope}{dwarfread.c}\\
\ & read\_subroutine\_type() & dwarfread.c & \cxreffunc{read_subroutine_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_tag\_pointer\_type() & dwarfread.c & \cxreffunc{read_tag_pointer_type}{dwarfread.c}\\
\ & read\_tag\_string\_type() & dwarfread.c & \cxreffunc{read_tag_string_type}{dwarfread.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & read\_file\_scope() & dwarfread.c & \cxreffunc{read_file_scope}{dwarfread.c}\\
\ & read\_func\_scope() & dwarfread.c & \cxreffunc{read_func_scope}{dwarfread.c}\\
\ & read\_lexical\_block\_scope() & dwarfread.c & \cxreffunc{read_lexical_block_scope}{dwarfread.c}\\
\ & read\_ofile\_symtab() & dwarfread.c & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & struct\_type() & dwarfread.c & \cxreffunc{struct_type}{dwarfread.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_subfile & buildsym.c & \cxrefvar{current_subfile}{buildsym.c}\\
\ & dbbase & dwarfread.c & \cxrefvar{dbbase}{dwarfread.c}\\
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function psymtab\_to\_symtab\_1()}
\label{func_psymtab_to_symtab_1_dwarfread.c}

{\stt static void psymtab\_to\_symtab\_1 ( struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & buildsym\_init() & buildsym.c & \cxreffunc{buildsym_init}{buildsym.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & fputs\_filtered() & utils.c & \cxreffunc{fputs_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & psymtab\_to\_symtab\_1() & dwarfread.c & \cxreffunc{psymtab_to_symtab_1}{dwarfread.c}\\
\ & read\_ofile\_symtab() & dwarfread.c & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & wrap\_here() & utils.c & \cxreffunc{wrap_here}{utils.c}\\
Called by:\ & dwarf\_psymtab\_to\_symtab() & dwarfread.c & \cxreffunc{dwarf_psymtab_to_symtab}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & psymtab\_to\_symtab\_1() & dwarfread.c & \cxreffunc{psymtab_to_symtab_1}{dwarfread.c}\\
Refs Func:\ & really\_free\_pendings() & buildsym.c & \cxreffunc{really_free_pendings}{buildsym.c}\\
Refs Var:\ & diecount & dwarfread.c & \cxrefvar{diecount}{dwarfread.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & info\_verbose & top.c & \cxrefvar{info_verbose}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_enumeration()}
\label{func_read_enumeration_dwarfread.c}

{\stt static void read\_enumeration ( struct dieinfo* dip, char* thisdie, char* enddie, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & enum\_type() & dwarfread.c & \cxreffunc{enum_type}{dwarfread.c}\\
\ & new\_symbol() & dwarfread.c & \cxreffunc{new_symbol}{dwarfread.c}\\
\ & synthesize\_typedef() & dwarfread.c & \cxreffunc{synthesize_typedef}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
Refs Var:\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_file\_scope()}
\label{func_read_file_scope_dwarfread.c}

{\stt static void read\_file\_scope ( struct dieinfo* dip, char* thisdie, char* enddie, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & decode\_line\_numbers() & dwarfread.c & \cxreffunc{decode_line_numbers}{dwarfread.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & end\_symtab() & buildsym.c & \cxreffunc{end_symtab}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\ & handle\_producer() & dwarfread.c & \cxreffunc{handle_producer}{dwarfread.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\ & record\_debugformat() & buildsym.c & \cxreffunc{record_debugformat}{buildsym.c}\\
\ & set\_cu\_language() & dwarfread.c & \cxreffunc{set_cu_language}{dwarfread.c}\\
\ & start\_symtab() & buildsym.c & \cxreffunc{start_symtab}{buildsym.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & free\_utypes() & dwarfread.c & \cxreffunc{free_utypes}{dwarfread.c}\\
Refs Var:\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\ & ftypes & dwarfread.c & \cxrefvar{ftypes}{dwarfread.c}\\
\ & lnbase & dwarfread.c & \cxrefvar{lnbase}{dwarfread.c}\\
\ & numutypes & dwarfread.c & \cxrefvar{numutypes}{dwarfread.c}\\
\ & utypes & dwarfread.c & \cxrefvar{utypes}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_func\_scope()}
\label{func_read_func_scope_dwarfread.c}

{\stt static void read\_func\_scope ( struct dieinfo* dip, char* thisdie, char* enddie, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\ & finish\_block() & buildsym.c & \cxreffunc{finish_block}{buildsym.c}\\
\ & new\_symbol() & dwarfread.c & \cxreffunc{new_symbol}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & pop\_context() & buildsym.c & \cxreffunc{pop_context}{buildsym.c}\\
\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\ & push\_context() & buildsym.c & \cxreffunc{push_context}{buildsym.c}\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & file\_symbols & buildsym.c & \cxrefvar{file_symbols}{buildsym.c}\\
\ & list\_in\_scope & dwarfread.c & \cxrefvar{list_in_scope}{dwarfread.c}\\
\ & local\_symbols & buildsym.c & \cxrefvar{local_symbols}{buildsym.c}\\
\cxreftabbreak{cxreftabiii}
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_lexical\_block\_scope()}
\label{func_read_lexical_block_scope_dwarfread.c}

{\stt static void read\_lexical\_block\_scope ( struct dieinfo* dip, char* thisdie, char* enddie, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & finish\_block() & buildsym.c & \cxreffunc{finish_block}{buildsym.c}\\
\ & pop\_context() & buildsym.c & \cxreffunc{pop_context}{buildsym.c}\\
\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & push\_context() & buildsym.c & \cxreffunc{push_context}{buildsym.c}\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
Refs Var:\ & local\_symbols & buildsym.c & \cxrefvar{local_symbols}{buildsym.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_ofile\_symtab()}
\label{func_read_ofile_symtab_dwarfread.c}

{\stt static void read\_ofile\_symtab ( struct partial\_symtab* pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\ & target\_to\_host() & dwarfread.c & \cxreffunc{target_to_host}{dwarfread.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ bfd\_bread(), bfd\_seek()} &\\
Called by:\ & psymtab\_to\_symtab\_1() & dwarfread.c & \cxreffunc{psymtab_to_symtab_1}{dwarfread.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & base\_section\_offsets & dwarfread.c & \cxrefvar{base_section_offsets}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & baseaddr & dwarfread.c & \cxrefvar{baseaddr}{dwarfread.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\ & dbbase & dwarfread.c & \cxrefvar{dbbase}{dwarfread.c}\\
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\ & dbsize & dwarfread.c & \cxrefvar{dbsize}{dwarfread.c}\\
\ & diecount & dwarfread.c & \cxrefvar{diecount}{dwarfread.c}\\
\ & lnbase & dwarfread.c & \cxrefvar{lnbase}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_structure\_scope()}
\label{func_read_structure_scope_dwarfread.c}

{\stt static void read\_structure\_scope ( struct dieinfo* dip, char* thisdie, char* enddie, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & new\_symbol() & dwarfread.c & \cxreffunc{new_symbol}{dwarfread.c}\\
\ & struct\_type() & dwarfread.c & \cxreffunc{struct_type}{dwarfread.c}\\
\ & synthesize\_typedef() & dwarfread.c & \cxreffunc{synthesize_typedef}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
Refs Var:\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_subroutine\_type()}
\label{func_read_subroutine_type_dwarfread.c}

{\stt static void read\_subroutine\_type ( struct dieinfo* dip, char* thisdie, char* enddie )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
\ & dup\_user\_type\_definition\_complaint() & dwarfread.c & \cxreffunc{dup_user_type_definition_complaint}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_function\_type() & gdbtypes.c & \cxreffunc{lookup_function_type}{gdbtypes.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_pointer\_type()}
\label{func_read_tag_pointer_type_dwarfread.c}

{\stt static void read\_tag\_pointer\_type ( struct dieinfo* dip )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
\ & gdbarch\_ptr\_bit() & gdbarch.c & \cxreffunc{gdbarch_ptr_bit}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function read\_tag\_string\_type()}
\label{func_read_tag_string_type_dwarfread.c}

{\stt static void read\_tag\_string\_type ( struct dieinfo* dip )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & create\_string\_type() & gdbtypes.c & \cxreffunc{create_string_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & dup\_user\_type\_definition\_complaint() & dwarfread.c & \cxreffunc{dup_user_type_definition_complaint}{dwarfread.c}\\
\ & dwarf\_fundamental\_type() & dwarfread.c & \cxreffunc{dwarf_fundamental_type}{dwarfread.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
Called by:\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_objfile & objfiles.c & \cxrefvar{current_objfile}{objfiles.c}\\
\end{cxreftabiii}


\subsubsection{Local Function scan\_compilation\_units()}
\label{func_scan_compilation_units_dwarfread.c}

{\stt static void scan\_compilation\_units ( char* thisdie, char* enddie, file\_ptr dbfoff, file\_ptr lnoffset, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & basicdieinfo() & dwarfread.c & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\ & completedieinfo() & dwarfread.c & \cxreffunc{completedieinfo}{dwarfread.c}\\
\ & free\_named\_symtabs() & symfile.c & \cxreffunc{free_named_symtabs}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & scan\_partial\_symbols() & dwarfread.c & \cxreffunc{scan_partial_symbols}{dwarfread.c}\\
\ & set\_cu\_language() & dwarfread.c & \cxreffunc{set_cu_language}{dwarfread.c}\\
\ & sort\_pst\_symbols() & symfile.c & \cxreffunc{sort_pst_symbols}{symfile.c}\\
\ & start\_psymtab\_common() & symfile.c & \cxreffunc{start_psymtab_common}{symfile.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_obstack\_newchunk()} &\\
Called by:\ & dwarf\_build\_psymtabs() & dwarfread.c & \cxreffunc{dwarf_build_psymtabs}{dwarfread.c}\\
Refs Func:\ & dwarf\_psymtab\_to\_symtab() & dwarfread.c & \cxreffunc{dwarf_psymtab_to_symtab}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & base\_section\_offsets & dwarfread.c & \cxrefvar{base_section_offsets}{dwarfread.c}\\
\ & dbbase & dwarfread.c & \cxrefvar{dbbase}{dwarfread.c}\\
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function scan\_partial\_symbols()}
\label{func_scan_partial_symbols_dwarfread.c}

{\stt static void scan\_partial\_symbols ( char* thisdie, char* enddie, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & add\_enum\_psymbol() & dwarfread.c & \cxreffunc{add_enum_psymbol}{dwarfread.c}\\
\ & add\_partial\_symbol() & dwarfread.c & \cxreffunc{add_partial_symbol}{dwarfread.c}\\
\ & bad\_die\_ref\_complaint() & dwarfread.c & \cxreffunc{bad_die_ref_complaint}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & basicdieinfo() & dwarfread.c & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\ & completedieinfo() & dwarfread.c & \cxreffunc{completedieinfo}{dwarfread.c}\\
Called by:\ & scan\_compilation\_units() & dwarfread.c & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & dbbase & dwarfread.c & \cxrefvar{dbbase}{dwarfread.c}\\
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_cu\_language()}
\label{func_set_cu_language_dwarfread.c}

{\stt static void set\_cu\_language ( struct dieinfo* dip )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & deduce\_language\_from\_filename() & symfile.c & \cxreffunc{deduce_language_from_filename}{symfile.c}\\
\ & language\_def() & language.c & \cxreffunc{language_def}{language.c}\\
Called by:\ & read\_file\_scope() & dwarfread.c & \cxreffunc{read_file_scope}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & scan\_compilation\_units() & dwarfread.c & \cxreffunc{scan_compilation_units}{dwarfread.c}\\
Refs Var:\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\ & cu\_language\_defn & dwarfread.c & \cxrefvar{cu_language_defn}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function struct\_type()}
\label{func_struct_type_dwarfread.c}

{\stt static struct type* struct\_type ( struct dieinfo* dip, char* thisdie, char* enddie, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & alloc\_utype() & dwarfread.c & \cxreffunc{alloc_utype}{dwarfread.c}\\
\ & basicdieinfo() & dwarfread.c & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\ & completedieinfo() & dwarfread.c & \cxreffunc{completedieinfo}{dwarfread.c}\\
\ & decode\_die\_type() & dwarfread.c & \cxreffunc{decode_die_type}{dwarfread.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\ & locval() & dwarfread.c & \cxreffunc{locval}{dwarfread.c}\\
\ & lookup\_utype() & dwarfread.c & \cxreffunc{lookup_utype}{dwarfread.c}\\
\ & obconcat() & symfile.c & \cxreffunc{obconcat}{symfile.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & process\_dies() & dwarfread.c & \cxreffunc{process_dies}{dwarfread.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca(), \_obstack\_newchunk(), strlen()} &\\
Called by:\ & read\_structure\_scope() & dwarfread.c & \cxreffunc{read_structure_scope}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & dbbase & dwarfread.c & \cxrefvar{dbbase}{dwarfread.c}\\
\ & dbroff & dwarfread.c & \cxrefvar{dbroff}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function synthesize\_typedef()}
\label{func_synthesize_typedef_dwarfread.c}

{\stt static void synthesize\_typedef ( struct dieinfo* dip, struct objfile* objfile, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & add\_symbol\_to\_list() & buildsym.c & \cxreffunc{add_symbol_to_list}{buildsym.c}\\
\ & create\_name() & dwarfread.c & \cxreffunc{create_name}{dwarfread.c}\\
\ & symbol\_init\_language\_specific() & symtab.c & \cxreffunc{symbol_init_language_specific}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & read\_enumeration() & dwarfread.c & \cxreffunc{read_enumeration}{dwarfread.c}\\
\ & read\_structure\_scope() & dwarfread.c & \cxreffunc{read_structure_scope}{dwarfread.c}\\
Refs Var:\ & cu\_language & dwarfread.c & \cxrefvar{cu_language}{dwarfread.c}\\
\ & list\_in\_scope & dwarfread.c & \cxrefvar{list_in_scope}{dwarfread.c}\\
\end{cxreftabiii}


\subsubsection{Local Function target\_to\_host()}
\label{func_target_to_host_dwarfread.c}

{\stt static CORE\_ADDR target\_to\_host ( char* from, int nbytes, int signextend, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& dwarfread.c & \ & \cxreffile{dwarfread.c}\\
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & add\_enum\_psymbol() & dwarfread.c & \cxreffunc{add_enum_psymbol}{dwarfread.c}\\
\ & basicdieinfo() & dwarfread.c & \cxreffunc{basicdieinfo}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & completedieinfo() & dwarfread.c & \cxreffunc{completedieinfo}{dwarfread.c}\\
\ & decode\_array\_element\_type() & dwarfread.c & \cxreffunc{decode_array_element_type}{dwarfread.c}\\
\ & decode\_line\_numbers() & dwarfread.c & \cxreffunc{decode_line_numbers}{dwarfread.c}\\
\ & decode\_mod\_fund\_type() & dwarfread.c & \cxreffunc{decode_mod_fund_type}{dwarfread.c}\\
\ & decode\_mod\_u\_d\_type() & dwarfread.c & \cxreffunc{decode_mod_u_d_type}{dwarfread.c}\\
\ & decode\_modified\_type() & dwarfread.c & \cxreffunc{decode_modified_type}{dwarfread.c}\\
\ & decode\_subscript\_data\_item() & dwarfread.c & \cxreffunc{decode_subscript_data_item}{dwarfread.c}\\
\ & dwarf\_read\_array\_type() & dwarfread.c & \cxreffunc{dwarf_read_array_type}{dwarfread.c}\\
\cxreftabbreak{cxreftabiii}
\ & enum\_type() & dwarfread.c & \cxreffunc{enum_type}{dwarfread.c}\\
\ & locval() & dwarfread.c & \cxreffunc{locval}{dwarfread.c}\\
\ & read\_ofile\_symtab() & dwarfread.c & \cxreffunc{read_ofile_symtab}{dwarfread.c}\\
Refs Var:\ & curdie & dwarfread.c & \cxrefvar{curdie}{dwarfread.c}\\
\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\end{cxreftabiii}


\subsubsection{Local Function unknown\_attribute\_form\_complaint()}
\label{func_unknown_attribute_form_complaint_dwarfread.c}

{\stt static void unknown\_attribute\_form\_complaint ( int arg1, const char* arg2, int arg3 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & complaint() & complaints.c & \cxreffunc{complaint}{complaints.c}\\
Called by:\ & attribute\_size() & dwarfread.c & \cxreffunc{attribute_size}{dwarfread.c}\\
\ & completedieinfo() & dwarfread.c & \cxreffunc{completedieinfo}{dwarfread.c}\\
Refs Var:\ & symfile\_complaints & complaints.c & \cxrefvar{symfile_complaints}{complaints.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}

