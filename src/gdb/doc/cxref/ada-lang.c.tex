% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF ada-lang.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File ada-lang.c}{File ada-lang.c}
\section{File ada-lang.c}
\label{file_ada-lang.c}

\smallskip
\begin{cxreftabiii}
Refs Func:\ & ada\_create\_fundamental\_type() & ada-lang.c & \cxreffunc{ada_create_fundamental_type}{ada-lang.c}\\
\ & ada\_dump\_subexp\_body() & ada-lang.c & \cxreffunc{ada_dump_subexp_body}{ada-lang.c}\\
\ & ada\_error() & ada-exp.c & \cxreffunc{ada_error}{ada-exp.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_get\_gdb\_completer\_word\_break\_characters() & ada-lang.c & \cxreffunc{ada_get_gdb_completer_word_break_characters}{ada-lang.c}\\
\ & ada\_la\_decode() & ada-lang.c & \cxreffunc{ada_la_decode}{ada-lang.c}\\
\ & ada\_language\_arch\_info() & ada-lang.c & \cxreffunc{ada_language_arch_info}{ada-lang.c}\\
\ & ada\_lookup\_symbol\_nonlocal() & ada-lang.c & \cxreffunc{ada_lookup_symbol_nonlocal}{ada-lang.c}\\
\ & ada\_op\_name() & ada-lang.c & \cxreffunc{ada_op_name}{ada-lang.c}\\
\ & ada\_operator\_length() & ada-lang.c & \cxreffunc{ada_operator_length}{ada-lang.c}\\
\ & ada\_print\_subexp() & ada-lang.c & \cxreffunc{ada_print_subexp}{ada-lang.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_printchar() & ada-valprint.c & \cxreffunc{ada_printchar}{ada-valprint.c}\\
\ & ada\_printstr() & ada-valprint.c & \cxreffunc{ada_printstr}{ada-valprint.c}\\
\ & ada\_val\_print() & ada-valprint.c & \cxreffunc{ada_val_print}{ada-valprint.c}\\
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\ & basic\_lookup\_transparent\_type() & symtab.c & \cxreffunc{basic_lookup_transparent_type}{symtab.c}\\
\ & emit\_char() & ada-lang.c & \cxreffunc{emit_char}{ada-lang.c}\\
\ & parse() & ada-lang.c & \cxreffunc{parse}{ada-lang.c}\\
\ & resolve() & ada-lang.c & \cxreffunc{resolve}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & ada\_exp\_descriptor & ada-lang.c & \cxrefvar{ada_exp_descriptor}{ada-lang.c}\\
\ & ada\_op\_print\_tab & ada-lang.c & \cxrefvar{ada_op_print_tab}{ada-lang.c}\\
\end{cxreftabiii}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <stdio.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <ctype.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <stdarg.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/demangle.h"} &\cxreffile{../include/demangle.h}\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{0.8in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{0.6in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.6in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "parser-defs.h"} &\cxreffile{parser-defs.h}\\
\hspace*{0.2in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "c-lang.h"} &\cxreffile{c-lang.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "macroexp.h"} &\cxreffile{macroexp.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inferior.h"} &\cxreffile{inferior.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.4in}{\stt \#include "gdb-events.h"} &\cxreffile{gdb-events.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <uuid/uuid.h>} &\\
\hspace*{0.2in}{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/obstack.h"} &\cxreffile{../include/obstack.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcore.h"} &\cxreffile{gdbcore.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/hashtab.h"} &\cxreffile{../include/hashtab.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "ada-lang.h"} &\cxreffile{ada-lang.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "completer.h"} &\cxreffile{completer.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_stat.h"} &\cxreffile{gdb_stat.h}\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/stat.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "block.h"} &\cxreffile{block.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "infcall.h"} &\cxreffile{infcall.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "dictionary.h"} &\cxreffile{dictionary.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "exceptions.h"} &\cxreffile{exceptions.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\hspace*{0.2in}{\stt \#include <setjmp.h>} &\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define ADA\_RETAIN\_DOTS 0}

\medskip
{\stt \#define TRUNCATION\_TOWARDS\_ZERO}

\medskip
{\stt \#define MAX\_ADA\_DIMENS}

\medskip
{\stt \#define EXP\_OPCODE\_OPERATORS}

\medskip
{\stt \#define ADA\_OPERATORS}

\medskip
{\stt \#define OP\_DEFN( op, len, args, binop )}

\medskip
{\stt \#define OP\_DEFN( op, len, args, binop )}

\medskip
{\stt \#define OP\_DEFN( op, len, args, binop )}


\subsection{Type definitions}


\subsubsection{Type struct tag\_args}
\label{type_struct_tag_args_ada-lang.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct tag\_args} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct value* tag;} &\\
\hspace*{0.2in}{\stt char* name;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum ada\_primitive\_types}
\label{type_enum_ada_primitive_types_ada-lang.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum ada\_primitive\_types} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_int;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_long;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_short;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt ada\_primitive\_type\_char;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_float;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_double;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_void;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_long\_long;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_long\_double;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_natural;} &\\
\hspace*{0.2in}{\stt ada\_primitive\_type\_positive;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt ada\_primitive\_type\_system\_address;} &\\
\hspace*{0.2in}{\stt nr\_ada\_primitive\_types;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable ada\_opname\_table}
\label{var_ada_opname_table_ada-lang.c}

{\stt const struct ada\_opname\_map ada\_opname\_table[]}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-exp.c & \ & \cxreffile{ada-exp.c}\\
\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & ada-typeprint.c & \ & \cxreffile{ada-typeprint.c}\\
\ & ada-valprint.c & \ & \cxreffile{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & symtab.c & \ & \cxreffile{symtab.c}\\
Used in:\ & ada\_decode() & ada-lang.c & \cxreffunc{ada_decode}{ada-lang.c}\\
\ & ada\_decoded\_op\_name() & ada-lang.c & \cxreffunc{ada_decoded_op_name}{ada-lang.c}\\
\ & ada\_encode() & ada-lang.c & \cxreffunc{ada_encode}{ada-lang.c}\\
\ & is\_suppressed\_name() & ada-lang.c & \cxreffunc{is_suppressed_name}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & string\_to\_operator() & ada-exp.c & \cxreffunc{string_to_operator}{ada-exp.c}\\
\end{cxreftabiii}


\subsubsection{Variable ada\_language\_defn}
\label{var_ada_language_defn_ada-lang.c}

{\stt const struct language\_defn ada\_language\_defn}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Used in:\ & \_initialize\_ada\_language() & ada-lang.c & \cxreffunc{_initialize_ada_language}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf varsize\_limit}
\label{var_varsize_limit_ada-lang.c}

{\stt static unsigned int varsize\_limit}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_ada\_language() & \ & \cxreffunc{_initialize_ada_language}{ada-lang.c}\\
\ & ada\_template\_to\_fixed\_record\_type\_1() & \ & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & check\_size() & \ & \cxreffunc{check_size}{ada-lang.c}\\
\ & to\_fixed\_array\_type() & \ & \cxreffunc{to_fixed_array_type}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf ada\_completer\_word\_break\_characters}
\label{var_ada_completer_word_break_characters_ada-lang.c}

{\stt static const char* ada\_completer\_word\_break\_characters}

\smallskip
\begin{cxreftabiii}
Used in:\ & ada\_get\_gdb\_completer\_word\_break\_characters() & \ & \cxreffunc{ada_get_gdb_completer_word_break_characters}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf ADA\_MAIN\_PROGRAM\_SYMBOL\_NAME}
\label{var_ADA_MAIN_PROGRAM_SYMBOL_NAME_ada-lang.c}

{\stt static const char ADA\_MAIN\_PROGRAM\_SYMBOL\_NAME[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & ada\_main\_name() & \ & \cxreffunc{ada_main_name}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf warning\_limit}
\label{var_warning_limit_ada-lang.c}

{\stt static int warning\_limit}

\smallskip
\begin{cxreftabiii}
Used in:\ & lim\_warning() & \ & \cxreffunc{lim_warning}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf warnings\_issued}
\label{var_warnings_issued_ada-lang.c}

{\stt static int warnings\_issued}

\smallskip
\begin{cxreftabiii}
Used in:\ & lim\_warning() & \ & \cxreffunc{lim_warning}{ada-lang.c}\\
\ & parse() & \ & \cxreffunc{parse}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf symbol\_list\_obstack}
\label{var_symbol_list_obstack_ada-lang.c}

{\stt static struct obstack symbol\_list\_obstack}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_ada\_language() & \ & \cxreffunc{_initialize_ada_language}{ada-lang.c}\\
\ & ada\_lookup\_symbol\_list() & \ & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf decoded\_names\_store}
\label{var_decoded_names_store_ada-lang.c}

{\stt static struct htab* decoded\_names\_store}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_ada\_language() & \ & \cxreffunc{_initialize_ada_language}{ada-lang.c}\\
\ & ada\_decode\_symbol() & \ & \cxreffunc{ada_decode_symbol}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf bound\_name}
\label{var_bound_name_ada-lang.c}

{\stt static const char* bound\_name[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & desc\_index\_type() & \ & \cxreffunc{desc_index_type}{ada-lang.c}\\
\ & desc\_one\_bound() & \ & \cxreffunc{desc_one_bound}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf attribute\_names}
\label{var_attribute_names_ada-lang.c}

{\stt static const char* attribute\_names[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & ada\_attribute\_name() & \ & \cxreffunc{ada_attribute_name}{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf ada\_op\_print\_tab}
\label{var_ada_op_print_tab_ada-lang.c}

{\stt static const struct op\_print ada\_op\_print\_tab[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}

\medskip
{\bf ada\_exp\_descriptor}
\label{var_ada_exp_descriptor_ada-lang.c}

{\stt static const struct exp\_descriptor ada\_exp\_descriptor}

\smallskip
\begin{cxreftabiii}
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_ada\_language()}
\label{func__initialize_ada_language_ada-lang.c}

{\stt void \_initialize\_ada\_language ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & add\_language() & language.c & \cxreffunc{add_language}{language.c}\\
\ & \cxreftabiiispan{ \_obstack\_begin(), htab\_create\_alloc()} &\\
Refs Func:\ & streq() & utils.c & \cxreffunc{streq}{utils.c}\\
\ & xcalloc() & utils.c & \cxreffunc{xcalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ htab\_hash\_string()} &\\
Refs Var:\ & ada\_language\_defn & ada-lang.c & \cxrefvar{ada_language_defn}{ada-lang.c}\\
\ & decoded\_names\_store & ada-lang.c & \cxrefvar{decoded_names_store}{ada-lang.c}\\
\ & symbol\_list\_obstack & ada-lang.c & \cxrefvar{symbol_list_obstack}{ada-lang.c}\\
\ & varsize\_limit & ada-lang.c & \cxrefvar{varsize_limit}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_aligned\_type()}
\label{func_ada_aligned_type_ada-lang.c}

{\stt struct type* ada\_aligned\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_aligned\_type() & ada-lang.c & \cxreffunc{ada_aligned_type}{ada-lang.c}\\
\ & ada\_get\_base\_type() & ada-lang.c & \cxreffunc{ada_get_base_type}{ada-lang.c}\\
\ & ada\_is\_aligner\_type() & ada-lang.c & \cxreffunc{ada_is_aligner_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_aligned\_type() & ada-lang.c & \cxreffunc{ada_aligned_type}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & printable\_val\_type() & ada-valprint.c & \cxreffunc{printable_val_type}{ada-valprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_aligned\_value\_addr()}
\label{func_ada_aligned_value_addr_ada-lang.c}

{\stt const gdb\_byte* ada\_aligned\_value\_addr ( struct type* type, const gdb\_byte* valaddr )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_aligned\_value\_addr() & ada-lang.c & \cxreffunc{ada_aligned_value_addr}{ada-lang.c}\\
\ & ada\_is\_aligner\_type() & ada-lang.c & \cxreffunc{ada_is_aligner_type}{ada-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_aligned\_value\_addr() & ada-lang.c & \cxreffunc{ada_aligned_value_addr}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_array\_arity()}
\label{func_ada_array_arity_ada-lang.c}

{\stt int ada\_array\_arity ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & desc\_arity() & ada-lang.c & \cxreffunc{desc_arity}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & ada\_array\_element\_type() & ada-lang.c & \cxreffunc{ada_array_element_type}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_index\_type() & ada-lang.c & \cxreffunc{ada_index_type}{ada-lang.c}\\
\ & ada\_is\_string\_type() & ada-lang.c & \cxreffunc{ada_is_string_type}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_array\_type() & ada-typeprint.c & \cxreffunc{print_array_type}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_array\_bound()}
\label{func_ada_array_bound_ada-lang.c}

{\stt struct value* ada\_array\_bound ( struct value* arr, int n, int which )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_array\_bound\_from\_type() & ada-lang.c & \cxreffunc{ada_array_bound_from_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_is\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_is_simple_array_type}{ada-lang.c}\\
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & desc\_one\_bound() & ada-lang.c & \cxreffunc{desc_one_bound}{ada-lang.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_array\_bound\_from\_type()}
\label{func_ada_array_bound_from_type_ada-lang.c}

{\stt long ada\_array\_bound\_from\_type ( struct type* arr\_type, int n, int which, struct type** typep )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\ & ada\_is\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_is_simple_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
Called by:\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & builtin\_type\_long & gdbtypes.c & \cxrefvar{builtin_type_long}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_array\_element\_type()}
\label{func_ada_array_element_type_ada-lang.c}

{\stt struct type* ada\_array\_element\_type ( struct type* type, int nindices )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_data\_type() & ada-lang.c & \cxreffunc{desc_data_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_is\_string\_type() & ada-lang.c & \cxreffunc{ada_is_string_type}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & empty\_array() & ada-lang.c & \cxreffunc{empty_array}{ada-lang.c}\\
\ & print\_array\_type() & ada-typeprint.c & \cxreffunc{print_array_type}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_array\_length()}
\label{func_ada_array_length_ada-lang.c}

{\stt struct value* ada\_array\_length ( struct value* arr, int n )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_array\_bound\_from\_type() & ada-lang.c & \cxreffunc{ada_array_bound_from_type}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\ & ada\_is\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_is_simple_array_type}{ada-lang.c}\\
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & desc\_one\_bound() & ada-lang.c & \cxreffunc{desc_one_bound}{ada-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_attribute\_name()}
\label{func_ada_attribute_name_ada-lang.c}

{\stt const char* ada\_attribute\_name ( enum exp\_opcode n )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_print\_subexp() & ada-lang.c & \cxreffunc{ada_print_subexp}{ada-lang.c}\\
Refs Var:\ & attribute\_names & ada-lang.c & \cxrefvar{attribute_names}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_check\_typedef()}
\label{func_ada_check_typedef_ada-lang.c}

{\stt struct type* ada\_check\_typedef ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_find\_any\_type() & ada-lang.c & \cxreffunc{ada_find_any_type}{ada-lang.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
Called by:\ & ada\_args\_match() & ada-lang.c & \cxreffunc{ada_args_match}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_array\_element\_type() & ada-lang.c & \cxreffunc{ada_array_element_type}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_is\_aligner\_type() & ada-lang.c & \cxreffunc{ada_is_aligner_type}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_is\_direct\_array\_type() & ada-lang.c & \cxreffunc{ada_is_direct_array_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_is\_parent\_field() & ada-lang.c & \cxreffunc{ada_is_parent_field}{ada-lang.c}\\
\ & ada\_is\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_is_simple_array_type}{ada-lang.c}\\
\ & ada\_is\_string\_type() & ada-lang.c & \cxreffunc{ada_is_string_type}{ada-lang.c}\\
\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & ada\_parent\_type() & ada-lang.c & \cxreffunc{ada_parent_type}{ada-lang.c}\\
\ & ada\_print\_scalar() & ada-valprint.c & \cxreffunc{ada_print_scalar}{ada-valprint.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & ada\_resolve\_function() & ada-lang.c & \cxreffunc{ada_resolve_function}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\ & ada\_type\_match() & ada-lang.c & \cxreffunc{ada_type_match}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_binop() & ada-lang.c & \cxreffunc{ada_value_binop}{ada-lang.c}\\
\ & ada\_value\_primitive\_field() & ada-lang.c & \cxreffunc{ada_value_primitive_field}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & ada\_value\_subscript() & ada-lang.c & \cxreffunc{ada_value_subscript}{ada-lang.c}\\
\ & add\_defn\_to\_vec() & ada-lang.c & \cxreffunc{add_defn_to_vec}{ada-lang.c}\\
\ & coerce\_for\_assign() & ada-lang.c & \cxreffunc{coerce_for_assign}{ada-lang.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\ & dynamic\_template\_type() & ada-lang.c & \cxreffunc{dynamic_template_type}{ada-lang.c}\\
\ & ensure\_lval() & ada-lang.c & \cxreffunc{ensure_lval}{ada-lang.c}\\
\ & fat\_pntr\_bounds\_bitsize() & ada-lang.c & \cxreffunc{fat_pntr_bounds_bitsize}{ada-lang.c}\\
\ & find\_struct\_field() & ada-lang.c & \cxreffunc{find_struct_field}{ada-lang.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\ & packed\_array\_type() & ada-lang.c & \cxreffunc{packed_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & possible\_user\_operator\_p() & ada-lang.c & \cxreffunc{possible_user_operator_p}{ada-lang.c}\\
\ & print\_record() & ada-valprint.c & \cxreffunc{print_record}{ada-valprint.c}\\
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\ & template\_to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{template_to_static_fixed_type}{ada-lang.c}\\
\ & to\_fixed\_array\_type() & ada-lang.c & \cxreffunc{to_fixed_array_type}{ada-lang.c}\\
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\ & value\_subscript\_packed() & ada-lang.c & \cxreffunc{value_subscript_packed}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_coerce\_to\_simple\_array\_ptr()}
\label{func_ada_coerce_to_simple_array_ptr_ada-lang.c}

{\stt struct value* ada\_coerce\_to\_simple\_array\_ptr ( struct value* arr )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\ & desc\_data() & ada-lang.c & \cxreffunc{desc_data}{ada-lang.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_coerce\_to\_simple\_array\_type()}
\label{func_ada_coerce_to_simple_array_type_ada-lang.c}

{\stt struct type* ada\_coerce\_to\_simple\_array\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
Called by:\ & print\_array\_type() & ada-typeprint.c & \cxreffunc{print_array_type}{ada-typeprint.c}\\
Refs Var:\ & builtin\_type\_long & gdbtypes.c & \cxrefvar{builtin_type_long}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_convert\_actuals()}
\label{func_ada_convert_actuals_ada-lang.c}

{\stt void ada\_convert\_actuals ( struct value* func, int nargs, struct value* args[], CORE\_ADDR* sp )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_decode()}
\label{func_ada_decode_ada-lang.c}

{\stt const char* ada\_decode ( const char* encoded )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & grow\_vect() & ada-lang.c & \cxreffunc{grow_vect}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), isalnum(), isalpha(), isdigit(), isupper(), strcmp(), strlen(), strncmp(), strstr()} &\\
Called by:\ & ada\_decode\_symbol() & ada-lang.c & \cxreffunc{ada_decode_symbol}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_la\_decode() & ada-lang.c & \cxreffunc{ada_la_decode}{ada-lang.c}\\
\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\ & write\_object\_renaming() & ada-exp.c & \cxreffunc{write_object_renaming}{ada-exp.c}\\
Refs Var:\ & ada\_opname\_table & ada-lang.c & \cxrefvar{ada_opname_table}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_decode\_symbol()}
\label{func_ada_decode_symbol_ada-lang.c}

{\stt char* ada\_decode\_symbol ( const struct general\_symbol\_info* gsymbol )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_decode() & ada-lang.c & \cxreffunc{ada_decode}{ada-lang.c}\\
\ & objfile\_get\_first() & objfiles.c & \cxreffunc{objfile_get_first}{objfiles.c}\\
\ & objfile\_get\_next() & objfiles.c & \cxreffunc{objfile_get_next}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & obsavestring() & symfile.c & \cxreffunc{obsavestring}{symfile.c}\\
\ & \cxreftabiiispan{ htab\_find\_slot(), strlen(), xstrdup()} &\\
Called by:\ & symbol\_demangled\_name() & symtab.c & \cxreffunc{symbol_demangled_name}{symtab.c}\\
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
Refs Var:\ & decoded\_names\_store & ada-lang.c & \cxrefvar{decoded_names_store}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_delta()}
\label{func_ada_delta_ada-lang.c}

{\stt DOUBLEST ada\_delta ( struct type* the\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & fixed\_type\_info() & ada-lang.c & \cxreffunc{fixed_type_info}{ada-lang.c}\\
\ & \cxreftabiiispan{ sscanf()} &\\
Called by:\ & print\_fixed\_point\_type() & ada-typeprint.c & \cxreffunc{print_fixed_point_type}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_encode()}
\label{func_ada_encode_ada-lang.c}

{\stt char* ada\_encode ( const char* decoded )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & grow\_vect() & ada-lang.c & \cxreffunc{grow_vect}{ada-lang.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), strlen(), strncmp()} &\\
Called by:\ & ada\_lex() & ada-exp.c & \cxreffunc{ada_lex}{ada-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_lookup\_symbol() & ada-lang.c & \cxreffunc{ada_lookup_symbol}{ada-lang.c}\\
\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
\ & type\_from\_tag() & ada-lang.c & \cxreffunc{type_from_tag}{ada-lang.c}\\
\ & write\_var\_from\_name() & ada-exp.c & \cxreffunc{write_var_from_name}{ada-exp.c}\\
Refs Var:\ & ada\_opname\_table & ada-lang.c & \cxrefvar{ada_opname_table}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_enum\_name()}
\label{func_ada_enum_name_ada-lang.c}

{\stt const char* ada\_enum\_name ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & grow\_vect() & ada-lang.c & \cxreffunc{grow_vect}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), isascii(), isdigit(), isprint(), sscanf(), strrchr(), strstr()} &\\
Called by:\ & ada\_print\_scalar() & ada-valprint.c & \cxreffunc{ada_print_scalar}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & print\_enum\_type() & ada-typeprint.c & \cxreffunc{print_enum_type}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_evaluate\_subexp()}
\label{func_ada_evaluate_subexp_ada-lang.c}

{\stt struct value* ada\_evaluate\_subexp ( struct type* expect\_type, struct expression* exp, int* pos, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_aligned\_type() & ada-lang.c & \cxreffunc{ada_aligned_type}{ada-lang.c}\\
\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_array\_bound\_from\_type() & ada-lang.c & \cxreffunc{ada_array_bound_from_type}{ada-lang.c}\\
\ & ada\_array\_element\_type() & ada-lang.c & \cxreffunc{ada_array_element_type}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_attribute\_name() & ada-lang.c & \cxreffunc{ada_attribute_name}{ada-lang.c}\\
\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_coerce\_ref() & ada-lang.c & \cxreffunc{ada_coerce_ref}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_index\_type() & ada-lang.c & \cxreffunc{ada_index_type}{ada-lang.c}\\
\ & ada\_is\_aligner\_type() & ada-lang.c & \cxreffunc{ada_is_aligner_type}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_is\_fixed\_point\_type() & ada-lang.c & \cxreffunc{ada_is_fixed_point_type}{ada-lang.c}\\
\ & ada\_is\_modular\_type() & ada-lang.c & \cxreffunc{ada_is_modular_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\ & ada\_is\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_is_simple_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_is\_tagged\_type() & ada-lang.c & \cxreffunc{ada_is_tagged_type}{ada-lang.c}\\
\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & ada\_modulus() & ada-lang.c & \cxreffunc{ada_modulus}{ada-lang.c}\\
\ & ada\_tag\_type() & ada-lang.c & \cxreffunc{ada_tag_type}{ada-lang.c}\\
\ & ada\_to\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_fixed_value}{ada-lang.c}\\
\ & ada\_to\_fixed\_value\_create() & ada-lang.c & \cxreffunc{ada_to_fixed_value_create}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_binop() & ada-lang.c & \cxreffunc{ada_value_binop}{ada-lang.c}\\
\ & ada\_value\_equal() & ada-lang.c & \cxreffunc{ada_value_equal}{ada-lang.c}\\
\ & ada\_value\_ind() & ada-lang.c & \cxreffunc{ada_value_ind}{ada-lang.c}\\
\ & ada\_value\_ptr\_subscript() & ada-lang.c & \cxreffunc{ada_value_ptr_subscript}{ada-lang.c}\\
\ & ada\_value\_slice() & ada-lang.c & \cxreffunc{ada_value_slice}{ada-lang.c}\\
\ & ada\_value\_slice\_ptr() & ada-lang.c & \cxreffunc{ada_value_slice_ptr}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_subscript() & ada-lang.c & \cxreffunc{ada_value_subscript}{ada-lang.c}\\
\ & ada\_value\_tag() & ada-lang.c & \cxreffunc{ada_value_tag}{ada-lang.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & call\_function\_by\_hand() & infcall.c & \cxreffunc{call_function_by_hand}{infcall.c}\\
\ & cast\_from\_fixed\_to\_double() & ada-lang.c & \cxreffunc{cast_from_fixed_to_double}{ada-lang.c}\\
\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\ & check\_size() & ada-lang.c & \cxreffunc{check_size}{ada-lang.c}\\
\ & coerce\_for\_assign() & ada-lang.c & \cxreffunc{coerce_for_assign}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & discrete\_type\_high\_bound() & ada-lang.c & \cxreffunc{discrete_type_high_bound}{ada-lang.c}\\
\ & discrete\_type\_low\_bound() & ada-lang.c & \cxreffunc{discrete_type_low_bound}{ada-lang.c}\\
\ & discrete\_type\_p() & ada-lang.c & \cxreffunc{discrete_type_p}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & empty\_array() & ada-lang.c & \cxreffunc{empty_array}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & evaluate\_subexp() & ada-lang.c & \cxreffunc{evaluate_subexp}{ada-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & evaluate\_subexp\_with\_coercion() & eval.c & \cxreffunc{evaluate_subexp_with_coercion}{eval.c}\\
\ & lang\_bool\_type() & language.c & \cxreffunc{lang_bool_type}{language.c}\\
\ & lim\_warning() & ada-lang.c & \cxreffunc{lim_warning}{ada-lang.c}\\
\ & longest\_to\_int() & valprint.c & \cxreffunc{longest_to_int}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & pos\_atr() & ada-lang.c & \cxreffunc{pos_atr}{ada-lang.c}\\
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
\ & to\_fixed\_array\_type() & ada-lang.c & \cxreffunc{to_fixed_array_type}{ada-lang.c}\\
\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_add() & valarith.c & \cxreffunc{value_add}{valarith.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_less() & valarith.c & \cxreffunc{value_less}{valarith.c}\\
\ & value\_neg() & valarith.c & \cxreffunc{value_neg}{valarith.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_pos\_atr() & ada-lang.c & \cxreffunc{value_pos_atr}{ada-lang.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & value\_val\_atr() & ada-lang.c & \cxreffunc{value_val_atr}{ada-lang.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & builtin\_type\_long & gdbtypes.c & \cxrefvar{builtin_type_long}{gdbtypes.c}\\
\ & builtin\_type\_void & gdbtypes.c & \cxrefvar{builtin_type_void}{gdbtypes.c}\\
\ & demangle & utils.c & \cxrefvar{demangle}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_find\_any\_symbol()}
\label{func_ada_find_any_symbol_ada-lang.c}

{\stt struct symbol* ada\_find\_any\_symbol ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & get\_selected\_block() & stack.c & \cxreffunc{get_selected_block}{stack.c}\\
\ & standard\_lookup() & ada-lang.c & \cxreffunc{standard_lookup}{ada-lang.c}\\
Called by:\ & ada\_find\_any\_type() & ada-lang.c & \cxreffunc{ada_find_any_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_find\_renaming\_symbol() & ada-lang.c & \cxreffunc{ada_find_renaming_symbol}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_find\_any\_type()}
\label{func_ada_find_any_type_ada-lang.c}

{\stt struct type* ada\_find\_any\_type ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_find\_any\_symbol() & ada-lang.c & \cxreffunc{ada_find_any_symbol}{ada-lang.c}\\
Called by:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_get\_base\_type() & ada-lang.c & \cxreffunc{ada_get_base_type}{ada-lang.c}\\
\ & print\_range\_type\_named() & ada-typeprint.c & \cxreffunc{print_range_type_named}{ada-typeprint.c}\\
\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
\ & type\_from\_tag() & ada-lang.c & \cxreffunc{type_from_tag}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_find\_parallel\_type()}
\label{func_ada_find_parallel_type_ada-lang.c}

{\stt struct type* ada\_find\_parallel\_type ( struct type* the\_type, const char* suffix )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_find\_any\_type() & ada-lang.c & \cxreffunc{ada_find_any_type}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & grow\_vect() & ada-lang.c & \cxreffunc{grow_vect}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), strlen()} &\\
Called by:\ & ada\_array\_bound\_from\_type() & ada-lang.c & \cxreffunc{ada_array_bound_from_type}{ada-lang.c}\\
\ & ada\_get\_base\_type() & ada-lang.c & \cxreffunc{ada_get_base_type}{ada-lang.c}\\
\ & ada\_is\_aligner\_type() & ada-lang.c & \cxreffunc{ada_is_aligner_type}{ada-lang.c}\\
\ & dynamic\_template\_type() & ada-lang.c & \cxreffunc{dynamic_template_type}{ada-lang.c}\\
\ & print\_array\_type() & ada-typeprint.c & \cxreffunc{print_array_type}{ada-typeprint.c}\\
\ & print\_record\_type() & ada-typeprint.c & \cxreffunc{print_record_type}{ada-typeprint.c}\\
\ & print\_variant\_clauses() & ada-typeprint.c & \cxreffunc{print_variant_clauses}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & thin\_descriptor\_type() & ada-lang.c & \cxreffunc{thin_descriptor_type}{ada-lang.c}\\
\ & to\_fixed\_array\_type() & ada-lang.c & \cxreffunc{to_fixed_array_type}{ada-lang.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_find\_renaming\_symbol()}
\label{func_ada_find_renaming_symbol_ada-lang.c}

{\stt struct symbol* ada\_find\_renaming\_symbol ( const char* name, struct block* block )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_find\_any\_symbol() & ada-lang.c & \cxreffunc{ada_find_any_symbol}{ada-lang.c}\\
\ & block\_function() & block.c & \cxreffunc{block_function}{block.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), strlen(), strstr()} &\\
Called by:\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_fixed\_to\_float()}
\label{func_ada_fixed_to_float_ada-lang.c}

{\stt DOUBLEST ada\_fixed\_to\_float ( struct type* type, long x )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & scaling\_factor() & ada-lang.c & \cxreffunc{scaling_factor}{ada-lang.c}\\
Called by:\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & cast\_from\_fixed\_to\_double() & ada-lang.c & \cxreffunc{cast_from_fixed_to_double}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\ & print\_fixed\_point\_type() & ada-typeprint.c & \cxreffunc{print_fixed_point_type}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_float\_to\_fixed()}
\label{func_ada_float_to_fixed_ada-lang.c}

{\stt long ada\_float\_to\_fixed ( struct type* type, DOUBLEST x )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & scaling\_factor() & ada-lang.c & \cxreffunc{scaling_factor}{ada-lang.c}\\
Called by:\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_fold\_name()}
\label{func_ada_fold_name_ada-lang.c}

{\stt char* ada\_fold\_name ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & grow\_vect() & ada-lang.c & \cxreffunc{grow_vect}{ada-lang.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), strlen(), tolower()} &\\
Called by:\ & ada\_lookup\_symbol() & ada-lang.c & \cxreffunc{ada_lookup_symbol}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_get\_base\_type()}
\label{func_ada_get_base_type_ada-lang.c}

{\stt struct type* ada\_get\_base\_type ( struct type* raw\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_find\_any\_type() & ada-lang.c & \cxreffunc{ada_find_any_type}{ada-lang.c}\\
\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
Called by:\ & ada\_aligned\_type() & ada-lang.c & \cxreffunc{ada_aligned_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_get\_field\_index()}
\label{func_ada_get_field_index_ada-lang.c}

{\stt int ada\_get\_field\_index ( const struct type* type, const char* field\_name, int maybe\_missing )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & field\_name\_match() & ada-lang.c & \cxreffunc{field_name_match}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_in\_variant()}
\label{func_ada_in_variant_ada-lang.c}

{\stt int ada\_in\_variant ( long val, struct type* type, int field\_num )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_scan\_number() & ada-lang.c & \cxreffunc{ada_scan_number}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & ada\_which\_variant\_applies() & ada-lang.c & \cxreffunc{ada_which_variant_applies}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_index\_type()}
\label{func_ada_index_type_ada-lang.c}

{\stt struct type* ada\_index\_type ( struct type* type, int n )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_is\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_is_simple_array_type}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\ & desc\_index\_type() & ada-lang.c & \cxreffunc{desc_index_type}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_aligner\_type()}
\label{func_ada_is_aligner_type_ada-lang.c}

{\stt int ada\_is\_aligner\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & ada\_aligned\_type() & ada-lang.c & \cxreffunc{ada_aligned_type}{ada-lang.c}\\
\ & ada\_aligned\_value\_addr() & ada-lang.c & \cxreffunc{ada_aligned_value_addr}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_array\_descriptor\_type()}
\label{func_ada_is_array_descriptor_type_ada-lang.c}

{\stt int ada\_is\_array\_descriptor\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & desc\_arity() & ada-lang.c & \cxreffunc{desc_arity}{ada-lang.c}\\
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_data\_type() & ada-lang.c & \cxreffunc{desc_data_type}{ada-lang.c}\\
Called by:\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_is\_bogus\_array\_descriptor() & ada-lang.c & \cxreffunc{ada_is_bogus_array_descriptor}{ada-lang.c}\\
\ & ada\_is\_direct\_array\_type() & ada-lang.c & \cxreffunc{ada_is_direct_array_type}{ada-lang.c}\\
\ & ada\_is\_string\_type() & ada-lang.c & \cxreffunc{ada_is_string_type}{ada-lang.c}\\
\ & ada\_prefer\_type() & ada-lang.c & \cxreffunc{ada_prefer_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & ada\_type\_match() & ada-lang.c & \cxreffunc{ada_type_match}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_bogus\_array\_descriptor()}
\label{func_ada_is_bogus_array_descriptor_ada-lang.c}

{\stt int ada\_is\_bogus\_array\_descriptor ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & lookup\_struct\_elt\_type() & gdbtypes.c & \cxreffunc{lookup_struct_elt_type}{gdbtypes.c}\\
Called by:\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_character\_type()}
\label{func_ada_is_character_type_ada-lang.c}

{\stt int ada\_is\_character\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & ada\_is\_string\_type() & ada-lang.c & \cxreffunc{ada_is_string_type}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_fixed\_point\_type()}
\label{func_ada_is_fixed_point_type_ada-lang.c}

{\stt int ada\_is\_fixed\_point\_type ( struct type* the\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & fixed\_type\_info() & ada-lang.c & \cxreffunc{fixed_type_info}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_ignored\_field()}
\label{func_ada_is_ignored_field_ada-lang.c}

{\stt int ada\_is\_ignored\_field ( struct type* type, int field\_num )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & \cxreftabiiispan{ strncmp()} &\\
Called by:\ & print\_field\_values() & ada-valprint.c & \cxreffunc{print_field_values}{ada-valprint.c}\\
\ & print\_record\_field\_types() & ada-typeprint.c & \cxreffunc{print_record_field_types}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_modular\_type()}
\label{func_ada_is_modular_type_ada-lang.c}

{\stt int ada\_is\_modular\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & base\_type() & ada-lang.c & \cxreffunc{base_type}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_object\_renaming()}
\label{func_ada_is_object_renaming_ada-lang.c}

{\stt int ada\_is\_object\_renaming ( struct symbol* sym )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_renaming\_type() & ada-lang.c & \cxreffunc{ada_renaming_type}{ada-lang.c}\\
Called by:\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\ & remove\_out\_of\_scope\_renamings() & ada-lang.c & \cxreffunc{remove_out_of_scope_renamings}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & write\_object\_renaming() & ada-exp.c & \cxreffunc{write_object_renaming}{ada-exp.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_others\_clause()}
\label{func_ada_is_others_clause_ada-lang.c}

{\stt int ada\_is\_others\_clause ( struct type* type, int field\_num )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Called by:\ & ada\_which\_variant\_applies() & ada-lang.c & \cxreffunc{ada_which_variant_applies}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_packed\_array\_type()}
\label{func_ada_is_packed_array_type_ada-lang.c}

{\stt int ada\_is\_packed\_array\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ strstr()} &\\
Called by:\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_array\_bound\_from\_type() & ada-lang.c & \cxreffunc{ada_array_bound_from_type}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_prefer\_type() & ada-lang.c & \cxreffunc{ada_prefer_type}{ada-lang.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & print\_array\_type() & ada-typeprint.c & \cxreffunc{print_array_type}{ada-typeprint.c}\\
\ & to\_fixed\_array\_type() & ada-lang.c & \cxreffunc{to_fixed_array_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_parent\_field()}
\label{func_ada_is_parent_field_ada-lang.c}

{\stt int ada\_is\_parent\_field ( struct type* type, int field\_num )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & \cxreftabiiispan{ strncmp()} &\\
Called by:\ & ada\_parent\_type() & ada-lang.c & \cxreffunc{ada_parent_type}{ada-lang.c}\\
\ & print\_record\_field\_types() & ada-typeprint.c & \cxreffunc{print_record_field_types}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_range\_type\_name()}
\label{func_ada_is_range_type_name_ada-lang.c}

{\stt int ada\_is\_range\_type\_name ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & \cxreftabiiispan{ strstr()} &\\
Called by:\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_simple\_array\_type()}
\label{func_ada_is_simple_array_type_ada-lang.c}

{\stt int ada\_is\_simple\_array\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_array\_bound\_from\_type() & ada-lang.c & \cxreffunc{ada_array_bound_from_type}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_index\_type() & ada-lang.c & \cxreffunc{ada_index_type}{ada-lang.c}\\
\ & ada\_is\_string\_type() & ada-lang.c & \cxreffunc{ada_is_string_type}{ada-lang.c}\\
\ & print\_array\_type() & ada-typeprint.c & \cxreffunc{print_array_type}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_string\_type()}
\label{func_ada_is_string_type_ada-lang.c}

{\stt int ada\_is\_string\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_array\_element\_type() & ada-lang.c & \cxreffunc{ada_array_element_type}{ada-lang.c}\\
\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_is\_character\_type() & ada-lang.c & \cxreffunc{ada_is_character_type}{ada-lang.c}\\
\ & ada\_is\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_is_simple_array_type}{ada-lang.c}\\
Called by:\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_system\_address\_type()}
\label{func_ada_is_system_address_type_ada-lang.c}

{\stt int ada\_is\_system\_address\_type ( struct type* the\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_tag\_type()}
\label{func_ada_is_tag_type_ada-lang.c}

{\stt int ada\_is\_tag\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & ada\_tag\_name() & ada-lang.c & \cxreffunc{ada_tag_name}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_tagged\_type()}
\label{func_ada_is_tagged_type_ada-lang.c}

{\stt int ada\_is\_tagged\_type ( struct type* type, int refok )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_record\_type() & ada-typeprint.c & \cxreffunc{print_record_type}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_variant\_part()}
\label{func_ada_is_variant_part_ada-lang.c}

{\stt int ada\_is\_variant\_part ( struct type* type, int field\_num )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & is\_dynamic\_field() & ada-lang.c & \cxreffunc{is_dynamic_field}{ada-lang.c}\\
Called by:\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & find\_struct\_field() & ada-lang.c & \cxreffunc{find_struct_field}{ada-lang.c}\\
\ & print\_field\_values() & ada-valprint.c & \cxreffunc{print_field_values}{ada-valprint.c}\\
\ & print\_record\_field\_types() & ada-typeprint.c & \cxreffunc{print_record_field_types}{ada-typeprint.c}\\
\ & variant\_field\_index() & ada-lang.c & \cxreffunc{variant_field_index}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_vax\_floating\_type()}
\label{func_ada_is_vax_floating_type_ada-lang.c}

{\stt int ada\_is\_vax\_floating\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & \cxreftabiiispan{ strlen(), strncmp()} &\\
Called by:\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_is\_wrapper\_field()}
\label{func_ada_is_wrapper_field_ada-lang.c}

{\stt int ada\_is\_wrapper\_field ( struct type* type, int field\_num )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & \cxreftabiiispan{ strcmp(), strncmp()} &\\
Called by:\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\ & find\_struct\_field() & ada-lang.c & \cxreffunc{find_struct_field}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_field\_values() & ada-valprint.c & \cxreffunc{print_field_values}{ada-valprint.c}\\
\ & print\_record\_field\_types() & ada-typeprint.c & \cxreffunc{print_record_field_types}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_la\_decode()}
\label{func_ada_la_decode_ada-lang.c}

{\stt char* ada\_la\_decode ( const char* encoded, int options )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_decode() & ada-lang.c & \cxreffunc{ada_decode}{ada-lang.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_lookup\_simple\_minsym()}
\label{func_ada_lookup_simple_minsym_ada-lang.c}

{\stt struct minimal\_symbol* ada\_lookup\_simple\_minsym ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_match\_name() & ada-lang.c & \cxreffunc{ada_match_name}{ada-lang.c}\\
\ & objfile\_get\_first() & objfiles.c & \cxreffunc{objfile_get_first}{objfiles.c}\\
\ & objfile\_get\_next() & objfiles.c & \cxreffunc{objfile_get_next}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ strncmp(), strstr()} &\\
Called by:\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_lookup\_symbol()}
\label{func_ada_lookup_symbol_ada-lang.c}

{\stt struct symbol* ada\_lookup\_symbol ( const char* name, const struct block* block0, domain\_enum anamespace, int* is\_a\_field\_of\_this, struct symtab** symtab )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_encode() & ada-lang.c & \cxreffunc{ada_encode}{ada-lang.c}\\
\ & ada\_fold\_name() & ada-lang.c & \cxreffunc{ada_fold_name}{ada-lang.c}\\
\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & block\_highest\_pc() & block.c & \cxreffunc{block_highest_pc}{block.c}\\
\ & fixup\_symbol\_section() & symtab.c & \cxreffunc{fixup_symbol_section}{symtab.c}\\
\ & objfile\_get\_first() & objfiles.c & \cxreffunc{objfile_get_first}{objfiles.c}\\
\ & objfile\_get\_next() & objfiles.c & \cxreffunc{objfile_get_next}{objfiles.c}\\
\ & symtab\_get\_first() & objfiles.c & \cxreffunc{symtab_get_first}{objfiles.c}\\
\ & symtab\_get\_next() & objfiles.c & \cxreffunc{symtab_get_next}{objfiles.c}\\
Called by:\ & ada\_lookup\_symbol\_nonlocal() & ada-lang.c & \cxreffunc{ada_lookup_symbol_nonlocal}{ada-lang.c}\\
\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_lookup\_symbol\_list()}
\label{func_ada_lookup_symbol_list_ada-lang.c}

{\stt int ada\_lookup\_symbol\_list ( const char* name0, const struct block* block0, domain\_enum anamespace, struct ada\_symbol\_info** results )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_add\_block\_symbols() & ada-lang.c & \cxreffunc{ada_add_block_symbols}{ada-lang.c}\\
\ & ada\_lookup\_partial\_symbol() & ada-lang.c & \cxreffunc{ada_lookup_partial_symbol}{ada-lang.c}\\
\ & ada\_match\_name() & ada-lang.c & \cxreffunc{ada_match_name}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & add\_defn\_to\_vec() & ada-lang.c & \cxreffunc{add_defn_to_vec}{ada-lang.c}\\
\ & add\_symbols\_from\_enclosing\_procs() & ada-lang.c & \cxreffunc{add_symbols_from_enclosing_procs}{ada-lang.c}\\
\ & cache\_symbol() & ada-lang.c & \cxreffunc{cache_symbol}{ada-lang.c}\\
\ & defns\_collected() & ada-lang.c & \cxreffunc{defns_collected}{ada-lang.c}\\
\ & find\_pc\_symtab() & symtab.c & \cxreffunc{find_pc_symtab}{symtab.c}\\
\ & is\_nonfunction() & ada-lang.c & \cxreffunc{is_nonfunction}{ada-lang.c}\\
\ & lookup\_cached\_symbol() & ada-lang.c & \cxreffunc{lookup_cached_symbol}{ada-lang.c}\\
\ & num\_defns\_collected() & ada-lang.c & \cxreffunc{num_defns_collected}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & objfile\_get\_first() & objfiles.c & \cxreffunc{objfile_get_first}{objfiles.c}\\
\ & objfile\_get\_next() & objfiles.c & \cxreffunc{objfile_get_next}{objfiles.c}\\
\ & psymtab\_get\_first() & objfiles.c & \cxreffunc{psymtab_get_first}{objfiles.c}\\
\ & psymtab\_get\_next() & objfiles.c & \cxreffunc{psymtab_get_next}{objfiles.c}\\
\ & psymtab\_to\_symtab() & symfile.c & \cxreffunc{psymtab_to_symtab}{symfile.c}\\
\ & quit() & utils.c & \cxreffunc{quit}{utils.c}\\
\ & remove\_extra\_symbols() & ada-lang.c & \cxreffunc{remove_extra_symbols}{ada-lang.c}\\
\ & remove\_out\_of\_scope\_renamings() & ada-lang.c & \cxreffunc{remove_out_of_scope_renamings}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & symtab\_get\_first() & objfiles.c & \cxreffunc{symtab_get_first}{objfiles.c}\\
\ & symtab\_get\_next() & objfiles.c & \cxreffunc{symtab_get_next}{objfiles.c}\\
\ & \cxreftabiiispan{ \_obstack\_begin(), strncmp(), strstr()} &\\
Called by:\ & ada\_lookup\_symbol() & ada-lang.c & \cxreffunc{ada_lookup_symbol}{ada-lang.c}\\
\ & block\_lookup() & ada-exp.c & \cxreffunc{block_lookup}{ada-exp.c}\\
\ & get\_var\_value() & ada-lang.c & \cxreffunc{get_var_value}{ada-lang.c}\\
\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ obstack\_free()} &\\
Refs Var:\ & quit\_flag & utils.c & \cxrefvar{quit_flag}{utils.c}\\
\ & symbol\_list\_obstack & ada-lang.c & \cxrefvar{symbol_list_obstack}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_main\_name()}
\label{func_ada_main_name_ada-lang.c}

{\stt char* ada\_main\_name ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & extract\_string() & ada-lang.c & \cxreffunc{extract_string}{ada-lang.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & find\_main\_name() & symtab.c & \cxreffunc{find_main_name}{symtab.c}\\
Refs Var:\ & ADA\_MAIN\_PROGRAM\_SYMBOL\_NAME & ada-lang.c & \cxrefvar{ADA_MAIN_PROGRAM_SYMBOL_NAME}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_match\_name()}
\label{func_ada_match_name_ada-lang.c}

{\stt int ada\_match\_name ( const char* sym\_name, const char* name, int wild )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & is\_name\_suffix() & ada-lang.c & \cxreffunc{is_name_suffix}{ada-lang.c}\\
\ & wild\_match() & ada-lang.c & \cxreffunc{wild_match}{ada-lang.c}\\
\ & \cxreftabiiispan{ strlen(), strncmp()} &\\
Called by:\ & ada\_lookup\_simple\_minsym() & ada-lang.c & \cxreffunc{ada_lookup_simple_minsym}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_modulus()}
\label{func_ada_modulus_ada-lang.c}

{\stt unsigned long ada\_modulus ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_name\_prefix\_len()}
\label{func_ada_name_prefix_len_ada-lang.c}

{\stt int ada\_name\_prefix\_len ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & \cxreftabiiispan{ strlen(), strstr()} &\\
Called by:\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & ada\_typedef\_print() & ada-typeprint.c & \cxreffunc{ada_typedef_print}{ada-typeprint.c}\\
\ & print\_field\_values() & ada-valprint.c & \cxreffunc{print_field_values}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_range() & ada-typeprint.c & \cxreffunc{print_range}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_parent\_type()}
\label{func_ada_parent_type_ada-lang.c}

{\stt struct type* ada\_parent\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_is\_parent\_field() & ada-lang.c & \cxreffunc{ada_is_parent_field}{ada-lang.c}\\
Called by:\ & print\_record\_type() & ada-typeprint.c & \cxreffunc{print_record_type}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_prefer\_type()}
\label{func_ada_prefer_type_ada-lang.c}

{\stt int ada\_prefer\_type ( struct type* type0, struct type* type1 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\ & ada\_renaming\_type() & ada-lang.c & \cxreffunc{ada_renaming_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_renaming\_type()}
\label{func_ada_renaming_type_ada-lang.c}

{\stt const char* ada\_renaming\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & type\_name\_no\_tag() & gdbtypes.c & \cxreffunc{type_name_no_tag}{gdbtypes.c}\\
\ & \cxreftabiiispan{ strchr(), strstr()} &\\
Called by:\ & ada\_is\_object\_renaming() & ada-lang.c & \cxreffunc{ada_is_object_renaming}{ada-lang.c}\\
\ & ada\_prefer\_type() & ada-lang.c & \cxreffunc{ada_prefer_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_scan\_number()}
\label{func_ada_scan_number_ada-lang.c}

{\stt int ada\_scan\_number ( const char str[], int k, long* R, int* new\_k )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & \cxreftabiiispan{ isdigit()} &\\
Called by:\ & ada\_in\_variant() & ada-lang.c & \cxreffunc{ada_in_variant}{ada-lang.c}\\
\ & print\_choices() & ada-typeprint.c & \cxreffunc{print_choices}{ada-typeprint.c}\\
\ & print\_range\_bound() & ada-typeprint.c & \cxreffunc{print_range_bound}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_simple\_renamed\_entity()}
\label{func_ada_simple_renamed_entity_ada-lang.c}

{\stt char* ada\_simple\_renamed\_entity ( struct symbol* sym )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), strlen()} &\\
Called by:\ & name\_lookup() & ada-exp.c & \cxreffunc{name_lookup}{ada-exp.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_suppress\_symbol\_printing()}
\label{func_ada_suppress_symbol_printing_ada-lang.c}

{\stt int ada\_suppress\_symbol\_printing ( struct symbol* sym )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & is\_suppressed\_name() & ada-lang.c & \cxreffunc{is_suppressed_name}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_tag\_name()}
\label{func_ada_tag_name_ada-lang.c}

{\stt const char* ada\_tag\_name ( struct value* tag )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_is\_tag\_type() & ada-lang.c & \cxreffunc{ada_is_tag_type}{ada-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ catch\_errors()} &\\
Called by:\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & type\_from\_tag() & ada-lang.c & \cxreffunc{type_from_tag}{ada-lang.c}\\
Refs Func:\ & ada\_tag\_name\_1() & ada-lang.c & \cxreffunc{ada_tag_name_1}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_tag\_type()}
\label{func_ada_tag_type_ada-lang.c}

{\stt struct type* ada\_tag\_type ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_template\_to\_fixed\_record\_type\_1()}
\label{func_ada_template_to_fixed_record_type_1_ada-lang.c}

{\stt struct type* ada\_template\_to\_fixed\_record\_type\_1 ( struct type* type, const gdb\_byte* valaddr, CORE\_ADDR address, struct value* dval0, int keep\_dynamic\_fields )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_get\_base\_type() & ada-lang.c & \cxreffunc{ada_get_base_type}{ada-lang.c}\\
\ & ada\_is\_variant\_part() & ada-lang.c & \cxreffunc{ada_is_variant_part}{ada-lang.c}\\
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & align\_value() & ada-lang.c & \cxreffunc{align_value}{ada-lang.c}\\
\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & cond\_offset\_host() & ada-lang.c & \cxreffunc{cond_offset_host}{ada-lang.c}\\
\ & cond\_offset\_target() & ada-lang.c & \cxreffunc{cond_offset_target}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & field\_alignment() & ada-lang.c & \cxreffunc{field_alignment}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & is\_dynamic\_field() & ada-lang.c & \cxreffunc{is_dynamic_field}{ada-lang.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & template\_to\_fixed\_record\_type() & ada-lang.c & \cxreffunc{template_to_fixed_record_type}{ada-lang.c}\\
Refs Var:\ & varsize\_limit & ada-lang.c & \cxrefvar{varsize_limit}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_to\_fixed\_type()}
\label{func_ada_to_fixed_type_ada-lang.c}

{\stt struct type* ada\_to\_fixed\_type ( struct type* type, const gdb\_byte* valaddr, CORE\_ADDR address, struct value* dval )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_is\_tagged\_type() & ada-lang.c & \cxreffunc{ada_is_tagged_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & to\_fixed\_array\_type() & ada-lang.c & \cxreffunc{to_fixed_array_type}{ada-lang.c}\\
\ & to\_fixed\_record\_type() & ada-lang.c & \cxreffunc{to_fixed_record_type}{ada-lang.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\ & type\_from\_tag() & ada-lang.c & \cxreffunc{type_from_tag}{ada-lang.c}\\
\ & value\_tag\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_tag_from_contents_and_address}{ada-lang.c}\\
Called by:\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & ada\_to\_fixed\_value\_create() & ada-lang.c & \cxreffunc{ada_to_fixed_value_create}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & printable\_val\_type() & ada-valprint.c & \cxreffunc{printable_val_type}{ada-valprint.c}\\
\ & to\_fixed\_array\_type() & ada-lang.c & \cxreffunc{to_fixed_array_type}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_to\_static\_fixed\_value()}
\label{func_ada_to_static_fixed_value_ada-lang.c}

{\stt struct value* ada\_to\_static\_fixed\_value ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_type\_name()}
\label{func_ada_type_name_ada-lang.c}

{\stt const char* ada\_type\_name ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & ada\_is\_character\_type() & ada-lang.c & \cxreffunc{ada_is_character_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\ & ada\_is\_tag\_type() & ada-lang.c & \cxreffunc{ada_is_tag_type}{ada-lang.c}\\
\ & ada\_is\_vax\_floating\_type() & ada-lang.c & \cxreffunc{ada_is_vax_floating_type}{ada-lang.c}\\
\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & ada\_variant\_discrim\_name() & ada-lang.c & \cxreffunc{ada_variant_discrim_name}{ada-lang.c}\\
\ & ada\_vax\_float\_type\_suffix() & ada-lang.c & \cxreffunc{ada_vax_float_type_suffix}{ada-lang.c}\\
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & decoded\_type\_name() & ada-typeprint.c & \cxreffunc{decoded_type_name}{ada-typeprint.c}\\
\ & dynamic\_template\_type() & ada-lang.c & \cxreffunc{dynamic_template_type}{ada-lang.c}\\
\ & equiv\_types() & ada-lang.c & \cxreffunc{equiv_types}{ada-lang.c}\\
\ & fixed\_type\_info() & ada-lang.c & \cxreffunc{fixed_type_info}{ada-lang.c}\\
\ & is\_nondebugging\_type() & ada-lang.c & \cxreffunc{is_nondebugging_type}{ada-lang.c}\\
\ & is\_thin\_pntr() & ada-lang.c & \cxreffunc{is_thin_pntr}{ada-lang.c}\\
\ & packed\_array\_type() & ada-lang.c & \cxreffunc{packed_array_type}{ada-lang.c}\\
\ & print\_record\_type() & ada-typeprint.c & \cxreffunc{print_record_type}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\ & template\_to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{template_to_static_fixed_type}{ada-lang.c}\\
\ & thin\_descriptor\_type() & ada-lang.c & \cxreffunc{thin_descriptor_type}{ada-lang.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_type\_of\_array()}
\label{func_ada_type_of_array_ada-lang.c}

{\stt struct type* ada\_type\_of\_array ( struct value* arr, int bounds )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_array\_element\_type() & ada-lang.c & \cxreffunc{ada_array_element_type}{ada-lang.c}\\
\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & desc\_data\_type() & ada-lang.c & \cxreffunc{desc_data_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_one\_bound() & ada-lang.c & \cxreffunc{desc_one_bound}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_type}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_update\_initial\_language()}
\label{func_ada_update_initial_language_ada-lang.c}

{\stt enum language ada\_update\_initial\_language ( enum language lang, struct partial\_symtab* main\_pst )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_value\_ind()}
\label{func_ada_value_ind_ada-lang.c}

{\stt struct value* ada\_value\_ind ( struct value* val0 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_to\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_fixed_value}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & coerce\_for\_assign() & ada-lang.c & \cxreffunc{coerce_for_assign}{ada-lang.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_value\_primitive\_packed\_val()}
\label{func_ada_value_primitive_packed_val_ada-lang.c}

{\stt struct value* ada\_value\_primitive\_packed\_val ( struct value* obj, const gdb\_byte* valaddr, long offset, int bit\_offset, size\_t bit\_size, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\ & has\_negatives() & ada-lang.c & \cxreffunc{has_negatives}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & read\_memory() & corefile.c & \cxreffunc{read_memory}{corefile.c}\\
\ & set\_value\_bitpos() & value.c & \cxreffunc{set_value_bitpos}{value.c}\\
\ & set\_value\_bitsize() & value.c & \cxreffunc{set_value_bitsize}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_at() & valops.c & \cxreffunc{value_at}{valops.c}\\
\ & value\_bitpos() & value.c & \cxreffunc{value_bitpos}{value.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & ada\_value\_primitive\_field() & ada-lang.c & \cxreffunc{ada_value_primitive_field}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\ & print\_field\_values() & ada-valprint.c & \cxreffunc{print_field_values}{ada-valprint.c}\\
\ & val\_print\_packed\_array\_elements() & ada-valprint.c & \cxreffunc{val_print_packed_array_elements}{ada-valprint.c}\\
\ & value\_subscript\_packed() & ada-lang.c & \cxreffunc{value_subscript_packed}{ada-lang.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_value\_ptr\_subscript()}
\label{func_ada_value_ptr_subscript_ada-lang.c}

{\stt struct value* ada\_value\_ptr\_subscript ( struct value* arr, struct type* type, int arity, struct value** ind )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_discrete\_bounds() & gdbtypes.c & \cxreffunc{get_discrete_bounds}{gdbtypes.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_add() & valarith.c & \cxreffunc{value_add}{valarith.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_pos\_atr() & ada-lang.c & \cxreffunc{value_pos_atr}{ada-lang.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_value\_struct\_elt()}
\label{func_ada_value_struct_elt_ada-lang.c}

{\stt struct value* ada\_value\_struct\_elt ( struct value* arg, const char* name, const char* err )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_coerce\_ref() & ada-lang.c & \cxreffunc{ada_coerce_ref}{ada-lang.c}\\
\ & ada\_get\_base\_type() & ada-lang.c & \cxreffunc{ada_get_base_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\ & ada\_value\_ind() & ada-lang.c & \cxreffunc{ada_value_ind}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_struct\_field() & ada-lang.c & \cxreffunc{find_struct_field}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\ & unpack\_pointer() & value.c & \cxreffunc{unpack_pointer}{value.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_tag\_name\_1() & ada-lang.c & \cxreffunc{ada_tag_name_1}{ada-lang.c}\\
\ & ada\_value\_tag() & ada-lang.c & \cxreffunc{ada_value_tag}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_value\_subscript()}
\label{func_ada_value_subscript_ada-lang.c}

{\stt struct value* ada\_value\_subscript ( struct value* arr, int arity, struct value** ind )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_pos\_atr() & ada-lang.c & \cxreffunc{value_pos_atr}{ada-lang.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_subscript\_packed() & ada-lang.c & \cxreffunc{value_subscript_packed}{ada-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_value\_tag()}
\label{func_ada_value_tag_ada-lang.c}

{\stt struct value* ada\_value\_tag ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_variant\_discrim\_name()}
\label{func_ada_variant_discrim_name_ada-lang.c}

{\stt const char* ada\_variant\_discrim\_name ( struct type* type0 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & grow\_vect() & ada-lang.c & \cxreffunc{grow_vect}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), strlen(), strncmp()} &\\
Called by:\ & ada\_variant\_discrim\_type() & ada-lang.c & \cxreffunc{ada_variant_discrim_type}{ada-lang.c}\\
\ & ada\_which\_variant\_applies() & ada-lang.c & \cxreffunc{ada_which_variant_applies}{ada-lang.c}\\
\ & print\_variant\_part() & ada-typeprint.c & \cxreffunc{print_variant_part}{ada-typeprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_variant\_discrim\_type()}
\label{func_ada_variant_discrim_type_ada-lang.c}

{\stt struct type* ada\_variant\_discrim\_type ( struct type* var\_type, struct type* outer\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & ada\_variant\_discrim\_name() & ada-lang.c & \cxreffunc{ada_variant_discrim_name}{ada-lang.c}\\
Called by:\ & print\_variant\_clauses() & ada-typeprint.c & \cxreffunc{print_variant_clauses}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_vax\_float\_print\_function()}
\label{func_ada_vax_float_print_function_ada-lang.c}

{\stt struct value* ada\_vax\_float\_print\_function ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_vax\_float\_type\_suffix() & ada-lang.c & \cxreffunc{ada_vax_float_type_suffix}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_var\_value() & ada-lang.c & \cxreffunc{get_var_value}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ada\_vax\_float\_type\_suffix()}
\label{func_ada_vax_float_type_suffix_ada-lang.c}

{\stt int ada\_vax\_float\_type\_suffix ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & ada\_vax\_float\_print\_function() & ada-lang.c & \cxreffunc{ada_vax_float_print_function}{ada-lang.c}\\
\ & print\_vax\_floating\_point\_type() & ada-typeprint.c & \cxreffunc{print_vax_floating_point_type}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function ada\_which\_variant\_applies()}
\label{func_ada_which_variant_applies_ada-lang.c}

{\stt int ada\_which\_variant\_applies ( struct type* var\_type, struct type* outer\_type, const gdb\_byte* outer\_valaddr )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_in\_variant() & ada-lang.c & \cxreffunc{ada_in_variant}{ada-lang.c}\\
\ & ada\_is\_others\_clause() & ada-lang.c & \cxreffunc{ada_is_others_clause}{ada-lang.c}\\
\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_variant\_discrim\_name() & ada-lang.c & \cxreffunc{ada_variant_discrim_name}{ada-lang.c}\\
\ & unpack\_long() & value.c & \cxreffunc{unpack_long}{value.c}\\
Called by:\ & print\_variant\_part() & ada-valprint.c & \cxreffunc{print_variant_part}{ada-valprint.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function get\_int\_var\_value()}
\label{func_get_int_var_value_ada-lang.c}

{\stt long get\_int\_var\_value ( char* name, int* flag )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & get\_var\_value() & ada-lang.c & \cxreffunc{get_var_value}{ada-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
Called by:\ & print\_dynamic\_range\_bound() & ada-typeprint.c & \cxreffunc{print_dynamic_range_bound}{ada-typeprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function get\_selections()}
\label{func_get_selections_ada-lang.c}

{\stt int get\_selections ( int* choices, int n\_choices, int max\_results, int is\_all\_choice, const char* annotation\_suffix )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & command\_line\_input() & top.c & \cxreffunc{command_line_input}{top.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\cxreftabbreak{cxreftabiii}
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & \cxreftabiiispan{ error\_no\_arg(), getenv(), isspace(), strtol()} &\\
Called by:\ & user\_select\_syms() & ada-lang.c & \cxreffunc{user_select_syms}{ada-lang.c}\\
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\end{cxreftabiii}


\subsubsection{Global Function grow\_vect()}
\label{func_grow_vect_ada-lang.c}

{\stt void* grow\_vect ( void* vect, size\_t* size, size\_t min\_size, int element\_size )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
Called by:\ & ada\_decode() & ada-lang.c & \cxreffunc{ada_decode}{ada-lang.c}\\
\ & ada\_encode() & ada-lang.c & \cxreffunc{ada_encode}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_enum\_name() & ada-lang.c & \cxreffunc{ada_enum_name}{ada-lang.c}\\
\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & ada\_fold\_name() & ada-lang.c & \cxreffunc{ada_fold_name}{ada-lang.c}\\
\ & ada\_variant\_discrim\_name() & ada-lang.c & \cxreffunc{ada_variant_discrim_name}{ada-lang.c}\\
\ & print\_dynamic\_range\_bound() & ada-typeprint.c & \cxreffunc{print_dynamic_range_bound}{ada-typeprint.c}\\
\ & scan\_discrim\_bound() & ada-lang.c & \cxreffunc{scan_discrim_bound}{ada-lang.c}\\
\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function lookup\_symbol\_in\_language()}
\label{func_lookup_symbol_in_language_ada-lang.c}

{\stt struct symbol* lookup\_symbol\_in\_language ( const char* name, const struct block* block, domain\_enum domain, enum language lang, int* is\_a\_field\_of\_this, struct symtab** symtab )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & lookup\_symbol() & symtab.c & \cxreffunc{lookup_symbol}{symtab.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_language() & language.c & \cxreffunc{set_language}{language.c}\\
Called by:\ & standard\_lookup() & ada-lang.c & \cxreffunc{standard_lookup}{ada-lang.c}\\
Refs Func:\ & restore\_language() & ada-lang.c & \cxreffunc{restore_language}{ada-lang.c}\\
Refs Var:\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function user\_select\_syms()}
\label{func_user_select_syms_ada-lang.c}

{\stt int user\_select\_syms ( struct ada\_symbol\_info* syms, int nsyms, int max\_results )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & ada\_print\_type() & ada-typeprint.c & \cxreffunc{ada_print_type}{ada-typeprint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_function\_start\_sal() & symtab.c & \cxreffunc{find_function_start_sal}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_selections() & ada-lang.c & \cxreffunc{get_selections}{ada-lang.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & sort\_choices() & ada-lang.c & \cxreffunc{sort_choices}{ada-lang.c}\\
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
\ & symtab\_for\_sym() & ada-lang.c & \cxreffunc{symtab_for_sym}{ada-lang.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & ada\_resolve\_function() & ada-lang.c & \cxreffunc{ada_resolve_function}{ada-lang.c}\\
\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
Refs Var:\ & demangle & utils.c & \cxrefvar{demangle}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_from\_contents\_and\_address()}
\label{func_value_from_contents_and_address_ada-lang.c}

{\stt struct value* value\_from\_contents\_and\_address ( struct type* type, const gdb\_byte* valaddr, CORE\_ADDR address )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.h & \ & \cxreffile{ada-lang.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & set\_value\_lazy() & value.c & \cxreffunc{set_value_lazy}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & ada\_to\_fixed\_value\_create() & ada-lang.c & \cxreffunc{ada_to_fixed_value_create}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_tag\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_tag_from_contents_and_address}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_add\_block\_symbols()}
\label{func_ada_add_block_symbols_ada-lang.c}

{\stt static void ada\_add\_block\_symbols ( struct obstack* obstackp, struct block* block, const char* name, domain\_enum domain, struct objfile* objfile, struct symtab* symtab, int wild )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & add\_defn\_to\_vec() & ada-lang.c & \cxreffunc{add_defn_to_vec}{ada-lang.c}\\
\ & dict\_iterator\_first() & dictionary.c & \cxreffunc{dict_iterator_first}{dictionary.c}\\
\ & dict\_iterator\_next() & dictionary.c & \cxreffunc{dict_iterator_next}{dictionary.c}\\
\cxreftabbreak{cxreftabiii}
\ & fixup\_symbol\_section() & symtab.c & \cxreffunc{fixup_symbol_section}{symtab.c}\\
\ & is\_name\_suffix() & ada-lang.c & \cxreffunc{is_name_suffix}{ada-lang.c}\\
\ & wild\_match() & ada-lang.c & \cxreffunc{wild_match}{ada-lang.c}\\
\ & \cxreftabiiispan{ strlen(), strncmp()} &\\
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_args\_match()}
\label{func_ada_args_match_ada-lang.c}

{\stt static int ada\_args\_match ( struct symbol* func, struct value** actuals, int n\_actuals )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_type\_match() & ada-lang.c & \cxreffunc{ada_type_match}{ada-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_resolve\_function() & ada-lang.c & \cxreffunc{ada_resolve_function}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_coerce\_ref()}
\label{func_ada_coerce_ref_ada-lang.c}

{\stt static struct value* ada\_coerce\_ref ( struct value* val0 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_to\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_fixed_value}{ada-lang.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_coerce\_to\_simple\_array()}
\label{func_ada_coerce_to_simple_array_ada-lang.c}

{\stt static struct value* ada\_coerce\_to\_simple\_array ( struct value* arr )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_value\_equal() & ada-lang.c & \cxreffunc{ada_value_equal}{ada-lang.c}\\
\ & ada\_value\_subscript() & ada-lang.c & \cxreffunc{ada_value_subscript}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_create\_fundamental\_type()}
\label{func_ada_create_fundamental_type_ada-lang.c}

{\stt static struct type* ada\_create\_fundamental\_type ( struct objfile* objfile, int adatypeid )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & gdbarch\_double\_bit() & gdbarch.c & \cxreffunc{gdbarch_double_bit}{gdbarch.c}\\
\ & gdbarch\_float\_bit() & gdbarch.c & \cxreffunc{gdbarch_float_bit}{gdbarch.c}\\
\ & gdbarch\_int\_bit() & gdbarch.c & \cxreffunc{gdbarch_int_bit}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_bit}{gdbarch.c}\\
\ & gdbarch\_long\_double\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_double_bit}{gdbarch.c}\\
\ & gdbarch\_long\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_long_bit}{gdbarch.c}\\
\ & gdbarch\_short\_bit() & gdbarch.c & \cxreffunc{gdbarch_short_bit}{gdbarch.c}\\
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function ada\_decoded\_op\_name()}
\label{func_ada_decoded_op_name_ada-lang.c}

{\stt static const char* ada\_decoded\_op\_name ( enum exp\_opcode op )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
Called by:\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
Refs Var:\ & ada\_opname\_table & ada-lang.c & \cxrefvar{ada_opname_table}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function ada\_dump\_subexp\_body()}
\label{func_ada_dump_subexp_body_ada-lang.c}

{\stt static int ada\_dump\_subexp\_body ( struct expression* exp, struct ui\_file* stream, int elt )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_forward\_operator\_length() & ada-lang.c & \cxreffunc{ada_forward_operator_length}{ada-lang.c}\\
\ & dump\_subexp() & expprint.c & \cxreffunc{dump_subexp}{expprint.c}\\
\ & dump\_subexp\_body\_standard() & expprint.c & \cxreffunc{dump_subexp_body_standard}{expprint.c}\\
\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_print\_host\_address() & utils.c & \cxreffunc{gdb_print_host_address}{utils.c}\\
\ & type\_print() & typeprint.c & \cxreffunc{type_print}{typeprint.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_forward\_operator\_length()}
\label{func_ada_forward_operator_length_ada-lang.c}

{\stt static void ada\_forward\_operator\_length ( struct expression* exp, int pc, int* oplenp, int* argsp )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_dump\_subexp\_body() & ada-lang.c & \cxreffunc{ada_dump_subexp_body}{ada-lang.c}\\
\ & ada\_print\_subexp() & ada-lang.c & \cxreffunc{ada_print_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_get\_gdb\_completer\_word\_break\_characters()}
\label{func_ada_get_gdb_completer_word_break_characters_ada-lang.c}

{\stt static const char* ada\_get\_gdb\_completer\_word\_break\_characters ( void )}

\smallskip
\begin{cxreftabiii}
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Refs Var:\ & ada\_completer\_word\_break\_characters & ada-lang.c & \cxrefvar{ada_completer_word_break_characters}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_is\_direct\_array\_type()}
\label{func_ada_is_direct_array_type_ada-lang.c}

{\stt static int ada\_is\_direct\_array\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
Called by:\ & ada\_value\_equal() & ada-lang.c & \cxreffunc{ada_value_equal}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function ada\_language\_arch\_info()}
\label{func_ada_language_arch_info_ada-lang.c}

{\stt static void ada\_language\_arch\_info ( struct gdbarch* current\_gdbarch, struct language\_arch\_info* lai )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & gdbarch\_double\_bit() & gdbarch.c & \cxreffunc{gdbarch_double_bit}{gdbarch.c}\\
\ & gdbarch\_float\_bit() & gdbarch.c & \cxreffunc{gdbarch_float_bit}{gdbarch.c}\\
\ & gdbarch\_int\_bit() & gdbarch.c & \cxreffunc{gdbarch_int_bit}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_bit}{gdbarch.c}\\
\ & gdbarch\_long\_double\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_double_bit}{gdbarch.c}\\
\ & gdbarch\_long\_long\_bit() & gdbarch.c & \cxreffunc{gdbarch_long_long_bit}{gdbarch.c}\\
\ & gdbarch\_obstack\_zalloc() & gdbarch.c & \cxreffunc{gdbarch_obstack_zalloc}{gdbarch.c}\\
\ & gdbarch\_short\_bit() & gdbarch.c & \cxreffunc{gdbarch_short_bit}{gdbarch.c}\\
\ & get\_builtin\_type() & gdbtypes.c & \cxreffunc{get_builtin_type}{gdbtypes.c}\\
\ & init\_type() & gdbtypes.c & \cxreffunc{init_type}{gdbtypes.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_lookup\_partial\_symbol()}
\label{func_ada_lookup_partial_symbol_ada-lang.c}

{\stt static struct partial\_symbol* ada\_lookup\_partial\_symbol ( struct partial\_symtab* pst, const char* name, int global, domain\_enum anamespace, int wild )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & is\_name\_suffix() & ada-lang.c & \cxreffunc{is_name_suffix}{ada-lang.c}\\
\ & wild\_match() & ada-lang.c & \cxreffunc{wild_match}{ada-lang.c}\\
\ & \cxreftabiiispan{ strcmp(), strlen(), strncmp()} &\\
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function ada\_lookup\_struct\_elt\_type()}
\label{func_ada_lookup_struct_elt_type_ada-lang.c}

{\stt static struct type* ada\_lookup\_struct\_elt\_type ( struct type* type, const char* name, int refok, int noerr, int* dispp )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_is\_variant\_part() & ada-lang.c & \cxreffunc{ada_is_variant_part}{ada-lang.c}\\
\ & ada\_is\_wrapper\_field() & ada-lang.c & \cxreffunc{ada_is_wrapper_field}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & field\_name\_match() & ada-lang.c & \cxreffunc{field_name_match}{ada-lang.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & gdb\_flush() & ui-file.c & \cxreffunc{gdb_flush}{ui-file.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & type\_print() & typeprint.c & \cxreffunc{type_print}{typeprint.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_is\_tagged\_type() & ada-lang.c & \cxreffunc{ada_is_tagged_type}{ada-lang.c}\\
\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & ada\_tag\_type() & ada-lang.c & \cxreffunc{ada_tag_type}{ada-lang.c}\\
\ & ada\_variant\_discrim\_type() & ada-lang.c & \cxreffunc{ada_variant_discrim_type}{ada-lang.c}\\
\ & ada\_which\_variant\_applies() & ada-lang.c & \cxreffunc{ada_which_variant_applies}{ada-lang.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_lookup\_symbol\_nonlocal()}
\label{func_ada_lookup_symbol_nonlocal_ada-lang.c}

{\stt static struct symbol* ada\_lookup\_symbol\_nonlocal ( const char* name, const char* linkage\_name, const struct block* block, const domain\_enum domain, struct symtab** symtab )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_lookup\_symbol() & ada-lang.c & \cxreffunc{ada_lookup_symbol}{ada-lang.c}\\
\ & block\_static\_block() & block.c & \cxreffunc{block_static_block}{block.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_op\_name()}
\label{func_ada_op_name_ada-lang.c}

{\stt static const char* ada\_op\_name ( enum exp\_opcode opcode )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & op\_name\_standard() & expprint.c & \cxreffunc{op_name_standard}{expprint.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_operator\_length()}
\label{func_ada_operator_length_ada-lang.c}

{\stt static void ada\_operator\_length ( struct expression* exp, int pc, int* oplenp, int* argsp )}

\smallskip
\begin{cxreftabiii}
Calls:\ & operator\_length\_standard() & parse.c & \cxreffunc{operator_length_standard}{parse.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_print\_subexp()}
\label{func_ada_print_subexp_ada-lang.c}

{\stt static void ada\_print\_subexp ( struct expression* exp, int* pos, struct ui\_file* stream, enum precedence prec )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_attribute\_name() & ada-lang.c & \cxreffunc{ada_attribute_name}{ada-lang.c}\\
\ & ada\_forward\_operator\_length() & ada-lang.c & \cxreffunc{ada_forward_operator_length}{ada-lang.c}\\
\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
\ & fputs\_filtered() & utils.c & \cxreffunc{fputs_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_subexp() & expprint.c & \cxreffunc{print_subexp}{expprint.c}\\
\ & print\_subexp\_standard() & expprint.c & \cxreffunc{print_subexp_standard}{expprint.c}\\
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
\ & type\_print() & typeprint.c & \cxreffunc{type_print}{typeprint.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Refs Var:\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_resolve\_function()}
\label{func_ada_resolve_function_ada-lang.c}

{\stt static int ada\_resolve\_function ( struct ada\_symbol\_info syms[], int nsyms, struct value** args, int nargs, const char* name, struct type* context\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_args\_match() & ada-lang.c & \cxreffunc{ada_args_match}{ada-lang.c}\\
\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & return\_match() & ada-lang.c & \cxreffunc{return_match}{ada-lang.c}\\
\ & user\_select\_syms() & ada-lang.c & \cxreffunc{user_select_syms}{ada-lang.c}\\
Called by:\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
Refs Var:\ & builtin\_type\_void & gdbtypes.c & \cxrefvar{builtin_type_void}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_search\_struct\_field()}
\label{func_ada_search_struct_field_ada-lang.c}

{\stt static struct value* ada\_search\_struct\_field ( const char* name, struct value* arg, int offset, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_is\_variant\_part() & ada-lang.c & \cxreffunc{ada_is_variant_part}{ada-lang.c}\\
\ & ada\_is\_wrapper\_field() & ada-lang.c & \cxreffunc{ada_is_wrapper_field}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\ & ada\_value\_primitive\_field() & ada-lang.c & \cxreffunc{ada_value_primitive_field}{ada-lang.c}\\
\ & field\_name\_match() & ada-lang.c & \cxreffunc{field_name_match}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
Called by:\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & scan\_discrim\_bound() & ada-lang.c & \cxreffunc{scan_discrim_bound}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function ada\_tag\_name\_1()}
\label{func_ada_tag_name_1_ada-lang.c}

{\stt static int ada\_tag\_name\_1 ( void* args0 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & read\_memory\_string() & corefile.c & \cxreffunc{read_memory_string}{corefile.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & \cxreftabiiispan{ isalpha(), tolower()} &\\
Used in:\ & ada\_tag\_name() & ada-lang.c & \cxreffunc{ada_tag_name}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function ada\_to\_fixed\_value()}
\label{func_ada_to_fixed_value_ada-lang.c}

{\stt static struct value* ada\_to\_fixed\_value ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_to\_fixed\_value\_create() & ada-lang.c & \cxreffunc{ada_to_fixed_value_create}{ada-lang.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_coerce\_ref() & ada-lang.c & \cxreffunc{ada_coerce_ref}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_value\_ind() & ada-lang.c & \cxreffunc{ada_value_ind}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_to\_fixed\_value\_create()}
\label{func_ada_to_fixed_value_create_ada-lang.c}

{\stt static struct value* ada\_to\_fixed\_value\_create ( struct type* type0, CORE\_ADDR address, struct value* val0 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_to\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_fixed_value}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_type\_match()}
\label{func_ada_type_match_ada-lang.c}

{\stt static int ada\_type\_match ( struct type* ftype, struct type* atype, int may\_deref )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_type\_match() & ada-lang.c & \cxreffunc{ada_type_match}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & ada\_args\_match() & ada-lang.c & \cxreffunc{ada_args_match}{ada-lang.c}\\
\ & ada\_type\_match() & ada-lang.c & \cxreffunc{ada_type_match}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_value\_assign()}
\label{func_ada_value_assign_ada-lang.c}

{\stt static struct value* ada\_value\_assign ( struct value* toval, struct value* fromval )}

\smallskip
\begin{cxreftabiii}
Calls:\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_modifiable() & value.c & \cxreffunc{deprecated_value_modifiable}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\ & move\_bits() & ada-lang.c & \cxreffunc{move_bits}{ada-lang.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & read\_memory() & corefile.c & \cxreffunc{read_memory}{corefile.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_bitpos() & value.c & \cxreffunc{value_bitpos}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_bitsize() & value.c & \cxreffunc{value_bitsize}{value.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & write\_memory() & corefile.c & \cxreffunc{write_memory}{corefile.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_value\_binop()}
\label{func_ada_value_binop_ada-lang.c}

{\stt static struct value* ada\_value\_binop ( struct value* arg1, struct value* arg2, enum exp\_opcode op )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & base\_type() & ada-lang.c & \cxreffunc{base_type}{ada-lang.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & op\_string() & expprint.c & \cxreffunc{op_string}{expprint.c}\\
\ & store\_unsigned\_integer() & findvar.c & \cxreffunc{store_unsigned_integer}{findvar.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_value\_equal()}
\label{func_ada_value_equal_ada-lang.c}

{\stt static int ada\_value\_equal ( struct value* arg1, struct value* arg2 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & ada\_is\_direct\_array\_type() & ada-lang.c & \cxreffunc{ada_is_direct_array_type}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ memcmp()} &\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_value\_primitive\_field()}
\label{func_ada_value_primitive_field_ada-lang.c}

{\stt static struct value* ada\_value\_primitive\_field ( struct value* arg1, int offset, int fieldno, struct type* arg\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
Called by:\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_value\_slice()}
\label{func_ada_value_slice_ada-lang.c}

{\stt static struct value* ada\_value\_slice ( struct value* array, int low, int high )}

\smallskip
\begin{cxreftabiii}
Calls:\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ada\_value\_slice\_ptr()}
\label{func_ada_value_slice_ptr_ada-lang.c}

{\stt static struct value* ada\_value\_slice\_ptr ( struct value* array\_ptr, struct type* type, int low, int high )}

\smallskip
\begin{cxreftabiii}
Calls:\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & lookup\_reference\_type() & gdbtypes.c & \cxreffunc{lookup_reference_type}{gdbtypes.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_defn\_to\_vec()}
\label{func_add_defn_to_vec_ada-lang.c}

{\stt static void add\_defn\_to\_vec ( struct obstack* obstackp, struct symbol* sym, struct block* block, struct symtab* symtab )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & defns\_collected() & ada-lang.c & \cxreffunc{defns_collected}{ada-lang.c}\\
\ & lesseq\_defined\_than() & ada-lang.c & \cxreffunc{lesseq_defined_than}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & num\_defns\_collected() & ada-lang.c & \cxreffunc{num_defns_collected}{ada-lang.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & ada\_add\_block\_symbols() & ada-lang.c & \cxreffunc{ada_add_block_symbols}{ada-lang.c}\\
\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_symbols\_from\_enclosing\_procs()}
\label{func_add_symbols_from_enclosing_procs_ada-lang.c}

{\stt static void add\_symbols\_from\_enclosing\_procs ( struct obstack* obstackp, const char* name, domain\_enum anamespace, int wild\_match )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function align\_value()}
\label{func_align_value_ada-lang.c}

{\stt static unsigned int align\_value ( unsigned int off, unsigned int alignment )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function base\_type()}
\label{func_base_type_ada-lang.c}

{\stt static struct type* base\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_is\_modular\_type() & ada-lang.c & \cxreffunc{ada_is_modular_type}{ada-lang.c}\\
\ & ada\_value\_binop() & ada-lang.c & \cxreffunc{ada_value_binop}{ada-lang.c}\\
\ & return\_match() & ada-lang.c & \cxreffunc{return_match}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cache\_symbol()}
\label{func_cache_symbol_ada-lang.c}

{\stt static void cache\_symbol ( const char* name, domain\_enum anamespace, struct symbol* sym, struct block* block, struct symtab* symtab )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\ & standard\_lookup() & ada-lang.c & \cxreffunc{standard_lookup}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cast\_from\_fixed\_to\_double()}
\label{func_cast_from_fixed_to_double_ada-lang.c}

{\stt static struct value* cast\_from\_fixed\_to\_double ( struct value* arg )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_fixed\_to\_float() & ada-lang.c & \cxreffunc{ada_fixed_to_float}{ada-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_from\_double() & value.c & \cxreffunc{value_from_double}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
Refs Var:\ & builtin\_type\_double & gdbtypes.c & \cxrefvar{builtin_type_double}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cast\_to\_fixed()}
\label{func_cast_to_fixed_ada-lang.c}

{\stt static struct value* cast\_to\_fixed ( struct type* type, struct value* arg )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_fixed\_to\_float() & ada-lang.c & \cxreffunc{ada_fixed_to_float}{ada-lang.c}\\
\ & ada\_float\_to\_fixed() & ada-lang.c & \cxreffunc{ada_float_to_fixed}{ada-lang.c}\\
\ & ada\_is\_fixed\_point\_type() & ada-lang.c & \cxreffunc{ada_is_fixed_point_type}{ada-lang.c}\\
\ & value\_as\_double() & value.c & \cxreffunc{value_as_double}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
Refs Var:\ & builtin\_type\_double & gdbtypes.c & \cxrefvar{builtin_type_double}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function check\_size()}
\label{func_check_size_ada-lang.c}

{\stt static void check\_size ( struct type* the\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
Refs Var:\ & varsize\_limit & ada-lang.c & \cxrefvar{varsize_limit}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function coerce\_for\_assign()}
\label{func_coerce_for_assign_ada-lang.c}

{\stt static struct value* coerce\_for\_assign ( struct type* type, struct value* val )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_value\_ind() & ada-lang.c & \cxreffunc{ada_value_ind}{ada-lang.c}\\
\ & deprecated\_set\_value\_type() & value.c & \cxreffunc{deprecated_set_value_type}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function coerce\_unspec\_val\_to\_type()}
\label{func_coerce_unspec_val_to_type_ada-lang.c}

{\stt static struct value* coerce\_unspec\_val\_to\_type ( struct value* val, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & check\_size() & ada-lang.c & \cxreffunc{check_size}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & set\_value\_bitpos() & value.c & \cxreffunc{set_value_bitpos}{value.c}\\
\ & set\_value\_bitsize() & value.c & \cxreffunc{set_value_bitsize}{value.c}\\
\ & set\_value\_lazy() & value.c & \cxreffunc{set_value_lazy}{value.c}\\
\ & value\_bitpos() & value.c & \cxreffunc{value_bitpos}{value.c}\\
\ & value\_bitsize() & value.c & \cxreffunc{value_bitsize}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & ada\_to\_static\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_static_fixed_value}{ada-lang.c}\\
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function cond\_offset\_host()}
\label{func_cond_offset_host_ada-lang.c}

{\stt static const gdb\_byte* cond\_offset\_host ( const gdb\_byte* valaddr, long offset )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cond\_offset\_target()}
\label{func_cond_offset_target_ada-lang.c}

{\stt static CORE\_ADDR cond\_offset\_target ( CORE\_ADDR address, long offset )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function convert\_actual()}
\label{func_convert_actual_ada-lang.c}

{\stt static struct value* convert\_actual ( struct value* actual, struct type* formal\_type0, CORE\_ADDR* sp )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_value\_ind() & ada-lang.c & \cxreffunc{ada_value_ind}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & desc\_data() & ada-lang.c & \cxreffunc{desc_data}{ada-lang.c}\\
\ & ensure\_lval() & ada-lang.c & \cxreffunc{ensure_lval}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & ada\_convert\_actuals() & ada-lang.c & \cxreffunc{ada_convert_actuals}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_packed\_array()}
\label{func_decode_packed_array_ada-lang.c}

{\stt static struct value* decode\_packed\_array ( struct value* arr )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_coerce\_ref() & ada-lang.c & \cxreffunc{ada_coerce_ref}{ada-lang.c}\\
\ & ada\_is\_modular\_type() & ada-lang.c & \cxreffunc{ada_is_modular_type}{ada-lang.c}\\
\ & ada\_modulus() & ada-lang.c & \cxreffunc{ada_modulus}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_ind() & ada-lang.c & \cxreffunc{ada_value_ind}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function decode\_packed\_array\_type()}
\label{func_decode_packed_array_type_ada-lang.c}

{\stt static struct type* decode\_packed\_array\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_selected\_block() & stack.c & \cxreffunc{get_selected_block}{stack.c}\\
\ & lim\_warning() & ada-lang.c & \cxreffunc{lim_warning}{ada-lang.c}\\
\ & packed\_array\_type() & ada-lang.c & \cxreffunc{packed_array_type}{ada-lang.c}\\
\ & standard\_lookup() & ada-lang.c & \cxreffunc{standard_lookup}{ada-lang.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), sscanf(), strlen(), strstr()} &\\
Called by:\ & ada\_array\_bound\_from\_type() & ada-lang.c & \cxreffunc{ada_array_bound_from_type}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function defns\_collected()}
\label{func_defns_collected_ada-lang.c}

{\stt static struct ada\_symbol\_info* defns\_collected ( struct obstack* obstackp, int finish )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\ & add\_defn\_to\_vec() & ada-lang.c & \cxreffunc{add_defn_to_vec}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function desc\_arity()}
\label{func_desc_arity_ada-lang.c}

{\stt static int desc\_arity ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
Called by:\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function desc\_base\_type()}
\label{func_desc_base_type_ada-lang.c}

{\stt static struct type* desc\_base\_type ( struct type* the\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
Called by:\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_array\_element\_type() & ada-lang.c & \cxreffunc{ada_array_element_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_index\_type() & ada-lang.c & \cxreffunc{ada_index_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\ & desc\_arity() & ada-lang.c & \cxreffunc{desc_arity}{ada-lang.c}\\
\ & desc\_bound\_bitpos() & ada-lang.c & \cxreffunc{desc_bound_bitpos}{ada-lang.c}\\
\ & desc\_bound\_bitsize() & ada-lang.c & \cxreffunc{desc_bound_bitsize}{ada-lang.c}\\
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_data\_type() & ada-lang.c & \cxreffunc{desc_data_type}{ada-lang.c}\\
\ & desc\_index\_type() & ada-lang.c & \cxreffunc{desc_index_type}{ada-lang.c}\\
\ & fat\_pntr\_bounds\_bitpos() & ada-lang.c & \cxreffunc{fat_pntr_bounds_bitpos}{ada-lang.c}\\
\ & fat\_pntr\_bounds\_bitsize() & ada-lang.c & \cxreffunc{fat_pntr_bounds_bitsize}{ada-lang.c}\\
\ & fat\_pntr\_data\_bitpos() & ada-lang.c & \cxreffunc{fat_pntr_data_bitpos}{ada-lang.c}\\
\ & fat\_pntr\_data\_bitsize() & ada-lang.c & \cxreffunc{fat_pntr_data_bitsize}{ada-lang.c}\\
\ & is\_thick\_pntr() & ada-lang.c & \cxreffunc{is_thick_pntr}{ada-lang.c}\\
\ & is\_thin\_pntr() & ada-lang.c & \cxreffunc{is_thin_pntr}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\ & thin\_descriptor\_type() & ada-lang.c & \cxreffunc{thin_descriptor_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function desc\_bound\_bitpos()}
\label{func_desc_bound_bitpos_ada-lang.c}

{\stt static int desc\_bound\_bitpos ( struct type* type, int i, int which )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function desc\_bound\_bitsize()}
\label{func_desc_bound_bitsize_ada-lang.c}

{\stt static int desc\_bound\_bitsize ( struct type* type, int i, int which )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function desc\_bounds()}
\label{func_desc_bounds_ada-lang.c}

{\stt static struct value* desc\_bounds ( struct value* arr )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & is\_thick\_pntr() & ada-lang.c & \cxreffunc{is_thick_pntr}{ada-lang.c}\\
\ & is\_thin\_pntr() & ada-lang.c & \cxreffunc{is_thin_pntr}{ada-lang.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & thin\_descriptor\_type() & ada-lang.c & \cxreffunc{thin_descriptor_type}{ada-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function desc\_bounds\_type()}
\label{func_desc_bounds_type_ada-lang.c}

{\stt static struct type* desc\_bounds\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & is\_thin\_pntr() & ada-lang.c & \cxreffunc{is_thin_pntr}{ada-lang.c}\\
\ & lookup\_struct\_elt\_type() & gdbtypes.c & \cxreffunc{lookup_struct_elt_type}{gdbtypes.c}\\
\ & thin\_descriptor\_type() & ada-lang.c & \cxreffunc{thin_descriptor_type}{ada-lang.c}\\
Called by:\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_index\_type() & ada-lang.c & \cxreffunc{ada_index_type}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function desc\_data()}
\label{func_desc_data_ada-lang.c}

{\stt static struct value* desc\_data ( struct value* arr )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & is\_thick\_pntr() & ada-lang.c & \cxreffunc{is_thick_pntr}{ada-lang.c}\\
\ & is\_thin\_pntr() & ada-lang.c & \cxreffunc{is_thin_pntr}{ada-lang.c}\\
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function desc\_data\_type()}
\label{func_desc_data_type_ada-lang.c}

{\stt static struct type* desc\_data\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & is\_thick\_pntr() & ada-lang.c & \cxreffunc{is_thick_pntr}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & is\_thin\_pntr() & ada-lang.c & \cxreffunc{is_thin_pntr}{ada-lang.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_struct\_elt\_type() & gdbtypes.c & \cxreffunc{lookup_struct_elt_type}{gdbtypes.c}\\
\ & thin\_descriptor\_type() & ada-lang.c & \cxreffunc{thin_descriptor_type}{ada-lang.c}\\
Called by:\ & ada\_array\_element\_type() & ada-lang.c & \cxreffunc{ada_array_element_type}{ada-lang.c}\\
\ & ada\_is\_array\_descriptor\_type() & ada-lang.c & \cxreffunc{ada_is_array_descriptor_type}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function desc\_index\_type()}
\label{func_desc_index_type_ada-lang.c}

{\stt static struct type* desc\_index\_type ( struct type* type, int i )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & lookup\_struct\_elt\_type() & gdbtypes.c & \cxreffunc{lookup_struct_elt_type}{gdbtypes.c}\\
Called by:\ & ada\_index\_type() & ada-lang.c & \cxreffunc{ada_index_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & bound\_name & ada-lang.c & \cxrefvar{bound_name}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function desc\_one\_bound()}
\label{func_desc_one_bound_ada-lang.c}

{\stt static struct value* desc\_one\_bound ( struct value* bounds, int i, int which )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
Called by:\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
Refs Var:\ & bound\_name & ada-lang.c & \cxrefvar{bound_name}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function discrete\_type\_high\_bound()}
\label{func_discrete_type_high_bound_ada-lang.c}

{\stt static struct value* discrete\_type\_high\_bound ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & max\_of\_type() & ada-lang.c & \cxreffunc{max_of_type}{ada-lang.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function discrete\_type\_low\_bound()}
\label{func_discrete_type_low_bound_ada-lang.c}

{\stt static struct value* discrete\_type\_low\_bound ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & min\_of\_type() & ada-lang.c & \cxreffunc{min_of_type}{ada-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function discrete\_type\_p()}
\label{func_discrete_type_p_ada-lang.c}

{\stt static int discrete\_type\_p ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & pos\_atr() & ada-lang.c & \cxreffunc{pos_atr}{ada-lang.c}\\
\ & value\_val\_atr() & ada-lang.c & \cxreffunc{value_val_atr}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function dynamic\_template\_type()}
\label{func_dynamic_template_type_ada-lang.c}

{\stt static struct type* dynamic\_template\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & \cxreftabiiispan{ strcmp(), strlen()} &\\
Called by:\ & to\_fixed\_record\_type() & ada-lang.c & \cxreffunc{to_fixed_record_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function emit\_char()}
\label{func_emit_char_ada-lang.c}

{\stt static void emit\_char ( int c, struct ui\_file* stream, int quoter )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_emit\_char() & ada-valprint.c & \cxreffunc{ada_emit_char}{ada-valprint.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function empty\_array()}
\label{func_empty_array_ada-lang.c}

{\stt static struct value* empty\_array ( struct type* arr\_type, int low )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_array\_element\_type() & ada-lang.c & \cxreffunc{ada_array_element_type}{ada-lang.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function empty\_record()}
\label{func_empty_record_ada-lang.c}

{\stt static struct type* empty\_record ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Calls:\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
Called by:\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function encoded\_ordered\_before()}
\label{func_encoded_ordered_before_ada-lang.c}

{\stt static int encoded\_ordered\_before ( const char* N0, const char* N1 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ atoi(), isdigit(), strcmp(), strlen(), strncmp()} &\\
Called by:\ & sort\_choices() & ada-lang.c & \cxreffunc{sort_choices}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ensure\_lval()}
\label{func_ensure_lval_ada-lang.c}

{\stt static struct value* ensure\_lval ( struct value* val, CORE\_ADDR* sp )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_frame\_align() & gdbarch.c & \cxreffunc{gdbarch_frame_align}{gdbarch.c}\\
\ & gdbarch\_frame\_align\_p() & gdbarch.c & \cxreffunc{gdbarch_frame_align_p}{gdbarch.c}\\
\ & gdbarch\_inner\_than() & gdbarch.c & \cxreffunc{gdbarch_inner_than}{gdbarch.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & write\_memory() & corefile.c & \cxreffunc{write_memory}{corefile.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function equiv\_types()}
\label{func_equiv_types_ada-lang.c}

{\stt static int equiv\_types ( struct type* type0, struct type* type1 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & lesseq\_defined\_than() & ada-lang.c & \cxreffunc{lesseq_defined_than}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function evaluate\_subexp()}
\label{func_evaluate_subexp_ada-lang.c}

{\stt static struct value* evaluate\_subexp ( struct type* expect\_type, struct expression* exp, int* pos, enum noside noside )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function evaluate\_subexp\_type()}
\label{func_evaluate_subexp_type_ada-lang.c}

{\stt static struct value* evaluate\_subexp\_type ( struct expression* exp, int* pos )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Called by:\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function extract\_string()}
\label{func_extract_string_ada-lang.c}

{\stt static void extract\_string ( CORE\_ADDR addr, char* buf )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & target\_read\_memory() & target/target.c & \cxreffunc{target_read_memory}{target/target.c}\\
Called by:\ & ada\_main\_name() & ada-lang.c & \cxreffunc{ada_main_name}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fat\_pntr\_bounds\_bitpos()}
\label{func_fat_pntr_bounds_bitpos_ada-lang.c}

{\stt static int fat\_pntr\_bounds\_bitpos ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fat\_pntr\_bounds\_bitsize()}
\label{func_fat_pntr_bounds_bitsize_ada-lang.c}

{\stt static int fat\_pntr\_bounds\_bitsize ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fat\_pntr\_data\_bitpos()}
\label{func_fat_pntr_data_bitpos_ada-lang.c}

{\stt static int fat\_pntr\_data\_bitpos ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
Called by:\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function fat\_pntr\_data\_bitsize()}
\label{func_fat_pntr_data_bitsize_ada-lang.c}

{\stt static int fat\_pntr\_data\_bitsize ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
Called by:\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function field\_alignment()}
\label{func_field_alignment_ada-lang.c}

{\stt static unsigned int field\_alignment ( struct type* type, int f )}

\smallskip
\begin{cxreftabiii}
Calls:\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ atoi(), isdigit(), strlen(), strncmp()} &\\
Called by:\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function field\_name\_match()}
\label{func_field_name_match_ada-lang.c}

{\stt static int field\_name\_match ( const char* field\_name, const char* target )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ strcmp(), strlen(), strncmp()} &\\
Called by:\ & ada\_get\_field\_index() & ada-lang.c & \cxreffunc{ada_get_field_index}{ada-lang.c}\\
\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\ & find\_struct\_field() & ada-lang.c & \cxreffunc{find_struct_field}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function find\_struct\_field()}
\label{func_find_struct_field_ada-lang.c}

{\stt static int find\_struct\_field ( const char* name, struct type* type, int offset, struct type** field\_type\_p, int* byte\_offset\_p, int* bit\_offset\_p, int* bit\_size\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_is\_variant\_part() & ada-lang.c & \cxreffunc{ada_is_variant_part}{ada-lang.c}\\
\ & ada\_is\_wrapper\_field() & ada-lang.c & \cxreffunc{ada_is_wrapper_field}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & field\_name\_match() & ada-lang.c & \cxreffunc{field_name_match}{ada-lang.c}\\
\ & find\_struct\_field() & ada-lang.c & \cxreffunc{find_struct_field}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
Called by:\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & find\_struct\_field() & ada-lang.c & \cxreffunc{find_struct_field}{ada-lang.c}\\
\ & value\_tag\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_tag_from_contents_and_address}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function fixed\_type\_info()}
\label{func_fixed_type_info_ada-lang.c}

{\stt static const char* fixed\_type\_info ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & fixed\_type\_info() & ada-lang.c & \cxreffunc{fixed_type_info}{ada-lang.c}\\
\ & \cxreftabiiispan{ strstr()} &\\
Called by:\ & ada\_delta() & ada-lang.c & \cxreffunc{ada_delta}{ada-lang.c}\\
\ & ada\_is\_fixed\_point\_type() & ada-lang.c & \cxreffunc{ada_is_fixed_point_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & fixed\_type\_info() & ada-lang.c & \cxreffunc{fixed_type_info}{ada-lang.c}\\
\ & scaling\_factor() & ada-lang.c & \cxreffunc{scaling_factor}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function get\_var\_value()}
\label{func_get_var_value_ada-lang.c}

{\stt static struct value* get\_var\_value ( const char* name, char* err\_msg )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_selected\_block() & stack.c & \cxreffunc{get_selected_block}{stack.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_of\_variable() & valops.c & \cxreffunc{value_of_variable}{valops.c}\\
Called by:\ & ada\_vax\_float\_print\_function() & ada-lang.c & \cxreffunc{ada_vax_float_print_function}{ada-lang.c}\\
\ & get\_int\_var\_value() & ada-lang.c & \cxreffunc{get_int_var_value}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function has\_negatives()}
\label{func_has_negatives_ada-lang.c}

{\stt static int has\_negatives ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function integer\_type\_p()}
\label{func_integer_type_p_ada-lang.c}

{\stt static int integer\_type\_p ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & integer\_type\_p() & ada-lang.c & \cxreffunc{integer_type_p}{ada-lang.c}\\
Called by:\ & integer\_type\_p() & ada-lang.c & \cxreffunc{integer_type_p}{ada-lang.c}\\
\ & possible\_user\_operator\_p() & ada-lang.c & \cxreffunc{possible_user_operator_p}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_val\_atr() & ada-lang.c & \cxreffunc{value_val_atr}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_dot\_digits\_suffix()}
\label{func_is_dot_digits_suffix_ada-lang.c}

{\stt static int is\_dot\_digits\_suffix ( const char* str )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ isdigit()} &\\
Called by:\ & wild\_match() & ada-lang.c & \cxreffunc{wild_match}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_dynamic\_field()}
\label{func_is_dynamic_field_ada-lang.c}

{\stt static int is\_dynamic\_field ( struct type* templ\_type, int field\_num )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & \cxreftabiiispan{ strstr()} &\\
Called by:\ & ada\_is\_variant\_part() & ada-lang.c & \cxreffunc{ada_is_variant_part}{ada-lang.c}\\
\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & template\_to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{template_to_static_fixed_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_name\_suffix()}
\label{func_is_name_suffix_ada-lang.c}

{\stt static int is\_name\_suffix ( const char* str )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & \cxreftabiiispan{ isdigit(), strcmp(), strlen()} &\\
Called by:\ & ada\_add\_block\_symbols() & ada-lang.c & \cxreffunc{ada_add_block_symbols}{ada-lang.c}\\
\ & ada\_lookup\_partial\_symbol() & ada-lang.c & \cxreffunc{ada_lookup_partial_symbol}{ada-lang.c}\\
\ & ada\_match\_name() & ada-lang.c & \cxreffunc{ada_match_name}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & wild\_match() & ada-lang.c & \cxreffunc{wild_match}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_nondebugging\_type()}
\label{func_is_nondebugging_type_ada-lang.c}

{\stt static int is\_nondebugging\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & remove\_extra\_symbols() & ada-lang.c & \cxreffunc{remove_extra_symbols}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_nonfunction()}
\label{func_is_nonfunction_ada-lang.c}

{\stt static int is\_nonfunction ( struct ada\_symbol\_info syms[], int n )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_package\_name()}
\label{func_is_package_name_ada-lang.c}

{\stt static int is\_package\_name ( const char* name )}

\smallskip
\begin{cxreftabiii}
Calls:\ & standard\_lookup() & ada-lang.c & \cxreffunc{standard_lookup}{ada-lang.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ strstr()} &\\
Called by:\ & renaming\_is\_visible() & ada-lang.c & \cxreffunc{renaming_is_visible}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_suffix()}
\label{func_is_suffix_ada-lang.c}

{\stt static int is\_suffix ( const char* str, const char* suffix )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ strcmp(), strlen()} &\\
Called by:\ & is\_thin\_pntr() & ada-lang.c & \cxreffunc{is_thin_pntr}{ada-lang.c}\\
\ & thin\_descriptor\_type() & ada-lang.c & \cxreffunc{thin_descriptor_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_suppressed\_name()}
\label{func_is_suppressed_name_ada-lang.c}

{\stt static int is\_suppressed\_name ( const char* str )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ isupper(), strlen(), strncmp(), strstr()} &\\
Called by:\ & ada\_suppress\_symbol\_printing() & ada-lang.c & \cxreffunc{ada_suppress_symbol_printing}{ada-lang.c}\\
Refs Var:\ & ada\_opname\_table & ada-lang.c & \cxrefvar{ada_opname_table}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_thick\_pntr()}
\label{func_is_thick_pntr_ada-lang.c}

{\stt static int is\_thick\_pntr ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & lookup\_struct\_elt\_type() & gdbtypes.c & \cxreffunc{lookup_struct_elt_type}{gdbtypes.c}\\
Called by:\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & desc\_data() & ada-lang.c & \cxreffunc{desc_data}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_data\_type() & ada-lang.c & \cxreffunc{desc_data_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function is\_thin\_pntr()}
\label{func_is_thin_pntr_ada-lang.c}

{\stt static int is\_thin\_pntr ( struct type* the\_type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & is\_suffix() & ada-lang.c & \cxreffunc{is_suffix}{ada-lang.c}\\
Called by:\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\ & desc\_data() & ada-lang.c & \cxreffunc{desc_data}{ada-lang.c}\\
\ & desc\_data\_type() & ada-lang.c & \cxreffunc{desc_data_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function lesseq\_defined\_than()}
\label{func_lesseq_defined_than_ada-lang.c}

{\stt static int lesseq\_defined\_than ( struct symbol* sym0, struct symbol* sym1 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & equiv\_types() & ada-lang.c & \cxreffunc{equiv_types}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ strlen(), strncmp()} &\\
Called by:\ & add\_defn\_to\_vec() & ada-lang.c & \cxreffunc{add_defn_to_vec}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function lim\_warning()}
\label{func_lim_warning_ada-lang.c}

{\stt static void lim\_warning ( const char* format, ... )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & vwarning() & utils.c & \cxreffunc{vwarning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_va\_end(), \_\_builtin\_va\_start()} &\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
\ & value\_subscript\_packed() & ada-lang.c & \cxreffunc{value_subscript_packed}{ada-lang.c}\\
Refs Var:\ & warning\_limit & ada-lang.c & \cxrefvar{warning_limit}{ada-lang.c}\\
\ & warnings\_issued & ada-lang.c & \cxrefvar{warnings_issued}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function lookup\_cached\_symbol()}
\label{func_lookup_cached_symbol_ada-lang.c}

{\stt static int lookup\_cached\_symbol ( const char* name, domain\_enum anamespace, struct symbol** sym, struct block** block, struct symtab** symtab )}

\smallskip
\begin{cxreftabiii}
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\ & standard\_lookup() & ada-lang.c & \cxreffunc{standard_lookup}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function make\_array\_descriptor()}
\label{func_make_array_descriptor_ada-lang.c}

{\stt static struct value* make\_array\_descriptor ( struct type* atype, struct value* arr, CORE\_ADDR* sp )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_array\_arity() & ada-lang.c & \cxreffunc{ada_array_arity}{ada-lang.c}\\
\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & desc\_bound\_bitpos() & ada-lang.c & \cxreffunc{desc_bound_bitpos}{ada-lang.c}\\
\ & desc\_bound\_bitsize() & ada-lang.c & \cxreffunc{desc_bound_bitsize}{ada-lang.c}\\
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\ & ensure\_lval() & ada-lang.c & \cxreffunc{ensure_lval}{ada-lang.c}\\
\ & fat\_pntr\_bounds\_bitpos() & ada-lang.c & \cxreffunc{fat_pntr_bounds_bitpos}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & fat\_pntr\_bounds\_bitsize() & ada-lang.c & \cxreffunc{fat_pntr_bounds_bitsize}{ada-lang.c}\\
\ & fat\_pntr\_data\_bitpos() & ada-lang.c & \cxreffunc{fat_pntr_data_bitpos}{ada-lang.c}\\
\ & fat\_pntr\_data\_bitsize() & ada-lang.c & \cxreffunc{fat_pntr_data_bitsize}{ada-lang.c}\\
\ & modify\_general\_field() & ada-lang.c & \cxreffunc{modify_general_field}{ada-lang.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_contents\_writeable() & value.c & \cxreffunc{value_contents_writeable}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function max\_of\_size()}
\label{func_max_of_size_ada-lang.c}

{\stt static long max\_of\_size ( int size )}

\smallskip
\begin{cxreftabiii}
Called by:\ & max\_of\_type() & ada-lang.c & \cxreffunc{max_of_type}{ada-lang.c}\\
\ & min\_of\_size() & ada-lang.c & \cxreffunc{min_of_size}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function max\_of\_type()}
\label{func_max_of_type_ada-lang.c}

{\stt static long max\_of\_type ( struct type* t )}

\smallskip
\begin{cxreftabiii}
Calls:\ & max\_of\_size() & ada-lang.c & \cxreffunc{max_of_size}{ada-lang.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & umax\_of\_size() & ada-lang.c & \cxreffunc{umax_of_size}{ada-lang.c}\\
Called by:\ & discrete\_type\_high\_bound() & ada-lang.c & \cxreffunc{discrete_type_high_bound}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function min\_of\_size()}
\label{func_min_of_size_ada-lang.c}

{\stt static long min\_of\_size ( int size )}

\smallskip
\begin{cxreftabiii}
Calls:\ & max\_of\_size() & ada-lang.c & \cxreffunc{max_of_size}{ada-lang.c}\\
Called by:\ & min\_of\_type() & ada-lang.c & \cxreffunc{min_of_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function min\_of\_type()}
\label{func_min_of_type_ada-lang.c}

{\stt static long min\_of\_type ( struct type* t )}

\smallskip
\begin{cxreftabiii}
Calls:\ & min\_of\_size() & ada-lang.c & \cxreffunc{min_of_size}{ada-lang.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
Called by:\ & discrete\_type\_low\_bound() & ada-lang.c & \cxreffunc{discrete_type_low_bound}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function modify\_general\_field()}
\label{func_modify_general_field_ada-lang.c}

{\stt static void modify\_general\_field ( char* addr, long fieldval, int bitpos, int bitsize )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & modify\_field() & value.c & \cxreffunc{modify_field}{value.c}\\
Called by:\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function move\_bits()}
\label{func_move_bits_ada-lang.c}

{\stt static void move\_bits ( gdb\_byte* target, int targ\_offset, const gdb\_byte* source, int src\_offset, int n )}

\smallskip
\begin{cxreftabiii}
Calls:\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
Called by:\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function num\_defns\_collected()}
\label{func_num_defns_collected_ada-lang.c}

{\stt static int num\_defns\_collected ( struct obstack* obstackp )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\ & add\_defn\_to\_vec() & ada-lang.c & \cxreffunc{add_defn_to_vec}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function numeric\_type\_p()}
\label{func_numeric_type_p_ada-lang.c}

{\stt static int numeric\_type\_p ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & numeric\_type\_p() & ada-lang.c & \cxreffunc{numeric_type_p}{ada-lang.c}\\
Called by:\ & numeric\_type\_p() & ada-lang.c & \cxreffunc{numeric_type_p}{ada-lang.c}\\
\ & possible\_user\_operator\_p() & ada-lang.c & \cxreffunc{possible_user_operator_p}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function packed\_array\_type()}
\label{func_packed_array_type_ada-lang.c}

{\stt static struct type* packed\_array\_type ( struct type* type, long* elt\_bits )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & get\_discrete\_bounds() & gdbtypes.c & \cxreffunc{get_discrete_bounds}{gdbtypes.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & packed\_array\_type() & ada-lang.c & \cxreffunc{packed_array_type}{ada-lang.c}\\
Called by:\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\ & packed\_array\_type() & ada-lang.c & \cxreffunc{packed_array_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function parse()}
\label{func_parse_ada-lang.c}

{\stt static int parse ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_parse() & ada-exp.c & \cxreffunc{ada_parse}{ada-exp.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Refs Var:\ & warnings\_issued & ada-lang.c & \cxrefvar{warnings_issued}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function pos\_atr()}
\label{func_pos_atr_ada-lang.c}

{\stt static long pos\_atr ( struct value* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & discrete\_type\_p() & ada-lang.c & \cxreffunc{discrete_type_p}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & value\_pos\_atr() & ada-lang.c & \cxreffunc{value_pos_atr}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function possible\_user\_operator\_p()}
\label{func_possible_user_operator_p_ada-lang.c}

{\stt static int possible\_user\_operator\_p ( enum exp\_opcode op, struct value* args[] )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & integer\_type\_p() & ada-lang.c & \cxreffunc{integer_type_p}{ada-lang.c}\\
\ & numeric\_type\_p() & ada-lang.c & \cxreffunc{numeric_type_p}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & scalar\_type\_p() & ada-lang.c & \cxreffunc{scalar_type_p}{ada-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remove\_extra\_symbols()}
\label{func_remove_extra_symbols_ada-lang.c}

{\stt static int remove\_extra\_symbols ( struct ada\_symbol\_info* syms, int nsyms )}

\smallskip
\begin{cxreftabiii}
Calls:\ & is\_nondebugging\_type() & ada-lang.c & \cxreffunc{is_nondebugging_type}{ada-lang.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remove\_out\_of\_scope\_renamings()}
\label{func_remove_out_of_scope_renamings_ada-lang.c}

{\stt static int remove\_out\_of\_scope\_renamings ( struct ada\_symbol\_info* syms, int nsyms, struct block* current\_block )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_is\_object\_renaming() & ada-lang.c & \cxreffunc{ada_is_object_renaming}{ada-lang.c}\\
\ & block\_function() & block.c & \cxreffunc{block_function}{block.c}\\
\ & renaming\_is\_visible() & ada-lang.c & \cxreffunc{renaming_is_visible}{ada-lang.c}\\
Called by:\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function renaming\_is\_visible()}
\label{func_renaming_is_visible_ada-lang.c}

{\stt static int renaming\_is\_visible ( const struct symbol* sym, const char* function\_name )}

\smallskip
\begin{cxreftabiii}
Calls:\ & is\_package\_name() & ada-lang.c & \cxreffunc{is_package_name}{ada-lang.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & xget\_renaming\_scope() & ada-lang.c & \cxreffunc{xget_renaming_scope}{ada-lang.c}\\
\ & \cxreftabiiispan{ strlen(), strncmp()} &\\
Called by:\ & remove\_out\_of\_scope\_renamings() & ada-lang.c & \cxreffunc{remove_out_of_scope_renamings}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Local Function replace\_operator\_with\_call()}
\label{func_replace_operator_with_call_ada-lang.c}

{\stt static void replace\_operator\_with\_call ( struct expression** expp, int pc, int nargs, int oplen, struct symbol* sym, struct block* block )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function resolve()}
\label{func_resolve_ada-lang.c}

{\stt static void resolve ( struct expression** expp, int void\_context\_p )}

\smallskip
\begin{cxreftabiii}
Calls:\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
Used in:\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Refs Var:\ & builtin\_type\_void & gdbtypes.c & \cxrefvar{builtin_type_void}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function resolve\_subexp()}
\label{func_resolve_subexp_ada-lang.c}

{\stt static struct value* resolve\_subexp ( struct expression** expp, int* pos, int deprocedure\_p, struct type* context\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_decoded\_op\_name() & ada-lang.c & \cxreffunc{ada_decoded_op_name}{ada-lang.c}\\
\ & ada\_encode() & ada-lang.c & \cxreffunc{ada_encode}{ada-lang.c}\\
\ & ada\_lookup\_symbol\_list() & ada-lang.c & \cxreffunc{ada_lookup_symbol_list}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_resolve\_function() & ada-lang.c & \cxreffunc{ada_resolve_function}{ada-lang.c}\\
\ & contained\_in() & block.c & \cxreffunc{contained_in}{block.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & evaluate\_subexp\_type() & ada-lang.c & \cxreffunc{evaluate_subexp_type}{ada-lang.c}\\
\ & is\_nonfunction() & ada-lang.c & \cxreffunc{is_nonfunction}{ada-lang.c}\\
\ & longest\_to\_int() & valprint.c & \cxreffunc{longest_to_int}{valprint.c}\\
\ & possible\_user\_operator\_p() & ada-lang.c & \cxreffunc{possible_user_operator_p}{ada-lang.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & replace\_operator\_with\_call() & ada-lang.c & \cxreffunc{replace_operator_with_call}{ada-lang.c}\\
\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
\ & user\_select\_syms() & ada-lang.c & \cxreffunc{user_select_syms}{ada-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_alloca()} &\\
Called by:\ & resolve() & ada-lang.c & \cxreffunc{resolve}{ada-lang.c}\\
\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
Refs Var:\ & demangle & utils.c & \cxrefvar{demangle}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\end{cxreftabiii}


\subsubsection{Local Function restore\_language()}
\label{func_restore_language_ada-lang.c}

{\stt static void restore\_language ( void* lang )}

\smallskip
\begin{cxreftabiii}
Calls:\ & set\_language() & language.c & \cxreffunc{set_language}{language.c}\\
Used in:\ & lookup\_symbol\_in\_language() & ada-lang.c & \cxreffunc{lookup_symbol_in_language}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function return\_match()}
\label{func_return_match_ada-lang.c}

{\stt static int return\_match ( struct type* func\_type, struct type* context\_type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & base\_type() & ada-lang.c & \cxreffunc{base_type}{ada-lang.c}\\
Called by:\ & ada\_resolve\_function() & ada-lang.c & \cxreffunc{ada_resolve_function}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function scalar\_type\_p()}
\label{func_scalar_type_p_ada-lang.c}

{\stt static int scalar\_type\_p ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Called by:\ & possible\_user\_operator\_p() & ada-lang.c & \cxreffunc{possible_user_operator_p}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function scaling\_factor()}
\label{func_scaling_factor_ada-lang.c}

{\stt static DOUBLEST scaling\_factor ( struct type* the\_type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fixed\_type\_info() & ada-lang.c & \cxreffunc{fixed_type_info}{ada-lang.c}\\
\ & \cxreftabiiispan{ sscanf()} &\\
Called by:\ & ada\_fixed\_to\_float() & ada-lang.c & \cxreffunc{ada_fixed_to_float}{ada-lang.c}\\
\ & ada\_float\_to\_fixed() & ada-lang.c & \cxreffunc{ada_float_to_fixed}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function scan\_discrim\_bound()}
\label{func_scan_discrim_bound_ada-lang.c}

{\stt static int scan\_discrim\_bound ( char* str, int k, struct value* dval, long* px, int* pnew\_k )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_search\_struct\_field() & ada-lang.c & \cxreffunc{ada_search_struct_field}{ada-lang.c}\\
\ & grow\_vect() & ada-lang.c & \cxreffunc{grow_vect}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), strlen(), strstr()} &\\
Called by:\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function sort\_choices()}
\label{func_sort_choices_ada-lang.c}

{\stt static void sort\_choices ( struct ada\_symbol\_info syms[], int nsyms )}

\smallskip
\begin{cxreftabiii}
Calls:\ & encoded\_ordered\_before() & ada-lang.c & \cxreffunc{encoded_ordered_before}{ada-lang.c}\\
Called by:\ & user\_select\_syms() & ada-lang.c & \cxreffunc{user_select_syms}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function standard\_lookup()}
\label{func_standard_lookup_ada-lang.c}

{\stt static struct symbol* standard\_lookup ( const char* name, const struct block* block, domain\_enum domain )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & cache\_symbol() & ada-lang.c & \cxreffunc{cache_symbol}{ada-lang.c}\\
\ & lookup\_cached\_symbol() & ada-lang.c & \cxreffunc{lookup_cached_symbol}{ada-lang.c}\\
\ & lookup\_symbol\_in\_language() & ada-lang.c & \cxreffunc{lookup_symbol_in_language}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_find\_any\_symbol() & ada-lang.c & \cxreffunc{ada_find_any_symbol}{ada-lang.c}\\
\ & decode\_packed\_array\_type() & ada-lang.c & \cxreffunc{decode_packed_array_type}{ada-lang.c}\\
\ & is\_package\_name() & ada-lang.c & \cxreffunc{is_package_name}{ada-lang.c}\\
Refs Var:\ & block\_found & symtab.c & \cxrefvar{block_found}{symtab.c}\\
\end{cxreftabiii}


\subsubsection{Local Function static\_unwrap\_type()}
\label{func_static_unwrap_type_ada-lang.c}

{\stt static struct type* static\_unwrap\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_get\_base\_type() & ada-lang.c & \cxreffunc{ada_get_base_type}{ada-lang.c}\\
\ & ada\_is\_aligner\_type() & ada-lang.c & \cxreffunc{ada_is_aligner_type}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_to\_static\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_static_fixed_value}{ada-lang.c}\\
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function symtab\_for\_sym()}
\label{func_symtab_for_sym_ada-lang.c}

{\stt static struct symtab* symtab\_for\_sym ( struct symbol* sym )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & dict\_iterator\_first() & dictionary.c & \cxreffunc{dict_iterator_first}{dictionary.c}\\
\ & dict\_iterator\_next() & dictionary.c & \cxreffunc{dict_iterator_next}{dictionary.c}\\
\ & objfile\_get\_first() & objfiles.c & \cxreffunc{objfile_get_first}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & objfile\_get\_next() & objfiles.c & \cxreffunc{objfile_get_next}{objfiles.c}\\
\ & symtab\_get\_first() & objfiles.c & \cxreffunc{symtab_get_first}{objfiles.c}\\
\ & symtab\_get\_next() & objfiles.c & \cxreffunc{symtab_get_next}{objfiles.c}\\
Called by:\ & user\_select\_syms() & ada-lang.c & \cxreffunc{user_select_syms}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function template\_to\_fixed\_record\_type()}
\label{func_template_to_fixed_record_type_ada-lang.c}

{\stt static struct type* template\_to\_fixed\_record\_type ( struct type* type, const gdb\_byte* valaddr, CORE\_ADDR address, struct value* dval0 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
Called by:\ & to\_fixed\_record\_type() & ada-lang.c & \cxreffunc{to_fixed_record_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function template\_to\_static\_fixed\_type()}
\label{func_template_to_static_fixed_type_ada-lang.c}

{\stt static struct type* template\_to\_static\_fixed\_type ( struct type* type0 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & is\_dynamic\_field() & ada-lang.c & \cxreffunc{is_dynamic_field}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{to_static_fixed_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function thin\_data\_pntr()}
\label{func_thin_data_pntr_ada-lang.c}

{\stt static struct value* thin\_data\_pntr ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Calls:\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & desc\_data\_type() & ada-lang.c & \cxreffunc{desc_data_type}{ada-lang.c}\\
\ & thin\_descriptor\_type() & ada-lang.c & \cxreffunc{thin_descriptor_type}{ada-lang.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & desc\_data() & ada-lang.c & \cxreffunc{desc_data}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function thin\_descriptor\_type()}
\label{func_thin_descriptor_type_ada-lang.c}

{\stt static struct type* thin\_descriptor\_type ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & desc\_base\_type() & ada-lang.c & \cxreffunc{desc_base_type}{ada-lang.c}\\
\ & is\_suffix() & ada-lang.c & \cxreffunc{is_suffix}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & desc\_bounds\_type() & ada-lang.c & \cxreffunc{desc_bounds_type}{ada-lang.c}\\
\ & desc\_data\_type() & ada-lang.c & \cxreffunc{desc_data_type}{ada-lang.c}\\
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function to\_fixed\_array\_type()}
\label{func_to_fixed_array_type_ada-lang.c}

{\stt static struct type* to\_fixed\_array\_type ( struct type* type0, struct value* dval, int ignore\_too\_big )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & ada\_is\_packed\_array\_type() & ada-lang.c & \cxreffunc{ada_is_packed_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & to\_fixed\_range\_type() & ada-lang.c & \cxreffunc{to_fixed_range_type}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & varsize\_limit & ada-lang.c & \cxrefvar{varsize_limit}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function to\_fixed\_range\_type()}
\label{func_to_fixed_range_type_ada-lang.c}

{\stt static struct type* to\_fixed\_range\_type ( const char* name, struct value* dval, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_find\_any\_type() & ada-lang.c & \cxreffunc{ada_find_any_type}{ada-lang.c}\\
\ & ada\_scan\_number() & ada-lang.c & \cxreffunc{ada_scan_number}{ada-lang.c}\\
\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\ & get\_int\_var\_value() & ada-lang.c & \cxreffunc{get_int_var_value}{ada-lang.c}\\
\ & grow\_vect() & ada-lang.c & \cxreffunc{grow_vect}{ada-lang.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & lim\_warning() & ada-lang.c & \cxreffunc{lim_warning}{ada-lang.c}\\
\ & scan\_discrim\_bound() & ada-lang.c & \cxreffunc{scan_discrim_bound}{ada-lang.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), \_\_inline\_strncpy\_chk(), strchr(), strstr()} &\\
Called by:\ & ada\_array\_bound\_from\_type() & ada-lang.c & \cxreffunc{ada_array_bound_from_type}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & to\_fixed\_array\_type() & ada-lang.c & \cxreffunc{to_fixed_array_type}{ada-lang.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function to\_fixed\_record\_type()}
\label{func_to_fixed_record_type_ada-lang.c}

{\stt static struct type* to\_fixed\_record\_type ( struct type* type0, const gdb\_byte* valaddr, CORE\_ADDR address, struct value* dval )}

\smallskip
\begin{cxreftabiii}
Calls:\ & dynamic\_template\_type() & ada-lang.c & \cxreffunc{dynamic_template_type}{ada-lang.c}\\
\ & template\_to\_fixed\_record\_type() & ada-lang.c & \cxreffunc{template_to_fixed_record_type}{ada-lang.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\ & variant\_field\_index() & ada-lang.c & \cxreffunc{variant_field_index}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function to\_fixed\_variant\_branch\_type()}
\label{func_to_fixed_variant_branch_type_ada-lang.c}

{\stt static struct type* to\_fixed\_variant\_branch\_type ( struct type* var\_type0, const gdb\_byte* valaddr, CORE\_ADDR address, struct value* dval )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & ada\_which\_variant\_applies() & ada-lang.c & \cxreffunc{ada_which_variant_applies}{ada-lang.c}\\
\ & empty\_record() & ada-lang.c & \cxreffunc{empty_record}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & is\_dynamic\_field() & ada-lang.c & \cxreffunc{is_dynamic_field}{ada-lang.c}\\
\ & to\_fixed\_record\_type() & ada-lang.c & \cxreffunc{to_fixed_record_type}{ada-lang.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & variant\_field\_index() & ada-lang.c & \cxreffunc{variant_field_index}{ada-lang.c}\\
Called by:\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function to\_record\_with\_fixed\_variant\_part()}
\label{func_to_record_with_fixed_variant_part_ada-lang.c}

{\stt static struct type* to\_record\_with\_fixed\_variant\_part ( struct type* type, const gdb\_byte* valaddr, CORE\_ADDR address, struct value* dval0 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & alloc\_type() & gdbtypes.c & \cxreffunc{alloc_type}{gdbtypes.c}\\
\ & cond\_offset\_host() & ada-lang.c & \cxreffunc{cond_offset_host}{ada-lang.c}\\
\ & cond\_offset\_target() & ada-lang.c & \cxreffunc{cond_offset_target}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
\ & variant\_field\_index() & ada-lang.c & \cxreffunc{variant_field_index}{ada-lang.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), \_obstack\_newchunk()} &\\
Called by:\ & to\_fixed\_record\_type() & ada-lang.c & \cxreffunc{to_fixed_record_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function to\_static\_fixed\_type()}
\label{func_to_static_fixed_type_ada-lang.c}

{\stt static struct type* to\_static\_fixed\_type ( struct type* type0 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_find\_parallel\_type() & ada-lang.c & \cxreffunc{ada_find_parallel_type}{ada-lang.c}\\
\ & dynamic\_template\_type() & ada-lang.c & \cxreffunc{dynamic_template_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & template\_to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{template_to_static_fixed_type}{ada-lang.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_lookup\_struct\_elt\_type() & ada-lang.c & \cxreffunc{ada_lookup_struct_elt_type}{ada-lang.c}\\
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\ & ada\_to\_static\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_static_fixed_value}{ada-lang.c}\\
\ & static\_unwrap\_type() & ada-lang.c & \cxreffunc{static_unwrap_type}{ada-lang.c}\\
\ & template\_to\_static\_fixed\_type() & ada-lang.c & \cxreffunc{template_to_static_fixed_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function type\_from\_tag()}
\label{func_type_from_tag_ada-lang.c}

{\stt static struct type* type\_from\_tag ( struct value* tag )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_encode() & ada-lang.c & \cxreffunc{ada_encode}{ada-lang.c}\\
\ & ada\_find\_any\_type() & ada-lang.c & \cxreffunc{ada_find_any_type}{ada-lang.c}\\
\ & ada\_tag\_name() & ada-lang.c & \cxreffunc{ada_tag_name}{ada-lang.c}\\
Called by:\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function umax\_of\_size()}
\label{func_umax_of_size_ada-lang.c}

{\stt static unsigned long umax\_of\_size ( int size )}

\smallskip
\begin{cxreftabiii}
Called by:\ & max\_of\_type() & ada-lang.c & \cxreffunc{max_of_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function unwrap\_value()}
\label{func_unwrap_value_ada-lang.c}

{\stt static struct value* unwrap\_value ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_get\_base\_type() & ada-lang.c & \cxreffunc{ada_get_base_type}{ada-lang.c}\\
\ & ada\_is\_aligner\_type() & ada-lang.c & \cxreffunc{ada_is_aligner_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\ & ada\_type\_name() & ada-lang.c & \cxreffunc{ada_type_name}{ada-lang.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_coerce\_ref() & ada-lang.c & \cxreffunc{ada_coerce_ref}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_value\_ind() & ada-lang.c & \cxreffunc{ada_value_ind}{ada-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function value\_pos\_atr()}
\label{func_value_pos_atr_ada-lang.c}

{\stt static struct value* value\_pos\_atr ( struct value* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & pos\_atr() & ada-lang.c & \cxreffunc{pos_atr}{ada-lang.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_ptr\_subscript() & ada-lang.c & \cxreffunc{ada_value_ptr_subscript}{ada-lang.c}\\
\ & ada\_value\_subscript() & ada-lang.c & \cxreffunc{ada_value_subscript}{ada-lang.c}\\
\ & value\_subscript\_packed() & ada-lang.c & \cxreffunc{value_subscript_packed}{ada-lang.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Local Function value\_subscript\_packed()}
\label{func_value_subscript_packed_ada-lang.c}

{\stt static struct value* value\_subscript\_packed ( struct value* arr, int arity, struct value** ind )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & ada\_check\_typedef() & ada-lang.c & \cxreffunc{ada_check_typedef}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_discrete\_bounds() & gdbtypes.c & \cxreffunc{get_discrete_bounds}{gdbtypes.c}\\
\ & lim\_warning() & ada-lang.c & \cxreffunc{lim_warning}{ada-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_pos\_atr() & ada-lang.c & \cxreffunc{value_pos_atr}{ada-lang.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_value\_subscript() & ada-lang.c & \cxreffunc{ada_value_subscript}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function value\_tag\_from\_contents\_and\_address()}
\label{func_value_tag_from_contents_and_address_ada-lang.c}

{\stt static struct value* value\_tag\_from\_contents\_and\_address ( struct type* type, const gdb\_byte* valaddr, CORE\_ADDR address )}

\smallskip
\begin{cxreftabiii}
Calls:\ & find\_struct\_field() & ada-lang.c & \cxreffunc{find_struct_field}{ada-lang.c}\\
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
Called by:\ & ada\_to\_fixed\_type() & ada-lang.c & \cxreffunc{ada_to_fixed_type}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function value\_val\_atr()}
\label{func_value_val_atr_ada-lang.c}

{\stt static struct value* value\_val\_atr ( struct type* type, struct value* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & discrete\_type\_p() & ada-lang.c & \cxreffunc{discrete_type_p}{ada-lang.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & integer\_type\_p() & ada-lang.c & \cxreffunc{integer_type_p}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function variant\_field\_index()}
\label{func_variant_field_index_ada-lang.c}

{\stt static int variant\_field\_index ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ada\_is\_variant\_part() & ada-lang.c & \cxreffunc{ada_is_variant_part}{ada-lang.c}\\
Called by:\ & to\_fixed\_record\_type() & ada-lang.c & \cxreffunc{to_fixed_record_type}{ada-lang.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function wild\_match()}
\label{func_wild_match_ada-lang.c}

{\stt static int wild\_match ( const char* patn0, int patn\_len, const char* name0 )}

\smallskip
\begin{cxreftabiii}
Prototype:& ada-lang.c & \ & \cxreffile{ada-lang.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & is\_dot\_digits\_suffix() & ada-lang.c & \cxreffunc{is_dot_digits_suffix}{ada-lang.c}\\
\ & is\_name\_suffix() & ada-lang.c & \cxreffunc{is_name_suffix}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), \_\_inline\_strncpy\_chk(), islower(), strlen(), strncmp(), strrchr()} &\\
Called by:\ & ada\_add\_block\_symbols() & ada-lang.c & \cxreffunc{ada_add_block_symbols}{ada-lang.c}\\
\ & ada\_lookup\_partial\_symbol() & ada-lang.c & \cxreffunc{ada_lookup_partial_symbol}{ada-lang.c}\\
\ & ada\_match\_name() & ada-lang.c & \cxreffunc{ada_match_name}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Local Function xget\_renaming\_scope()}
\label{func_xget_renaming_scope_ada-lang.c}

{\stt static char* xget\_renaming\_scope ( struct type* renaming\_type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & type\_name\_no\_tag() & gdbtypes.c & \cxreffunc{type_name_no_tag}{gdbtypes.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), strstr()} &\\
Called by:\ & renaming\_is\_visible() & ada-lang.c & \cxreffunc{renaming_is_visible}{ada-lang.c}\\
\end{cxreftabiii}

