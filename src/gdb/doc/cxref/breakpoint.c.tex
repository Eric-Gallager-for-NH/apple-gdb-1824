% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF breakpoint.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File breakpoint.c}{File breakpoint.c}
\section{File breakpoint.c}
\label{file_breakpoint.c}

\smallskip
\begin{cxreftabiii}
Refs Func:\ & print\_exception\_catchpoint() & breakpoint.c & \cxreffunc{print_exception_catchpoint}{breakpoint.c}\\
\ & print\_mention\_exception\_catchpoint() & breakpoint.c & \cxreffunc{print_mention_exception_catchpoint}{breakpoint.c}\\
\ & print\_one\_exception\_catchpoint() & breakpoint.c & \cxreffunc{print_one_exception_catchpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <time.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <ctype.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{0.8in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.6in}{\stt \#include <regex.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.4in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{0.6in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.6in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "gdb-events.h"} &\cxreffile{gdb-events.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcore.h"} &\cxreffile{gdbcore.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "value.h"} &\cxreffile{value.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "command.h"} &\cxreffile{command.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inferior.h"} &\cxreffile{inferior.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.2in}{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\hspace*{0.4in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbthread.h"} &\cxreffile{gdbthread.h}\\
\hspace*{0.2in}{\stt \#include "breakpoint.h"} &\cxreffile{breakpoint.h}\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include <block.h>} &\\
\hspace*{0.4in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "target.h"} &\cxreffile{target.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/demangle.h"} &\cxreffile{../include/demangle.h}\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "annotate.h"} &\cxreffile{annotate.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.2in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objfiles.h"} &\cxreffile{objfiles.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <uuid/uuid.h>} &\\
\hspace*{0.2in}{\stt \#include "gdb\_obstack.h"} &\cxreffile{gdb_obstack.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/obstack.h"} &\cxreffile{../include/obstack.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.6in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include "symfile.h"} &\cxreffile{symfile.h}\\
\hspace*{0.2in}{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\hspace*{0.2in}{\stt \#include <sqlite3.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "source.h"} &\cxreffile{source.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "linespec.h"} &\cxreffile{linespec.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "completer.h"} &\cxreffile{completer.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb.h"} &\cxreffile{gdb.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cli/cli-script.h"} &\cxreffile{cli/cli-script.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "cli-out.h"} &\cxreffile{cli-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "block.h"} &\cxreffile{block.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "wrapper.h"} &\cxreffile{wrapper.h}\\
\hspace*{0.2in}{\stt \#include "gdb.h"} &\cxreffile{gdb.h}\\
\hspace*{0.2in}{\stt \#include "varobj.h"} &\cxreffile{varobj.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "solib.h"} &\cxreffile{solib.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "solist.h"} &\cxreffile{solist.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "observer.h"} &\cxreffile{observer.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "exceptions.h"} &\cxreffile{exceptions.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\hspace*{0.2in}{\stt \#include <setjmp.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb-events.h"} &\cxreffile{gdb-events.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../readline/tilde.h"} &\cxreffile{../readline/tilde.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "mi/mi-common.h"} &\cxreffile{mi/mi-common.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "inlining.h"} &\cxreffile{inlining.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "objc-lang.h"} &\cxreffile{objc-lang.h}\\
\hspace*{0.2in}{\stt \#include <Availability.h>} &\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define BREAKPOINT\_C\_NOT\_ON\_i386 1}

\medskip
{\stt \#define ALL\_BREAKPOINTS( B )}

\medskip
{\stt \#define ALL\_BREAKPOINTS\_SAFE( B, TMP )}

\medskip
{\stt \#define ALL\_BP\_LOCATIONS( B )}

\medskip
{\stt \#define ALL\_BP\_LOCATIONS\_SAFE( B, TMP )}

\medskip
{\stt \#define WP\_DELETED 1}

\medskip
{\stt \#define WP\_VALUE\_CHANGED 2}

\medskip
{\stt \#define WP\_VALUE\_NOT\_CHANGED 3}

\medskip
{\stt \#define BP\_TEMPFLAG 1}

\medskip
{\stt \#define BP\_HARDWAREFLAG 2}

\medskip
{\stt \#define BP\_FUTUREFLAG 4}

\medskip
{\stt \#define kc BPSTAT\_WHAT\_KEEP\_CHECKING}

\medskip
{\stt \#define ss BPSTAT\_WHAT\_STOP\_SILENT}

\medskip
{\stt \#define sn BPSTAT\_WHAT\_STOP\_NOISY}

\medskip
{\stt \#define sgl BPSTAT\_WHAT\_SINGLE}

\medskip
{\stt \#define slr BPSTAT\_WHAT\_SET\_LONGJMP\_RESUME}

\medskip
{\stt \#define clr BPSTAT\_WHAT\_CLEAR\_LONGJMP\_RESUME}

\medskip
{\stt \#define clrs BPSTAT\_WHAT\_CLEAR\_LONGJMP\_RESUME\_SINGLE}

\medskip
{\stt \#define sr BPSTAT\_WHAT\_STEP\_RESUME}

\medskip
{\stt \#define ts BPSTAT\_WHAT\_THROUGH\_SIGTRAMP}

\medskip
{\stt \#define shl BPSTAT\_WHAT\_CHECK\_SHLIBS}

\medskip
{\stt \#define shlr BPSTAT\_WHAT\_CHECK\_SHLIBS\_RESUME\_FROM\_HOOK}

\medskip
{\stt \#define err BPSTAT\_WHAT\_STOP\_NOISY}


\subsection{Type definitions}


\subsubsection{Type struct breakpoint\_list}
\label{type_struct_breakpoint_list_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct breakpoint\_list} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct breakpoint\_list* next;} &\\
\hspace*{0.2in}{\stt struct breakpoint* bp;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef insertion\_state\_t}
\label{type_insertion_state_t_breakpoint.c}

{\stt typedef enum \{...\} insertion\_state\_t}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt mark\_inserted;} &\\
\hspace*{0.2in}{\stt mark\_uninserted;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef args\_for\_catchpoint\_enable}
\label{type_args_for_catchpoint_enable_breakpoint.c}

{\stt typedef struct \{...\} args\_for\_catchpoint\_enable}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum exception\_event\_kind kind;} &\\
\hspace*{0.2in}{\stt int enable\_p;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum bpstat\_class}
\label{type_enum_bpstat_class_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum bpstat\_class} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt no\_effect;} &\\
\hspace*{0.2in}{\stt wp\_silent;} &\\
\hspace*{0.2in}{\stt wp\_noisy;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt bp\_nostop;} &\\
\hspace*{0.2in}{\stt bp\_silent;} &\\
\hspace*{0.2in}{\stt bp\_noisy;} &\\
\hspace*{0.2in}{\stt long\_jump;} &\\
\hspace*{0.2in}{\stt long\_resume;} &\\
\hspace*{0.2in}{\stt step\_resume;} &\\
\hspace*{0.2in}{\stt through\_sig;} &\\
\hspace*{0.2in}{\stt shlib\_event;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt catch\_shlib\_event;} &\\
\hspace*{0.2in}{\stt class\_last;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct ep\_type\_description}
\label{type_struct_ep_type_description_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct ep\_type\_description} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum bptype type;} &\\
\hspace*{0.2in}{\stt const char* description;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct captured\_breakpoint\_query\_args}
\label{type_struct_captured_breakpoint_query_args_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct captured\_breakpoint\_query\_args} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt int bnum;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct captured\_parse\_breakpoint\_args}
\label{type_struct_captured_parse_breakpoint_args_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct captured\_parse\_breakpoint\_args} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt const char** arg\_p;} &\\
\hspace*{0.2in}{\stt struct symtabs\_and\_lines* sals\_p;} &\\
\hspace*{0.2in}{\stt char*** addr\_string\_p;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt char* requested\_shlib;} &\\
\hspace*{0.2in}{\stt int* not\_found\_ptr;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct lang\_and\_radix}
\label{type_struct_lang_and_radix_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct lang\_and\_radix} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum language lang;} &\\
\hspace*{0.2in}{\stt int radix;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct safe\_sals\_to\_pc\_args}
\label{type_struct_safe_sals_to_pc_args_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct safe\_sals\_to\_pc\_args} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct symtabs\_and\_lines* sals;} &\\
\hspace*{0.2in}{\stt const char* address;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct captured\_breakpoint\_args}
\label{type_struct_captured_breakpoint_args_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct captured\_breakpoint\_args} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* address;} &\\
\hspace*{0.2in}{\stt char* condition;} &\\
\hspace*{0.2in}{\stt int hardwareflag;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int tempflag;} &\\
\hspace*{0.2in}{\stt int thread;} &\\
\hspace*{0.2in}{\stt int ignore\_count;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef catch\_fork\_kind}
\label{type_catch_fork_kind_breakpoint.c}

{\stt typedef enum \{...\} catch\_fork\_kind}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt catch\_fork;} &\\
\hspace*{0.2in}{\stt catch\_vfork;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct sal\_chain}
\label{type_struct_sal_chain_breakpoint.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct sal\_chain} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct sal\_chain* next;} &\\
\hspace*{0.2in}{\stt struct symtab\_and\_line sal;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable deprecated\_exception\_catchpoints\_are\_fragile}
\label{var_deprecated_exception_catchpoints_are_fragile_breakpoint.c}

{\stt int deprecated\_exception\_catchpoints\_are\_fragile}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-exp.c & \ & \cxreffile{ada-exp.c}\\
\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & ada-typeprint.c & \ & \cxreffile{ada-typeprint.c}\\
\ & ada-valprint.c & \ & \cxreffile{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & coffread.c & \ & \cxreffile{coffread.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & linespec.c & \ & \cxreffile{linespec.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & printcmd.c & \ & \cxreffile{printcmd.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\cxreftabbreak{cxreftabiii}
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symmisc.c & \ & \cxreffile{symmisc.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\cxreftabbreak{cxreftabiii}
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & breakpoint\_init\_inferior() & breakpoint.c & \cxreffunc{breakpoint_init_inferior}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable deprecated\_exception\_support\_initialized}
\label{var_deprecated_exception_support_initialized_breakpoint.c}

{\stt int deprecated\_exception\_support\_initialized}

\smallskip
\begin{cxreftabiii}
Visible in:\ & ada-exp.c & \ & \cxreffile{ada-exp.c}\\
\ & ada-lang.c & \ & \cxreffile{ada-lang.c}\\
\ & ada-typeprint.c & \ & \cxreffile{ada-typeprint.c}\\
\ & ada-valprint.c & \ & \cxreffile{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & arch-utils.c & \ & \cxreffile{arch-utils.c}\\
\ & block.c & \ & \cxreffile{block.c}\\
\ & blockframe.c & \ & \cxreffile{blockframe.c}\\
\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & coffread.c & \ & \cxreffile{coffread.c}\\
\ & corefile.c & \ & \cxreffile{corefile.c}\\
\ & dbxread.c & \ & \cxreffile{dbxread.c}\\
\ & dummy-frame.c & \ & \cxreffile{dummy-frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & dwarf2loc.c & \ & \cxreffile{dwarf2loc.c}\\
\ & event-top.c & \ & \cxreffile{event-top.c}\\
\ & findvar.c & \ & \cxreffile{findvar.c}\\
\ & frame.c & \ & \cxreffile{frame.c}\\
\ & gdbarch.c & \ & \cxreffile{gdbarch.c}\\
\ & inf-loop.c & \ & \cxreffile{inf-loop.c}\\
\ & infcall.c & \ & \cxreffile{infcall.c}\\
\ & infcmd.c & \ & \cxreffile{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & inflow.c & \ & \cxreffile{inflow.c}\\
\ & infrun.c & \ & \cxreffile{infrun.c}\\
\ & inlining.c & \ & \cxreffile{inlining.c}\\
\ & linespec.c & \ & \cxreffile{linespec.c}\\
\ & macroscope.c & \ & \cxreffile{macroscope.c}\\
\ & main.c & \ & \cxreffile{main.c}\\
\ & mem-break.c & \ & \cxreffile{mem-break.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc-lang.c & \ & \cxreffile{objc-lang.c}\\
\ & objfiles.c & \ & \cxreffile{objfiles.c}\\
\ & parse.c & \ & \cxreffile{parse.c}\\
\ & printcmd.c & \ & \cxreffile{printcmd.c}\\
\ & regcache.c & \ & \cxreffile{regcache.c}\\
\ & remote.c & \ & \cxreffile{remote.c}\\
\ & sentinel-frame.c & \ & \cxreffile{sentinel-frame.c}\\
\ & solib.c & \ & \cxreffile{solib.c}\\
\cxreftabbreak{cxreftabiii}
\ & stack.c & \ & \cxreffile{stack.c}\\
\ & symfile.c & \ & \cxreffile{symfile.c}\\
\ & symmisc.c & \ & \cxreffile{symmisc.c}\\
\ & symtab.c & \ & \cxreffile{symtab.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
\ & target/x86-shared-tdep.c & \ & \cxreffile{target/x86-shared-tdep.c}\\
\ & thread.c & \ & \cxreffile{thread.c}\\
\ & top.c & \ & \cxreffile{top.c}\\
\cxreftabbreak{cxreftabiii}
\ & tracepoint.c & \ & \cxreffile{tracepoint.c}\\
\ & utils.c & \ & \cxreffile{utils.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
Used in:\ & breakpoint\_init\_inferior() & breakpoint.c & \cxreffunc{breakpoint_init_inferior}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable symbol\_generation}
\label{var_symbol_generation_breakpoint.c}

{\stt int symbol\_generation}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & valops.c & \ & \cxreffile{valops.c}\\
\ & value.c & \ & \cxreffile{value.c}\\
Used in:\ & breakpoint\_re\_set() & breakpoint.c & \cxreffunc{breakpoint_re_set}{breakpoint.c}\\
\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
\ & lookup\_cached\_function() & value.c & \cxreffunc{lookup_cached_function}{value.c}\\
\end{cxreftabiii}


\subsubsection{Variable breakpoint\_generation}
\label{var_breakpoint_generation_breakpoint.c}

{\stt int breakpoint\_generation}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
\ & tell\_breakpoints\_objfile\_changed\_internal() & breakpoint.c & \cxreffunc{tell_breakpoints_objfile_changed_internal}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable show\_breakpoint\_hit\_counts}
\label{var_show_breakpoint_hit_counts_breakpoint.c}

{\stt int show\_breakpoint\_hit\_counts}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\ & target/target.c & \ & \cxreffile{target/target.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\ & generic\_mourn\_inferior() & target/target.c & \cxreffunc{generic_mourn_inferior}{target/target.c}\\
\ & print\_one\_breakpoint() & breakpoint.c & \cxreffunc{print_one_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable breakpoint\_chain}
\label{var_breakpoint_chain_breakpoint.c}

{\stt struct breakpoint* breakpoint\_chain}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\ & bpstat\_should\_step() & breakpoint.c & \cxreffunc{bpstat_should_step}{breakpoint.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & breakpoint\_1() & breakpoint.c & \cxreffunc{breakpoint_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_auto\_delete() & breakpoint.c & \cxreffunc{breakpoint_auto_delete}{breakpoint.c}\\
\ & breakpoint\_clear\_ignore\_counts() & breakpoint.c & \cxreffunc{breakpoint_clear_ignore_counts}{breakpoint.c}\\
\ & breakpoint\_init\_inferior() & breakpoint.c & \cxreffunc{breakpoint_init_inferior}{breakpoint.c}\\
\ & breakpoint\_re\_set\_all() & breakpoint.c & \cxreffunc{breakpoint_re_set_all}{breakpoint.c}\\
\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
\ & breakpoints\_relocate() & breakpoint.c & \cxreffunc{breakpoints_relocate}{breakpoint.c}\\
\ & clear\_breakpoint\_hit\_counts() & breakpoint.c & \cxreffunc{clear_breakpoint_hit_counts}{breakpoint.c}\\
\ & clear\_command() & breakpoint.c & \cxreffunc{clear_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & commands\_command() & breakpoint.c & \cxreffunc{commands_command}{breakpoint.c}\\
\ & commands\_from\_control\_command() & breakpoint.c & \cxreffunc{commands_from_control_command}{breakpoint.c}\\
\ & condition\_command() & breakpoint.c & \cxreffunc{condition_command}{breakpoint.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & delete\_command() & breakpoint.c & \cxreffunc{delete_command}{breakpoint.c}\\
\ & describe\_other\_breakpoints() & breakpoint.c & \cxreffunc{describe_other_breakpoints}{breakpoint.c}\\
\ & disable\_breakpoints\_in\_shlibs() & breakpoint.c & \cxreffunc{disable_breakpoints_in_shlibs}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & disable\_breakpoints\_in\_unloaded\_shlib() & breakpoint.c & \cxreffunc{disable_breakpoints_in_unloaded_shlib}{breakpoint.c}\\
\ & disable\_command() & breakpoint.c & \cxreffunc{disable_command}{breakpoint.c}\\
\ & disable\_exception\_catch() & breakpoint.c & \cxreffunc{disable_exception_catch}{breakpoint.c}\\
\ & disable\_longjmp\_breakpoint() & breakpoint.c & \cxreffunc{disable_longjmp_breakpoint}{breakpoint.c}\\
\ & disable\_overlay\_breakpoints() & breakpoint.c & \cxreffunc{disable_overlay_breakpoints}{breakpoint.c}\\
\ & disable\_user\_breakpoints\_before\_operation() & breakpoint.c & \cxreffunc{disable_user_breakpoints_before_operation}{breakpoint.c}\\
\ & disable\_watchpoints\_before\_interactive\_call\_start() & breakpoint.c & \cxreffunc{disable_watchpoints_before_interactive_call_start}{breakpoint.c}\\
\ & do\_captured\_breakpoint\_query() & breakpoint.c & \cxreffunc{do_captured_breakpoint_query}{breakpoint.c}\\
\ & enable\_command() & breakpoint.c & \cxreffunc{enable_command}{breakpoint.c}\\
\ & enable\_longjmp\_breakpoint() & breakpoint.c & \cxreffunc{enable_longjmp_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & enable\_overlay\_breakpoints() & breakpoint.c & \cxreffunc{enable_overlay_breakpoints}{breakpoint.c}\\
\ & enable\_user\_breakpoints\_after\_operation() & breakpoint.c & \cxreffunc{enable_user_breakpoints_after_operation}{breakpoint.c}\\
\ & enable\_watchpoints\_after\_interactive\_call\_stop() & breakpoint.c & \cxreffunc{enable_watchpoints_after_interactive_call_stop}{breakpoint.c}\\
\ & find\_breakpoint() & breakpoint.c & \cxreffunc{find_breakpoint}{breakpoint.c}\\
\ & find\_finish\_breakpoint() & breakpoint.c & \cxreffunc{find_finish_breakpoint}{breakpoint.c}\\
\ & gnu\_v3\_update\_exception\_catchpoints() & breakpoint.c & \cxreffunc{gnu_v3_update_exception_catchpoints}{breakpoint.c}\\
\ & hw\_breakpoint\_used\_count() & breakpoint.c & \cxreffunc{hw_breakpoint_used_count}{breakpoint.c}\\
\ & hw\_watchpoint\_used\_count() & breakpoint.c & \cxreffunc{hw_watchpoint_used_count}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & map\_breakpoint\_numbers() & breakpoint.c & \cxreffunc{map_breakpoint_numbers}{breakpoint.c}\\
\ & re\_enable\_breakpoints\_in\_shlibs() & breakpoint.c & \cxreffunc{re_enable_breakpoints_in_shlibs}{breakpoint.c}\\
\ & remove\_solib\_event\_breakpoints() & breakpoint.c & \cxreffunc{remove_solib_event_breakpoints}{breakpoint.c}\\
\ & remove\_thread\_event\_breakpoints() & breakpoint.c & \cxreffunc{remove_thread_event_breakpoints}{breakpoint.c}\\
\ & save\_breakpoints\_command() & breakpoint.c & \cxreffunc{save_breakpoints_command}{breakpoint.c}\\
\ & set\_ignore\_count() & breakpoint.c & \cxreffunc{set_ignore_count}{breakpoint.c}\\
\ & set\_longjmp\_resume\_breakpoint() & breakpoint.c & \cxreffunc{set_longjmp_resume_breakpoint}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & tell\_breakpoints\_objfile\_changed\_internal() & breakpoint.c & \cxreffunc{tell_breakpoints_objfile_changed_internal}{breakpoint.c}\\
\ & update\_breakpoints\_after\_exec() & breakpoint.c & \cxreffunc{update_breakpoints_after_exec}{breakpoint.c}\\
\ & update\_exception\_catchpoints() & breakpoint.c & \cxreffunc{update_exception_catchpoints}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable bp\_location\_chain}
\label{var_bp_location_chain_breakpoint.c}

{\stt struct bp\_location* bp\_location\_chain}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & allocate\_bp\_location() & breakpoint.c & \cxreffunc{allocate_bp_location}{breakpoint.c}\\
\ & bpstat\_have\_active\_hw\_watchpoints() & breakpoint.c & \cxreffunc{bpstat_have_active_hw_watchpoints}{breakpoint.c}\\
\ & breakpoint\_here\_p() & breakpoint.c & \cxreffunc{breakpoint_here_p}{breakpoint.c}\\
\ & breakpoint\_init\_inferior() & breakpoint.c & \cxreffunc{breakpoint_init_inferior}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_inserted\_here\_p() & breakpoint.c & \cxreffunc{breakpoint_inserted_here_p}{breakpoint.c}\\
\ & breakpoint\_thread\_match() & breakpoint.c & \cxreffunc{breakpoint_thread_match}{breakpoint.c}\\
\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & deprecated\_read\_memory\_nobpt() & breakpoint.c & \cxreffunc{deprecated_read_memory_nobpt}{breakpoint.c}\\
\ & detach\_breakpoints() & breakpoint.c & \cxreffunc{detach_breakpoints}{breakpoint.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & mark\_breakpoints\_out() & breakpoint.c & \cxreffunc{mark_breakpoints_out}{breakpoint.c}\\
\ & reattach\_breakpoints() & breakpoint.c & \cxreffunc{reattach_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & remove\_breakpoints() & breakpoint.c & \cxreffunc{remove_breakpoints}{breakpoint.c}\\
\ & remove\_hw\_watchpoints() & breakpoint.c & \cxreffunc{remove_hw_watchpoints}{breakpoint.c}\\
\ & software\_breakpoint\_inserted\_here\_p() & breakpoint.c & \cxreffunc{software_breakpoint_inserted_here_p}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable breakpoint\_count}
\label{var_breakpoint_count_breakpoint.c}

{\stt int breakpoint\_count}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & create\_exception\_catchpoint() & breakpoint.c & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_exec\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_exec_event_catchpoint}{breakpoint.c}\\
\ & create\_fork\_vfork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_fork_vfork_event_catchpoint}{breakpoint.c}\\
\ & get\_number\_trailer() & breakpoint.c & \cxreffunc{get_number_trailer}{breakpoint.c}\\
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_breakpoint\_sal() & breakpoint.c & \cxreffunc{set_breakpoint_sal}{breakpoint.c}\\
\ & solib\_load\_unload\_1() & breakpoint.c & \cxreffunc{solib_load_unload_1}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable default\_breakpoint\_valid}
\label{var_default_breakpoint_valid_breakpoint.c}

{\stt int default\_breakpoint\_valid}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & decode\_line\_spec\_1() & breakpoint.c & \cxreffunc{decode_line_spec_1}{breakpoint.c}\\
\ & parse\_breakpoint\_sals() & breakpoint.c & \cxreffunc{parse_breakpoint_sals}{breakpoint.c}\\
\ & set\_default\_breakpoint() & breakpoint.c & \cxreffunc{set_default_breakpoint}{breakpoint.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable default\_breakpoint\_address}
\label{var_default_breakpoint_address_breakpoint.c}

{\stt CORE\_ADDR default\_breakpoint\_address}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & clear\_command() & breakpoint.c & \cxreffunc{clear_command}{breakpoint.c}\\
\ & parse\_breakpoint\_sals() & breakpoint.c & \cxreffunc{parse_breakpoint_sals}{breakpoint.c}\\
\ & set\_default\_breakpoint() & breakpoint.c & \cxreffunc{set_default_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable default\_breakpoint\_symtab}
\label{var_default_breakpoint_symtab_breakpoint.c}

{\stt struct symtab* default\_breakpoint\_symtab}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & clear\_command() & breakpoint.c & \cxreffunc{clear_command}{breakpoint.c}\\
\ & decode\_line\_spec\_1() & breakpoint.c & \cxreffunc{decode_line_spec_1}{breakpoint.c}\\
\ & parse\_breakpoint\_sals() & breakpoint.c & \cxreffunc{parse_breakpoint_sals}{breakpoint.c}\\
\ & set\_default\_breakpoint() & breakpoint.c & \cxreffunc{set_default_breakpoint}{breakpoint.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Variable default\_breakpoint\_line}
\label{var_default_breakpoint_line_breakpoint.c}

{\stt int default\_breakpoint\_line}

\smallskip
\begin{cxreftabiii}
Visible in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & clear\_command() & breakpoint.c & \cxreffunc{clear_command}{breakpoint.c}\\
\ & decode\_line\_spec\_1() & breakpoint.c & \cxreffunc{decode_line_spec_1}{breakpoint.c}\\
\ & parse\_breakpoint\_sals() & breakpoint.c & \cxreffunc{parse_breakpoint_sals}{breakpoint.c}\\
\ & set\_default\_breakpoint() & breakpoint.c & \cxreffunc{set_default_breakpoint}{breakpoint.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{External Variables}

{\bf addressprint}
\label{var_addressprint_breakpoint.c}

{\stt extern int addressprint}

\smallskip
\begin{cxreftabiii}
Defined in:& valprint.c & \ & \cxrefvar{addressprint}{valprint.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf exception\_throw\_type\_regexp}
\label{var_exception_throw_type_regexp_breakpoint.c}

{\stt static char* exception\_throw\_type\_regexp}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & \ & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\ & current\_exception\_should\_stop() & \ & \cxreffunc{current_exception_should_stop}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf exception\_catch\_type\_regexp}
\label{var_exception_catch_type_regexp_breakpoint.c}

{\stt static char* exception\_catch\_type\_regexp}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & \ & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\ & current\_exception\_should\_stop() & \ & \cxreffunc{current_exception_should_stop}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf exception\_catchpoint\_catch\_enabled}
\label{var_exception_catchpoint_catch_enabled_breakpoint.c}

{\stt static int exception\_catchpoint\_catch\_enabled}

\smallskip
\begin{cxreftabiii}
Used in:\ & catch\_command\_1() & \ & \cxreffunc{catch_command_1}{breakpoint.c}\\
\ & disable\_exception\_catch() & \ & \cxreffunc{disable_exception_catch}{breakpoint.c}\\
\ & exception\_catchpoints\_enabled() & \ & \cxreffunc{exception_catchpoints_enabled}{breakpoint.c}\\
\ & gnu\_v3\_update\_exception\_catchpoints() & \ & \cxreffunc{gnu_v3_update_exception_catchpoints}{breakpoint.c}\\
\ & handle\_gnu\_v3\_exceptions() & \ & \cxreffunc{handle_gnu_v3_exceptions}{breakpoint.c}\\
\ & update\_exception\_catchpoints() & \ & \cxreffunc{update_exception_catchpoints}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf exception\_catchpoint\_throw\_enabled}
\label{var_exception_catchpoint_throw_enabled_breakpoint.c}

{\stt static int exception\_catchpoint\_throw\_enabled}

\smallskip
\begin{cxreftabiii}
Used in:\ & catch\_command\_1() & \ & \cxreffunc{catch_command_1}{breakpoint.c}\\
\ & disable\_exception\_catch() & \ & \cxreffunc{disable_exception_catch}{breakpoint.c}\\
\ & exception\_catchpoints\_enabled() & \ & \cxreffunc{exception_catchpoints_enabled}{breakpoint.c}\\
\ & gnu\_v3\_update\_exception\_catchpoints() & \ & \cxreffunc{gnu_v3_update_exception_catchpoints}{breakpoint.c}\\
\ & handle\_gnu\_v3\_exceptions() & \ & \cxreffunc{handle_gnu_v3_exceptions}{breakpoint.c}\\
\ & update\_exception\_catchpoints() & \ & \cxreffunc{update_exception_catchpoints}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf dont\_mention}
\label{var_dont_mention_breakpoint.c}

{\stt static int dont\_mention}

\smallskip
\begin{cxreftabiii}
Used in:\ & mention() & \ & \cxreffunc{mention}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf can\_use\_hw\_watchpoints}
\label{var_can_use_hw_watchpoints_breakpoint.c}

{\stt static int can\_use\_hw\_watchpoints}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & \ & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\ & can\_use\_hardware\_watchpoint() & \ & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf pending\_break\_support}
\label{var_pending_break_support_breakpoint.c}

{\stt static enum auto\_boolean pending\_break\_support}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & \ & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\ & break\_command\_2() & \ & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & future\_break\_command() & \ & \cxreffunc{future_break_command}{breakpoint.c}\\
\ & gdb\_breakpoint() & \ & \cxreffunc{gdb_breakpoint}{breakpoint.c}\\
\ & parse\_breakpoint\_sals() & \ & \cxreffunc{parse_breakpoint_sals}{breakpoint.c}\\
\ & rbr\_break\_command() & \ & \cxreffunc{rbr_break_command}{breakpoint.c}\\
\ & restore\_saved\_pending\_break\_support() & \ & \cxreffunc{restore_saved_pending_break_support}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf executing\_breakpoint\_commands}
\label{var_executing_breakpoint_commands_breakpoint.c}

{\stt static int executing\_breakpoint\_commands}

\smallskip
\begin{cxreftabiii}
Used in:\ & bpstat\_do\_actions() & \ & \cxreffunc{bpstat_do_actions}{breakpoint.c}\\
\ & cleanup\_executing\_breakpoints() & \ & \cxreffunc{cleanup_executing_breakpoints}{breakpoint.c}\\
\ & commands\_command() & \ & \cxreffunc{commands_command}{breakpoint.c}\\
\ & commands\_from\_control\_command() & \ & \cxreffunc{commands_from_control_command}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf overlay\_events\_enabled}
\label{var_overlay_events_enabled_breakpoint.c}

{\stt static int overlay\_events\_enabled}

\smallskip
\begin{cxreftabiii}
Used in:\ & create\_overlay\_event\_breakpoint() & \ & \cxreffunc{create_overlay_event_breakpoint}{breakpoint.c}\\
\ & disable\_overlay\_breakpoints() & \ & \cxreffunc{disable_overlay_breakpoints}{breakpoint.c}\\
\ & enable\_overlay\_breakpoints() & \ & \cxreffunc{enable_overlay_breakpoints}{breakpoint.c}\\
\ & insert\_bp\_location() & \ & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & remove\_breakpoint() & \ & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf current\_exception\_event}
\label{var_current_exception_event_breakpoint.c}

{\stt static struct exception\_event\_record* current\_exception\_event}

\smallskip
\begin{cxreftabiii}
Used in:\ & bpstat\_stop\_status() & \ & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & bpstat\_what\_to\_do() & \ & \cxreffunc{bpstat_what_to_do}{breakpoint.c}\\
\ & current\_exception\_should\_stop() & \ & \cxreffunc{current_exception_should_stop}{breakpoint.c}\\
\ & print\_catch\_info() & \ & \cxreffunc{print_catch_info}{breakpoint.c}\\
\ & print\_exception\_catchpoint() & \ & \cxreffunc{print_exception_catchpoint}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf gnu\_v3\_catch\_symbol}
\label{var_gnu_v3_catch_symbol_breakpoint.c}

{\stt static const char* gnu\_v3\_catch\_symbol}

\smallskip
\begin{cxreftabiii}
Used in:\ & create\_exception\_catchpoint() & \ & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\ & gnu\_v3\_update\_exception\_catchpoints() & \ & \cxreffunc{gnu_v3_update_exception_catchpoints}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf gnu\_v3\_throw\_symbol}
\label{var_gnu_v3_throw_symbol_breakpoint.c}

{\stt static const char* gnu\_v3\_throw\_symbol}

\smallskip
\begin{cxreftabiii}
Used in:\ & create\_exception\_catchpoint() & \ & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\ & gnu\_v3\_update\_exception\_catchpoints() & \ & \cxreffunc{gnu_v3_update_exception_catchpoints}{breakpoint.c}\\
\end{cxreftabiii}

\medskip
{\bf gnu\_v3\_exception\_catchpoint\_ops}
\label{var_gnu_v3_exception_catchpoint_ops_breakpoint.c}

{\stt static struct breakpoint\_ops gnu\_v3\_exception\_catchpoint\_ops}

\smallskip
\begin{cxreftabiii}
Used in:\ & create\_exception\_catchpoint() & \ & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_breakpoint()}
\label{func__initialize_breakpoint_breakpoint.c}

{\stt void \_initialize\_breakpoint ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & observer\_attach\_solib\_unloaded() & observer.c & \cxreffunc{observer_attach_solib_unloaded}{observer.c}\\
\ & \cxreftabiiispan{ add\_abbrev\_prefix\_cmd(), add\_cmd(), add\_com(), add\_com\_alias(), add\_info(), add\_prefix\_cmd(), add\_setshow\_auto\_boolean\_cmd(), add\_setshow\_string\_cmd(), add\_setshow\_zinteger\_cmd(), set\_cmd\_completer()} &\\
Refs Func:\ & awatch\_command() & breakpoint.c & \cxreffunc{awatch_command}{breakpoint.c}\\
\ & break\_command() & breakpoint.c & \cxreffunc{break_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoints\_info() & breakpoint.c & \cxreffunc{breakpoints_info}{breakpoint.c}\\
\ & catch\_command() & breakpoint.c & \cxreffunc{catch_command}{breakpoint.c}\\
\ & clear\_command() & breakpoint.c & \cxreffunc{clear_command}{breakpoint.c}\\
\ & commands\_command() & breakpoint.c & \cxreffunc{commands_command}{breakpoint.c}\\
\ & condition\_command() & breakpoint.c & \cxreffunc{condition_command}{breakpoint.c}\\
\ & delete\_command() & breakpoint.c & \cxreffunc{delete_command}{breakpoint.c}\\
\ & disable\_breakpoints\_in\_unloaded\_shlib() & breakpoint.c & \cxreffunc{disable_breakpoints_in_unloaded_shlib}{breakpoint.c}\\
\ & disable\_command() & breakpoint.c & \cxreffunc{disable_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & enable\_command() & breakpoint.c & \cxreffunc{enable_command}{breakpoint.c}\\
\ & enable\_delete\_command() & breakpoint.c & \cxreffunc{enable_delete_command}{breakpoint.c}\\
\ & enable\_once\_command() & breakpoint.c & \cxreffunc{enable_once_command}{breakpoint.c}\\
\ & filename\_completer() & completer.c & \cxreffunc{filename_completer}{completer.c}\\
\ & future\_break\_command() & breakpoint.c & \cxreffunc{future_break_command}{breakpoint.c}\\
\ & hbreak\_command() & breakpoint.c & \cxreffunc{hbreak_command}{breakpoint.c}\\
\ & ignore\_command() & breakpoint.c & \cxreffunc{ignore_command}{breakpoint.c}\\
\ & location\_completer() & completer.c & \cxreffunc{location_completer}{completer.c}\\
\cxreftabbreak{cxreftabiii}
\ & maintenance\_info\_breakpoints() & breakpoint.c & \cxreffunc{maintenance_info_breakpoints}{breakpoint.c}\\
\ & rwatch\_command() & breakpoint.c & \cxreffunc{rwatch_command}{breakpoint.c}\\
\ & save\_breakpoints\_command() & breakpoint.c & \cxreffunc{save_breakpoints_command}{breakpoint.c}\\
\ & set\_breakpoint\_cmd() & breakpoint.c & \cxreffunc{set_breakpoint_cmd}{breakpoint.c}\\
\ & show\_breakpoint\_cmd() & breakpoint.c & \cxreffunc{show_breakpoint_cmd}{breakpoint.c}\\
\ & show\_can\_use\_hw\_watchpoints() & breakpoint.c & \cxreffunc{show_can_use_hw_watchpoints}{breakpoint.c}\\
\ & show\_pending\_break\_support() & breakpoint.c & \cxreffunc{show_pending_break_support}{breakpoint.c}\\
\ & stop\_command() & breakpoint.c & \cxreffunc{stop_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & stopat\_command() & breakpoint.c & \cxreffunc{stopat_command}{breakpoint.c}\\
\ & stopin\_command() & breakpoint.c & \cxreffunc{stopin_command}{breakpoint.c}\\
\ & tbreak\_command() & breakpoint.c & \cxreffunc{tbreak_command}{breakpoint.c}\\
\ & tcatch\_command() & breakpoint.c & \cxreffunc{tcatch_command}{breakpoint.c}\\
\ & thbreak\_command() & breakpoint.c & \cxreffunc{thbreak_command}{breakpoint.c}\\
\ & watch\_command() & breakpoint.c & \cxreffunc{watch_command}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & can\_use\_hw\_watchpoints & breakpoint.c & \cxrefvar{can_use_hw_watchpoints}{breakpoint.c}\\
\ & dbx\_commands & main.c & \cxrefvar{dbx_commands}{main.c}\\
\ & exception\_catch\_type\_regexp & breakpoint.c & \cxrefvar{exception_catch_type_regexp}{breakpoint.c}\\
\ & exception\_throw\_type\_regexp & breakpoint.c & \cxrefvar{exception_throw_type_regexp}{breakpoint.c}\\
\ & pending\_break\_support & breakpoint.c & \cxrefvar{pending_break_support}{breakpoint.c}\\
\ & show\_breakpoint\_hit\_counts & breakpoint.c & \cxrefvar{show_breakpoint_hit_counts}{breakpoint.c}\\
\ & xdb\_commands & main.c & \cxrefvar{xdb_commands}{main.c}\\
\ & \cxreftabiiispan{ cmdlist, deletelist, disablelist, enablebreaklist, enablelist, maintenanceinfolist, setlist, showlist, stoplist} &\\
\end{cxreftabiii}


\subsubsection{Global Function awatch\_command\_wrapper()}
\label{func_awatch_command_wrapper_breakpoint.c}

{\stt void awatch\_command\_wrapper ( const char* arg, int by\_location, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_clear()}
\label{func_bpstat_clear_breakpoint.c}

{\stt void bpstat\_clear ( bpstat* bsp )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ free\_command\_lines()} &\\
Called by:\ & bpstat\_get\_triggered\_catchpoints() & breakpoint.c & \cxreffunc{bpstat_get_triggered_catchpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & clear\_proceed\_status() & infrun.c & \cxreffunc{clear_proceed_status}{infrun.c}\\
\ & discard\_inferior\_status() & infrun.c & \cxreffunc{discard_inferior_status}{infrun.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & restore\_inferior\_status() & infrun.c & \cxreffunc{restore_inferior_status}{infrun.c}\\
Used in:\ & bpstat\_do\_actions() & breakpoint.c & \cxreffunc{bpstat_do_actions}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_clear\_actions()}
\label{func_bpstat_clear_actions_breakpoint.c}

{\stt void bpstat\_clear\_actions ( bpstat bs )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & \cxreftabiiispan{ free\_command\_lines()} &\\
Called by:\ & bpstat\_do\_actions() & breakpoint.c & \cxreffunc{bpstat_do_actions}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_copy()}
\label{func_bpstat_copy_breakpoint.c}

{\stt bpstat bpstat\_copy ( bpstat bs )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), copy\_command\_lines()} &\\
Called by:\ & bpstat\_do\_actions() & breakpoint.c & \cxreffunc{bpstat_do_actions}{breakpoint.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & save\_inferior\_status() & infrun.c & \cxreffunc{save_inferior_status}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_do\_actions()}
\label{func_bpstat_do_actions_breakpoint.c}

{\stt void bpstat\_do\_actions ( bpstat* bsp )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & add\_continuation() & utils.c & \cxreffunc{add_continuation}{utils.c}\\
\ & bpstat\_clear\_actions() & breakpoint.c & \cxreffunc{bpstat_clear_actions}{breakpoint.c}\\
\ & bpstat\_copy() & breakpoint.c & \cxreffunc{bpstat_copy}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_ui\_out\_notify\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_notify_begin_end}{ui-out.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\ & \cxreftabiiispan{ execute\_control\_command()} &\\
Called by:\ & async\_breakpoint\_command\_continuation() & breakpoint.c & \cxreffunc{async_breakpoint_command_continuation}{breakpoint.c}\\
\ & command\_handler() & event-top.c & \cxreffunc{command_handler}{event-top.c}\\
\ & command\_line\_handler\_continuation() & event-top.c & \cxreffunc{command_line_handler_continuation}{event-top.c}\\
\ & command\_loop() & top.c & \cxreffunc{command_loop}{top.c}\\
\cxreftabbreak{cxreftabiii}
\ & simplified\_command\_loop() & top.c & \cxreffunc{simplified_command_loop}{top.c}\\
Refs Func:\ & async\_breakpoint\_command\_continuation() & breakpoint.c & \cxreffunc{async_breakpoint_command_continuation}{breakpoint.c}\\
\ & bpstat\_clear() & breakpoint.c & \cxreffunc{bpstat_clear}{breakpoint.c}\\
\ & cleanup\_executing\_breakpoints() & breakpoint.c & \cxreffunc{cleanup_executing_breakpoints}{breakpoint.c}\\
Refs Var:\ & breakpoint\_proceeded & infcmd.c & \cxrefvar{breakpoint_proceeded}{infcmd.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & executing\_breakpoint\_commands & breakpoint.c & \cxrefvar{executing_breakpoint_commands}{breakpoint.c}\\
\ & gdb\_override\_async & target/target.c & \cxrefvar{gdb_override_async}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & target\_executing & top.c & \cxrefvar{target_executing}{top.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_find\_breakpoint()}
\label{func_bpstat_find_breakpoint_breakpoint.c}

{\stt bpstat bpstat\_find\_breakpoint ( bpstat bsp, struct breakpoint* breakpoint )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & finish\_command() & infcmd.c & \cxreffunc{finish_command}{infcmd.c}\\
\ & finish\_command\_continuation() & infcmd.c & \cxreffunc{finish_command_continuation}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_find\_step\_resume\_breakpoint()}
\label{func_bpstat_find_step_resume_breakpoint_breakpoint.c}

{\stt struct breakpoint* bpstat\_find\_step\_resume\_breakpoint ( bpstat bsp )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_get\_triggered\_catchpoints()}
\label{func_bpstat_get_triggered_catchpoints_breakpoint.c}

{\stt bpstat* bpstat\_get\_triggered\_catchpoints ( bpstat ep\_list, bpstat* cp\_list )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & bpstat\_alloc() & breakpoint.c & \cxreffunc{bpstat_alloc}{breakpoint.c}\\
\ & bpstat\_clear() & breakpoint.c & \cxreffunc{bpstat_clear}{breakpoint.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), strlen()} &\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_have\_active\_hw\_watchpoints()}
\label{func_bpstat_have_active_hw_watchpoints_breakpoint.c}

{\stt int bpstat\_have\_active\_hw\_watchpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_num()}
\label{func_bpstat_num_breakpoint.c}

{\stt int bpstat\_num ( bpstat* bsp )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & continue\_command() & infcmd.c & \cxreffunc{continue_command}{infcmd.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\ & program\_info() & infcmd.c & \cxreffunc{program_info}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_print()}
\label{func_bpstat_print_breakpoint.c}

{\stt enum print\_stop\_action bpstat\_print ( bpstat bs )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & print\_bp\_stop\_message() & breakpoint.c & \cxreffunc{print_bp_stop_message}{breakpoint.c}\\
Called by:\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_should\_step()}
\label{func_bpstat_should_step_breakpoint.c}

{\stt int bpstat\_should\_step ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
Called by:\ & currently\_stepping() & infrun.c & \cxreffunc{currently_stepping}{infrun.c}\\
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_stop\_status()}
\label{func_bpstat_stop_status_breakpoint.c}

{\stt bpstat bpstat\_stop\_status ( CORE\_ADDR bp\_addr, ptid\_t ptid, int stopped\_by\_watchpoint )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & at\_inlined\_call\_site\_p() & inlining.c & \cxreffunc{at_inlined_call_site_p}{inlining.c}\\
\ & bpstat\_alloc() & breakpoint.c & \cxreffunc{bpstat_alloc}{breakpoint.c}\\
\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & current\_exception\_should\_stop() & breakpoint.c & \cxreffunc{current_exception_should_stop}{breakpoint.c}\\
\ & current\_inlined\_subroutine\_call\_site\_line() & inlining.c & \cxreffunc{current_inlined_subroutine_call_site_line}{inlining.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & do\_hand\_call\_cleanups() & utils.c & \cxreffunc{do_hand_call_cleanups}{utils.c}\\
\ & ep\_is\_exception\_catchpoint() & breakpoint.c & \cxreffunc{ep_is_exception_catchpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & frame\_id\_eq() & frame.c & \cxreffunc{frame_id_eq}{frame.c}\\
\ & frame\_id\_p() & frame.c & \cxreffunc{frame_id_p}{frame.c}\\
\ & free\_all\_values() & value.c & \cxreffunc{free_all_values}{value.c}\\
\ & gdb\_parse\_exp\_1() & wrapper.c & \cxreffunc{gdb_parse_exp_1}{wrapper.c}\\
\ & gdbarch\_addr\_bits\_remove() & gdbarch.c & \cxreffunc{gdbarch_addr_bits_remove}{gdbarch.c}\\
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_frame\_type() & frame.c & \cxreffunc{get_frame_type}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_selected\_block() & stack.c & \cxreffunc{get_selected_block}{stack.c}\\
\ & inferior\_has\_execd() & infrun.c & \cxreffunc{inferior_has_execd}{infrun.c}\\
\ & inferior\_has\_forked() & infrun.c & \cxreffunc{inferior_has_forked}{infrun.c}\\
\ & inferior\_has\_vforked() & infrun.c & \cxreffunc{inferior_has_vforked}{infrun.c}\\
\ & inlined\_subroutine\_adjust\_position\_for\_breakpoint() & inlining.c & \cxreffunc{inlined_subroutine_adjust_position_for_breakpoint}{inlining.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & remove\_breakpoints() & breakpoint.c & \cxreffunc{remove_breakpoints}{breakpoint.c}\\
\ & section\_is\_mapped() & symfile.c & \cxreffunc{section_is_mapped}{symfile.c}\\
\ & section\_is\_overlay() & symfile.c & \cxreffunc{section_is_overlay}{symfile.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_next() & value.c & \cxreffunc{value_next}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ annotate\_ignore\_count\_change(), atoi(), catch\_errors(), copy\_command\_lines(), isdigit(), strcmp(), strrchr()} &\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Refs Func:\ & breakpoint\_cond\_eval() & breakpoint.c & \cxreffunc{breakpoint_cond_eval}{breakpoint.c}\\
\ & watchpoint\_check() & breakpoint.c & \cxreffunc{watchpoint_check}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_exception\_event & breakpoint.c & \cxrefvar{current_exception_event}{breakpoint.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & global\_inlined\_call\_stack & inlining.c & \cxrefvar{global_inlined_call_stack}{inlining.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & step\_frame\_id & infcmd.c & \cxrefvar{step_frame_id}{infcmd.c}\\
\ & step\_range\_start & infcmd.c & \cxrefvar{step_range_start}{infcmd.c}\\
\ & xdb\_commands & main.c & \cxrefvar{xdb_commands}{main.c}\\
\end{cxreftabiii}


\subsubsection{Global Function bpstat\_what\_to\_do()}
\label{func_bpstat_what_to_do_breakpoint.c}

{\stt struct bpstat\_what bpstat\_what\_to\_do ( bpstat bs )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Refs Var:\ & current\_exception\_event & breakpoint.c & \cxrefvar{current_exception_event}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function break\_command()}
\label{func_break_command_breakpoint.c}

{\stt void break\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_add\_commands()}
\label{func_breakpoint_add_commands_breakpoint.c}

{\stt void breakpoint\_add\_commands ( struct breakpoint* b, struct command\_line* commands )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & \cxreftabiiispan{ breakpoint\_modify\_event(), breakpoints\_changed(), free\_command\_lines()} &\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_auto\_delete()}
\label{func_breakpoint_auto_delete_breakpoint.c}

{\stt void breakpoint\_auto\_delete ( bpstat bs )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
Called by:\ & breakpoint\_auto\_delete\_contents() & infcall.c & \cxreffunc{breakpoint_auto_delete_contents}{infcall.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_clear\_ignore\_counts()}
\label{func_breakpoint_clear_ignore_counts_breakpoint.c}

{\stt void breakpoint\_clear\_ignore\_counts ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & generic\_mourn\_inferior() & target/target.c & \cxreffunc{generic_mourn_inferior}{target/target.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_here\_p()}
\label{func_breakpoint_here_p_breakpoint.c}

{\stt enum breakpoint\_here breakpoint\_here\_p ( CORE\_ADDR pc )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & section\_is\_mapped() & symfile.c & \cxreffunc{section_is_mapped}{symfile.c}\\
\ & section\_is\_overlay() & symfile.c & \cxreffunc{section_is_overlay}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & default\_memory\_remove\_breakpoint() & mem-break.c & \cxreffunc{default_memory_remove_breakpoint}{mem-break.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & prepare\_to\_proceed() & infrun.c & \cxreffunc{prepare_to_proceed}{infrun.c}\\
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_init\_inferior()}
\label{func_breakpoint_init_inferior_breakpoint.c}

{\stt void breakpoint\_init\_inferior ( enum inf\_context context )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & ep\_is\_exception\_catchpoint() & breakpoint.c & \cxreffunc{ep_is_exception_catchpoint}{breakpoint.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & generic\_mourn\_inferior() & target/target.c & \cxreffunc{generic_mourn_inferior}{target/target.c}\\
\ & init\_wait\_for\_inferior() & infrun.c & \cxreffunc{init_wait_for_inferior}{infrun.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & deprecated\_exception\_catchpoints\_are\_fragile & breakpoint.c & \cxrefvar{deprecated_exception_catchpoints_are_fragile}{breakpoint.c}\\
\ & deprecated\_exception\_support\_initialized & breakpoint.c & \cxrefvar{deprecated_exception_support_initialized}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_inserted\_here\_p()}
\label{func_breakpoint_inserted_here_p_breakpoint.c}

{\stt int breakpoint\_inserted\_here\_p ( CORE\_ADDR pc )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & section\_is\_mapped() & symfile.c & \cxreffunc{section_is_mapped}{symfile.c}\\
\ & section\_is\_overlay() & symfile.c & \cxreffunc{section_is_overlay}{symfile.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_print\_commands()}
\label{func_breakpoint_print_commands_breakpoint.c}

{\stt void breakpoint\_print\_commands ( struct ui\_out* uiout, struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup\_ui\_out\_list\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_list_begin_end}{ui-out.c}\\
\ & \cxreftabiiispan{ print\_command\_lines()} &\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_re\_set()}
\label{func_breakpoint_re_set_breakpoint.c}

{\stt void breakpoint\_re\_set ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & objfile\_add\_to\_restrict\_list() & objfiles.c & \cxreffunc{objfile_add_to_restrict_list}{objfiles.c}\\
Called by:\ & follow\_inferior\_reset\_breakpoints() & infrun.c & \cxreffunc{follow_inferior_reset_breakpoints}{infrun.c}\\
\ & new\_symfile\_objfile() & symfile.c & \cxreffunc{new_symfile_objfile}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & objfile\_relocate() & objfiles.c & \cxreffunc{objfile_relocate}{objfiles.c}\\
\ & reread\_symbols\_for\_objfile() & symfile.c & \cxreffunc{reread_symbols_for_objfile}{symfile.c}\\
Refs Var:\ & symbol\_generation & breakpoint.c & \cxrefvar{symbol_generation}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_re\_set\_thread()}
\label{func_breakpoint_re_set_thread_breakpoint.c}

{\stt void breakpoint\_re\_set\_thread ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
Called by:\ & follow\_inferior\_reset\_breakpoints() & infrun.c & \cxreffunc{follow_inferior_reset_breakpoints}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_thread\_match()}
\label{func_breakpoint_thread_match_breakpoint.c}

{\stt int breakpoint\_thread\_match ( CORE\_ADDR pc, ptid\_t ptid )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & section\_is\_mapped() & symfile.c & \cxreffunc{section_is_mapped}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & section\_is\_overlay() & symfile.c & \cxreffunc{section_is_overlay}{symfile.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoint\_update()}
\label{func_breakpoint_update_breakpoint.c}

{\stt void breakpoint\_update ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_re\_set\_all() & breakpoint.c & \cxreffunc{breakpoint_re_set_all}{breakpoint.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & exception\_catchpoints\_enabled() & breakpoint.c & \cxreffunc{exception_catchpoints_enabled}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnu\_v3\_update\_exception\_catchpoints() & breakpoint.c & \cxreffunc{gnu_v3_update_exception_catchpoints}{breakpoint.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_restrict\_to\_objfile() & objfiles.c & \cxreffunc{make_cleanup_restrict_to_objfile}{objfiles.c}\\
\ & objfile\_restrict\_search() & objfiles.c & \cxreffunc{objfile_restrict_search}{objfiles.c}\\
\ & user\_settable\_breakpoint() & breakpoint.c & \cxreffunc{user_settable_breakpoint}{breakpoint.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ catch\_errors()} &\\
Called by:\ & add\_kext\_command() & symfile.c & \cxreffunc{add_kext_command}{symfile.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & restrict\_search\_cleanup() & breakpoint.c & \cxreffunc{restrict_search_cleanup}{breakpoint.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & breakpoint\_generation & breakpoint.c & \cxrefvar{breakpoint_generation}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & symbol\_generation & breakpoint.c & \cxrefvar{symbol_generation}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function breakpoints\_relocate()}
\label{func_breakpoints_relocate_breakpoint.c}

{\stt void breakpoints\_relocate ( struct objfile* objfile, struct section\_offsets* delta )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & executable\_objfile() & objfiles.c & \cxreffunc{executable_objfile}{objfiles.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & objfile\_relocate() & objfiles.c & \cxreffunc{objfile_relocate}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function clear\_breakpoint\_hit\_counts()}
\label{func_clear_breakpoint_hit_counts_breakpoint.c}

{\stt void clear\_breakpoint\_hit\_counts ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & run\_command\_1() & infcmd.c & \cxreffunc{run_command_1}{infcmd.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function commands\_from\_control\_command()}
\label{func_commands_from_control_command_breakpoint.c}

{\stt enum command\_control\_type commands\_from\_control\_command ( char* arg, struct command\_line* cmd )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_number() & breakpoint.c & \cxreffunc{get_number}{breakpoint.c}\\
\ & \cxreftabiiispan{ breakpoint\_modify\_event(), breakpoints\_changed(), copy\_command\_lines(), free\_command\_lines()} &\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & executing\_breakpoint\_commands & breakpoint.c & \cxrefvar{executing_breakpoint_commands}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function create\_exception\_catchpoint()}
\label{func_create_exception_catchpoint_breakpoint.c}

{\stt struct breakpoint* create\_exception\_catchpoint ( int tempflag, const char* cond\_string, int gnu\_v3\_p, enum exception\_event\_kind ex\_event, struct symtab\_and\_line* sal )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\ & \cxreftabiiispan{ strlen(), xstrdup()} &\\
Called by:\ & gnu\_v3\_update\_exception\_catchpoints() & breakpoint.c & \cxreffunc{gnu_v3_update_exception_catchpoints}{breakpoint.c}\\
\ & update\_exception\_catchpoints() & breakpoint.c & \cxreffunc{update_exception_catchpoints}{breakpoint.c}\\
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\ & gnu\_v3\_catch\_symbol & breakpoint.c & \cxrefvar{gnu_v3_catch_symbol}{breakpoint.c}\\
\ & gnu\_v3\_exception\_catchpoint\_ops & breakpoint.c & \cxrefvar{gnu_v3_exception_catchpoint_ops}{breakpoint.c}\\
\ & gnu\_v3\_throw\_symbol & breakpoint.c & \cxrefvar{gnu_v3_throw_symbol}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function create\_exec\_event\_catchpoint()}
\label{func_create_exec_event_catchpoint_breakpoint.c}

{\stt void create\_exec\_event\_catchpoint ( int tempflag, const char* cond\_string )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & catch\_exec\_command\_1() & breakpoint.c & \cxreffunc{catch_exec_command_1}{breakpoint.c}\\
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function create\_fork\_event\_catchpoint()}
\label{func_create_fork_event_catchpoint_breakpoint.c}

{\stt void create\_fork\_event\_catchpoint ( int tempflag, const char* cond\_string )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & create\_fork\_vfork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_fork_vfork_event_catchpoint}{breakpoint.c}\\
Called by:\ & catch\_fork\_command\_1() & breakpoint.c & \cxreffunc{catch_fork_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function create\_objc\_hook\_breakpoint()}
\label{func_create_objc_hook_breakpoint_breakpoint.c}

{\stt struct breakpoint* create\_objc\_hook\_breakpoint ( const char* hookname )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & create\_internal\_breakpoint() & breakpoint.c & \cxreffunc{create_internal_breakpoint}{breakpoint.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & init\_debugger\_mode\_fail\_notification() & objc-lang.c & \cxreffunc{init_debugger_mode_fail_notification}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup\_init\_objc\_exception\_catcher() & objc-lang.c & \cxreffunc{make_cleanup_init_objc_exception_catcher}{objc-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function create\_solib\_event\_breakpoint()}
\label{func_create_solib_event_breakpoint_breakpoint.c}

{\stt struct breakpoint* create\_solib\_event\_breakpoint ( CORE\_ADDR address )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & create\_internal\_breakpoint() & breakpoint.c & \cxreffunc{create_internal_breakpoint}{breakpoint.c}\\
Called by:\ & objc\_init\_trampoline\_observer() & objc-lang.c & \cxreffunc{objc_init_trampoline_observer}{objc-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function create\_solib\_load\_event\_breakpoint()}
\label{func_create_solib_load_event_breakpoint_breakpoint.c}

{\stt void create\_solib\_load\_event\_breakpoint ( char* hookname, int tempflag, char* dll\_pathname, char* cond\_string )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & solib\_load\_unload\_1() & breakpoint.c & \cxreffunc{solib_load_unload_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function create\_solib\_unload\_event\_breakpoint()}
\label{func_create_solib_unload_event_breakpoint_breakpoint.c}

{\stt void create\_solib\_unload\_event\_breakpoint ( char* hookname, int tempflag, char* dll\_pathname, char* cond\_string )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & solib\_load\_unload\_1() & breakpoint.c & \cxreffunc{solib_load_unload_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function create\_thread\_event\_breakpoint()}
\label{func_create_thread_event_breakpoint_breakpoint.c}

{\stt struct breakpoint* create\_thread\_event\_breakpoint ( CORE\_ADDR address )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & create\_internal\_breakpoint() & breakpoint.c & \cxreffunc{create_internal_breakpoint}{breakpoint.c}\\
\ & paddr() & utils.c & \cxreffunc{paddr}{utils.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function create\_vfork\_event\_catchpoint()}
\label{func_create_vfork_event_catchpoint_breakpoint.c}

{\stt void create\_vfork\_event\_catchpoint ( int tempflag, const char* cond\_string )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & create\_fork\_vfork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_fork_vfork_event_catchpoint}{breakpoint.c}\\
Called by:\ & catch\_fork\_command\_1() & breakpoint.c & \cxreffunc{catch_fork_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function decode\_line\_spec\_1()}
\label{func_decode_line_spec_1_breakpoint.c}

{\stt struct symtabs\_and\_lines decode\_line\_spec\_1 ( const char* string, int funfirstline )}

\smallskip
\begin{cxreftabiii}
Prototype:& symtab.h & \ & \cxreffile{symtab.h}\\
Calls:\ & decode\_line\_1() & linespec.c & \cxreffunc{decode_line_1}{linespec.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
Called by:\ & jump\_command() & infcmd.c & \cxreffunc{jump_command}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & line\_info() & source.c & \cxreffunc{line_info}{source.c}\\
Refs Var:\ & default\_breakpoint\_line & breakpoint.c & \cxrefvar{default_breakpoint_line}{breakpoint.c}\\
\ & default\_breakpoint\_symtab & breakpoint.c & \cxrefvar{default_breakpoint_symtab}{breakpoint.c}\\
\ & default\_breakpoint\_valid & breakpoint.c & \cxrefvar{default_breakpoint_valid}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function delete\_breakpoint()}
\label{func_delete_breakpoint_breakpoint.c}

{\stt void delete\_breakpoint ( struct breakpoint* bpt )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\ & deprecated\_print\_address\_numeric() & printcmd.c & \cxreffunc{deprecated_print_address_numeric}{printcmd.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & ep\_is\_exception\_catchpoint() & breakpoint.c & \cxreffunc{ep_is_exception_catchpoint}{breakpoint.c}\\
\ & error\_stream() & utils.c & \cxreffunc{error_stream}{utils.c}\\
\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & free\_valchain() & breakpoint.c & \cxreffunc{free_valchain}{breakpoint.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_ui\_file\_delete() & utils.c & \cxreffunc{make_cleanup_ui_file_delete}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & mem\_fileopen() & ui-file.c & \cxreffunc{mem_fileopen}{ui-file.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & safe\_strerror() & utils.c & \cxreffunc{safe_strerror}{utils.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ breakpoint\_delete\_event(), catch\_errors(), deprecated\_delete\_breakpoint\_hook(), free\_command\_lines()} &\\
Called by:\ & breakpoint\_auto\_delete() & breakpoint.c & \cxreffunc{breakpoint_auto_delete}{breakpoint.c}\\
\ & breakpoint\_init\_inferior() & breakpoint.c & \cxreffunc{breakpoint_init_inferior}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_re\_set\_all() & breakpoint.c & \cxreffunc{breakpoint_re_set_all}{breakpoint.c}\\
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & clear\_command() & breakpoint.c & \cxreffunc{clear_command}{breakpoint.c}\\
\ & delete\_command() & breakpoint.c & \cxreffunc{delete_command}{breakpoint.c}\\
\ & delete\_step\_resume\_breakpoint() & thread.c & \cxreffunc{delete_step_resume_breakpoint}{thread.c}\\
\ & disable\_exception\_catch() & breakpoint.c & \cxreffunc{disable_exception_catch}{breakpoint.c}\\
\ & do\_cleanup\_objc\_exception\_breakpoint() & objc-lang.c & \cxreffunc{do_cleanup_objc_exception_breakpoint}{objc-lang.c}\\
\ & do\_delete\_breakpoint\_cleanup() & breakpoint.c & \cxreffunc{do_delete_breakpoint_cleanup}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & free\_thread() & thread.c & \cxreffunc{free_thread}{thread.c}\\
\ & objc\_clear\_trampoline\_data() & objc-lang.c & \cxreffunc{objc_clear_trampoline_data}{objc-lang.c}\\
\ & remove\_solib\_event\_breakpoints() & breakpoint.c & \cxreffunc{remove_solib_event_breakpoints}{breakpoint.c}\\
\ & remove\_thread\_event\_breakpoints() & breakpoint.c & \cxreffunc{remove_thread_event_breakpoints}{breakpoint.c}\\
\ & resolve\_pending\_breakpoint() & breakpoint.c & \cxreffunc{resolve_pending_breakpoint}{breakpoint.c}\\
\ & update\_breakpoints\_after\_exec() & breakpoint.c & \cxreffunc{update_breakpoints_after_exec}{breakpoint.c}\\
\ & update\_exception\_catchpoints() & breakpoint.c & \cxreffunc{update_exception_catchpoints}{breakpoint.c}\\
Used in:\ & delete\_command() & breakpoint.c & \cxreffunc{delete_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & cover\_target\_enable\_exception\_callback() & breakpoint.c & \cxreffunc{cover_target_enable_exception_callback}{breakpoint.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & deprecated\_delete\_breakpoint\_hook & top.c & \cxrefvar{deprecated_delete_breakpoint_hook}{top.c}\\
\ & stop\_bpstat & infcmd.c & \cxrefvar{stop_bpstat}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function delete\_command()}
\label{func_delete_command_breakpoint.c}

{\stt void delete\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & dont\_repeat() & top.c & \cxreffunc{dont_repeat}{top.c}\\
\ & map\_breakpoint\_numbers() & breakpoint.c & \cxreffunc{map_breakpoint_numbers}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & query() & utils.c & \cxreffunc{query}{utils.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_read\_memory\_nobpt()}
\label{func_deprecated_read_memory_nobpt_breakpoint.c}

{\stt int deprecated\_read\_memory\_nobpt ( CORE\_ADDR memaddr, gdb\_byte* myaddr, unsigned int len )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdbcore.h & \ & \cxreffile{gdbcore.h}\\
Calls:\ & deprecated\_read\_memory\_nobpt() & breakpoint.c & \cxreffunc{deprecated_read_memory_nobpt}{breakpoint.c}\\
\ & gdbarch\_breakpoint\_from\_pc() & gdbarch.c & \cxreffunc{gdbarch_breakpoint_from_pc}{gdbarch.c}\\
\ & target\_read\_memory() & target/target.c & \cxreffunc{target_read_memory}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & deprecated\_read\_memory\_nobpt() & breakpoint.c & \cxreffunc{deprecated_read_memory_nobpt}{breakpoint.c}\\
\ & safe\_frame\_unwind\_memory() & frame.c & \cxreffunc{safe_frame_unwind_memory}{frame.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Global Function detach\_breakpoints()}
\label{func_detach_breakpoints_breakpoint.c}

{\stt int detach\_breakpoints ( int pid )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & save\_inferior\_ptid() & infrun.c & \cxreffunc{save_inferior_ptid}{infrun.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function detect\_location\_arg()}
\label{func_detect_location_arg_breakpoint.c}

{\stt int detect\_location\_arg ( const char** arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & \cxreftabiiispan{ strlen(), strstr()} &\\
Called by:\ & awatch\_command() & breakpoint.c & \cxreffunc{awatch_command}{breakpoint.c}\\
\ & rwatch\_command() & breakpoint.c & \cxreffunc{rwatch_command}{breakpoint.c}\\
\ & watch\_command() & breakpoint.c & \cxreffunc{watch_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function disable\_breakpoint()}
\label{func_disable_breakpoint_breakpoint.c}

{\stt void disable\_breakpoint ( struct breakpoint* bpt )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\ & \cxreftabiiispan{ breakpoint\_modify\_event(), deprecated\_modify\_breakpoint\_hook()} &\\
Called by:\ & disable\_command() & breakpoint.c & \cxreffunc{disable_command}{breakpoint.c}\\
Used in:\ & disable\_command() & breakpoint.c & \cxreffunc{disable_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & deprecated\_modify\_breakpoint\_hook & top.c & \cxrefvar{deprecated_modify_breakpoint_hook}{top.c}\\
\end{cxreftabiii}


\subsubsection{Global Function disable\_breakpoints\_in\_shlibs()}
\label{func_disable_breakpoints_in_shlibs_breakpoint.c}

{\stt void disable\_breakpoints\_in\_shlibs ( int silent )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & clear\_solib() & solib.c & \cxreffunc{clear_solib}{solib.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Global Function disable\_breakpoints\_in\_unloaded\_shlib()}
\label{func_disable_breakpoints_in_unloaded_shlib_breakpoint.c}

{\stt void disable\_breakpoints\_in\_unloaded\_shlib ( struct so\_list* solib )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ macosx\_pc\_solib(), strcmp()} &\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Global Function disable\_exception\_catch()}
\label{func_disable_exception_catch_breakpoint.c}

{\stt void disable\_exception\_catch ( enum exception\_event\_kind ex\_event )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & handle\_gnu\_v3\_exceptions() & breakpoint.c & \cxreffunc{handle_gnu_v3_exceptions}{breakpoint.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & exception\_catchpoint\_catch\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_catch_enabled}{breakpoint.c}\\
\ & exception\_catchpoint\_throw\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_throw_enabled}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function disable\_longjmp\_breakpoint()}
\label{func_disable_longjmp_breakpoint_breakpoint.c}

{\stt void disable\_longjmp\_breakpoint ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
Called by:\ & disable\_longjmp\_breakpoint\_cleanup() & infcmd.c & \cxreffunc{disable_longjmp_breakpoint_cleanup}{infcmd.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function disable\_overlay\_breakpoints()}
\label{func_disable_overlay_breakpoints_breakpoint.c}

{\stt void disable\_overlay\_breakpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
Called by:\ & overlay\_manual\_command() & symfile.c & \cxreffunc{overlay_manual_command}{symfile.c}\\
\ & overlay\_off\_command() & symfile.c & \cxreffunc{overlay_off_command}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & overlay\_events\_enabled & breakpoint.c & \cxrefvar{overlay_events_enabled}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function disable\_watchpoints\_before\_interactive\_call\_start()}
\label{func_disable_watchpoints_before_interactive_call_start_breakpoint.c}

{\stt void disable\_watchpoints\_before\_interactive\_call\_start ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\ & ep\_is\_exception\_catchpoint() & breakpoint.c & \cxreffunc{ep_is_exception_catchpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function enable\_breakpoint()}
\label{func_enable_breakpoint_breakpoint.c}

{\stt void enable\_breakpoint ( struct breakpoint* bpt )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & enable\_command() & breakpoint.c & \cxreffunc{enable_command}{breakpoint.c}\\
\ & make\_cleanup\_init\_objc\_exception\_catcher() & objc-lang.c & \cxreffunc{make_cleanup_init_objc_exception_catcher}{objc-lang.c}\\
Used in:\ & enable\_command() & breakpoint.c & \cxreffunc{enable_command}{breakpoint.c}\\
Refs Var:\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Global Function enable\_longjmp\_breakpoint()}
\label{func_enable_longjmp_breakpoint_breakpoint.c}

{\stt void enable\_longjmp\_breakpoint ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
Called by:\ & step\_1\_inlining() & infcmd.c & \cxreffunc{step_1_inlining}{infcmd.c}\\
\ & step\_1\_no\_inlining() & infcmd.c & \cxreffunc{step_1_no_inlining}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function enable\_overlay\_breakpoints()}
\label{func_enable_overlay_breakpoints_breakpoint.c}

{\stt void enable\_overlay\_breakpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
Called by:\ & overlay\_auto\_command() & symfile.c & \cxreffunc{overlay_auto_command}{symfile.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & overlay\_events\_enabled & breakpoint.c & \cxrefvar{overlay_events_enabled}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function enable\_user\_breakpoints\_after\_operation()}
\label{func_enable_user_breakpoints_after_operation_breakpoint.c}

{\stt void enable\_user\_breakpoints\_after\_operation ( void* unused )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
Used in:\ & make\_cleanup\_enable\_disable\_bpts\_during\_operation() & breakpoint.c & \cxreffunc{make_cleanup_enable_disable_bpts_during_operation}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function enable\_watchpoints\_after\_interactive\_call\_stop()}
\label{func_enable_watchpoints_after_interactive_call_stop_breakpoint.c}

{\stt void enable\_watchpoints\_after\_interactive\_call\_stop ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\ & ep\_is\_exception\_catchpoint() & breakpoint.c & \cxreffunc{ep_is_exception_catchpoint}{breakpoint.c}\\
Called by:\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ep\_is\_catchpoint()}
\label{func_ep_is_catchpoint_breakpoint.c}

{\stt int ep\_is\_catchpoint ( struct breakpoint* ep )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & print\_one\_breakpoint() & breakpoint.c & \cxreffunc{print_one_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ep\_is\_exception\_catchpoint()}
\label{func_ep_is_exception_catchpoint_breakpoint.c}

{\stt int ep\_is\_exception\_catchpoint ( struct breakpoint* ep )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & breakpoint\_init\_inferior() & breakpoint.c & \cxreffunc{breakpoint_init_inferior}{breakpoint.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & disable\_watchpoints\_before\_interactive\_call\_start() & breakpoint.c & \cxreffunc{disable_watchpoints_before_interactive_call_start}{breakpoint.c}\\
\ & enable\_watchpoints\_after\_interactive\_call\_stop() & breakpoint.c & \cxreffunc{enable_watchpoints_after_interactive_call_stop}{breakpoint.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function ep\_is\_shlib\_catchpoint()}
\label{func_ep_is_shlib_catchpoint_breakpoint.c}

{\stt int ep\_is\_shlib\_catchpoint ( struct breakpoint* ep )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
\end{cxreftabiii}


\subsubsection{Global Function exception\_catchpoints\_enabled()}
\label{func_exception_catchpoints_enabled_breakpoint.c}

{\stt int exception\_catchpoints\_enabled ( enum exception\_event\_kind ex\_event )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
Refs Var:\ & exception\_catchpoint\_catch\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_catch_enabled}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & exception\_catchpoint\_throw\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_throw_enabled}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function find\_breakpoint()}
\label{func_find_breakpoint_breakpoint.c}

{\stt struct breakpoint* find\_breakpoint ( int bpnum )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function find\_finish\_breakpoint()}
\label{func_find_finish_breakpoint_breakpoint.c}

{\stt struct breakpoint* find\_finish\_breakpoint ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function fsf\_gdb\_breakpoint()}
\label{func_fsf_gdb_breakpoint_breakpoint.c}

{\stt enum gdb\_rc fsf\_gdb\_breakpoint ( char* address, char* condition, int hardwareflag, int tempflag, int thread, int ignore\_count, char** error\_message )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdb.h & \ & \cxreffile{gdb.h}\\
Calls:\ & \cxreftabiiispan{ catch\_exceptions\_with\_msg()} &\\
Refs Func:\ & do\_captured\_breakpoint() & breakpoint.c & \cxreffunc{do_captured_breakpoint}{breakpoint.c}\\
Refs Var:\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Global Function future\_break\_command()}
\label{func_future_break_command_breakpoint.c}

{\stt void future\_break\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & restore\_saved\_pending\_break\_support() & breakpoint.c & \cxreffunc{restore_saved_pending_break_support}{breakpoint.c}\\
Refs Var:\ & pending\_break\_support & breakpoint.c & \cxrefvar{pending_break_support}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function gdb\_breakpoint()}
\label{func_gdb_breakpoint_breakpoint.c}

{\stt enum gdb\_rc gdb\_breakpoint ( char* address, char* condition, int hardwareflag, int tempflag, int futureflag, int thread, int ignore\_count, int* indices, char* requested\_shlib, char** error\_message )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdb.h & \ & \cxreffile{gdb.h}\\
Calls:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & clear\_new\_breakpoint\_list() & breakpoint.c & \cxreffunc{clear_new_breakpoint_list}{breakpoint.c}\\
\ & condition\_command\_1() & breakpoint.c & \cxreffunc{condition_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
Refs Func:\ & restore\_saved\_pending\_break\_support() & breakpoint.c & \cxreffunc{restore_saved_pending_break_support}{breakpoint.c}\\
Refs Var:\ & pending\_break\_support & breakpoint.c & \cxrefvar{pending_break_support}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function gdb\_breakpoint\_query()}
\label{func_gdb_breakpoint_query_breakpoint.c}

{\stt enum gdb\_rc gdb\_breakpoint\_query ( struct ui\_out* uiout, int bnum, char** error\_message )}

\smallskip
\begin{cxreftabiii}
Prototype:& gdb.h & \ & \cxreffile{gdb.h}\\
Calls:\ & \cxreftabiiispan{ catch\_exceptions\_with\_msg()} &\\
Refs Func:\ & do\_captured\_breakpoint\_query() & breakpoint.c & \cxreffunc{do_captured_breakpoint_query}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function get\_number()}
\label{func_get_number_breakpoint.c}

{\stt int get\_number ( const char** pp )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & get\_number\_trailer() & breakpoint.c & \cxreffunc{get_number_trailer}{breakpoint.c}\\
Called by:\ & commands\_command() & breakpoint.c & \cxreffunc{commands_command}{breakpoint.c}\\
\ & commands\_from\_control\_command() & breakpoint.c & \cxreffunc{commands_from_control_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & condition\_command() & breakpoint.c & \cxreffunc{condition_command}{breakpoint.c}\\
\ & get\_number\_or\_range() & breakpoint.c & \cxreffunc{get_number_or_range}{breakpoint.c}\\
\ & get\_tracepoint\_by\_number() & tracepoint.c & \cxreffunc{get_tracepoint_by_number}{tracepoint.c}\\
\ & ignore\_command() & breakpoint.c & \cxreffunc{ignore_command}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function get\_number\_or\_range()}
\label{func_get_number_or_range_breakpoint.c}

{\stt int get\_number\_or\_range ( const char** pp )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_number() & breakpoint.c & \cxreffunc{get_number}{breakpoint.c}\\
\ & get\_number\_trailer() & breakpoint.c & \cxreffunc{get_number_trailer}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ isspace()} &\\
Called by:\ & get\_tracepoint\_by\_number() & tracepoint.c & \cxreffunc{get_tracepoint_by_number}{tracepoint.c}\\
\ & map\_breakpoint\_numbers() & breakpoint.c & \cxreffunc{map_breakpoint_numbers}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function gnu\_v3\_update\_exception\_catchpoints()}
\label{func_gnu_v3_update_exception_catchpoints_breakpoint.c}

{\stt void gnu\_v3\_update\_exception\_catchpoints ( enum exception\_event\_kind ex\_event, int tempflag, const char* cond\_string )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & create\_exception\_catchpoint() & breakpoint.c & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\ & gdbarch\_skip\_prologue() & gdbarch.c & \cxreffunc{gdbarch_skip_prologue}{gdbarch.c}\\
\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & msymbol\_hash() & minsyms.c & \cxreffunc{msymbol_hash}{minsyms.c}\\
\ & objfile\_get\_first() & objfiles.c & \cxreffunc{objfile_get_first}{objfiles.c}\\
\ & objfile\_get\_next() & objfiles.c & \cxreffunc{objfile_get_next}{objfiles.c}\\
\ & strcmp\_iw() & utils.c & \cxreffunc{strcmp_iw}{utils.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
\ & catch\_exception\_command\_1() & breakpoint.c & \cxreffunc{catch_exception_command_1}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & exception\_catchpoint\_catch\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_catch_enabled}{breakpoint.c}\\
\ & exception\_catchpoint\_throw\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_throw_enabled}{breakpoint.c}\\
\ & gnu\_v3\_catch\_symbol & breakpoint.c & \cxrefvar{gnu_v3_catch_symbol}{breakpoint.c}\\
\ & gnu\_v3\_throw\_symbol & breakpoint.c & \cxrefvar{gnu_v3_throw_symbol}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function handle\_gnu\_v3\_exceptions()}
\label{func_handle_gnu_v3_exceptions_breakpoint.c}

{\stt int handle\_gnu\_v3\_exceptions ( enum exception\_event\_kind ex\_event )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & catch\_exception\_command\_1() & breakpoint.c & \cxreffunc{catch_exception_command_1}{breakpoint.c}\\
\ & disable\_exception\_catch() & breakpoint.c & \cxreffunc{disable_exception_catch}{breakpoint.c}\\
Refs Var:\ & exception\_catchpoint\_catch\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_catch_enabled}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & exception\_catchpoint\_throw\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_throw_enabled}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function insert\_breakpoints()}
\label{func_insert_breakpoints_breakpoint.c}

{\stt int insert\_breakpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & gdb\_value\_fetch\_lazy() & wrapper.c & \cxreffunc{gdb_value_fetch_lazy}{wrapper.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & make\_cleanup\_ui\_file\_delete() & utils.c & \cxreffunc{make_cleanup_ui_file_delete}{utils.c}\\
\ & mem\_fileopen() & ui-file.c & \cxreffunc{mem_fileopen}{ui-file.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & ui\_file\_put() & ui-file.c & \cxreffunc{ui_file_put}{ui-file.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & extended\_remote\_async\_create\_inferior() & remote.c & \cxreffunc{extended_remote_async_create_inferior}{remote.c}\\
\ & extended\_remote\_create\_inferior() & remote.c & \cxreffunc{extended_remote_create_inferior}{remote.c}\\
\ & follow\_exec() & infrun.c & \cxreffunc{follow_exec}{infrun.c}\\
\ & follow\_inferior\_reset\_breakpoints() & infrun.c & \cxreffunc{follow_inferior_reset_breakpoints}{infrun.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_sal() & infrun.c & \cxreffunc{insert_step_resume_breakpoint_at_sal}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & keep\_going() & infrun.c & \cxreffunc{keep_going}{infrun.c}\\
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
Refs Func:\ & ui\_file\_write() & ui-file.c & \cxreffunc{ui_file_write}{ui-file.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\end{cxreftabiii}


\subsubsection{Global Function make\_breakpoint\_permanent()}
\label{func_make_breakpoint_permanent_breakpoint.c}

{\stt void make\_breakpoint\_permanent ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
\end{cxreftabiii}


\subsubsection{Global Function make\_cleanup\_delete\_breakpoint()}
\label{func_make_cleanup_delete_breakpoint_breakpoint.c}

{\stt struct cleanup* make\_cleanup\_delete\_breakpoint ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
Called by:\ & finish\_command() & infcmd.c & \cxreffunc{finish_command}{infcmd.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & do\_delete\_breakpoint\_cleanup() & breakpoint.c & \cxreffunc{do_delete_breakpoint_cleanup}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function make\_cleanup\_enable\_disable\_bpts\_during\_operation()}
\label{func_make_cleanup_enable_disable_bpts_during_operation_breakpoint.c}

{\stt struct cleanup* make\_cleanup\_enable\_disable\_bpts\_during\_operation ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & disable\_user\_breakpoints\_before\_operation() & breakpoint.c & \cxreffunc{disable_user_breakpoints_before_operation}{breakpoint.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
Called by:\ & do\_end\_debugger\_mode() & objc-lang.c & \cxreffunc{do_end_debugger_mode}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup\_set\_restore\_debugger\_mode() & objc-lang.c & \cxreffunc{make_cleanup_set_restore_debugger_mode}{objc-lang.c}\\
Refs Func:\ & enable\_user\_breakpoints\_after\_operation() & breakpoint.c & \cxreffunc{enable_user_breakpoints_after_operation}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function make\_exec\_cleanup\_delete\_breakpoint()}
\label{func_make_exec_cleanup_delete_breakpoint_breakpoint.c}

{\stt struct cleanup* make\_exec\_cleanup\_delete\_breakpoint ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & make\_exec\_cleanup() & utils.c & \cxreffunc{make_exec_cleanup}{utils.c}\\
Called by:\ & finish\_command() & infcmd.c & \cxreffunc{finish_command}{infcmd.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & do\_delete\_breakpoint\_cleanup() & breakpoint.c & \cxreffunc{do_delete_breakpoint_cleanup}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function mark\_breakpoints\_out()}
\label{func_mark_breakpoints_out_breakpoint.c}

{\stt void mark\_breakpoints\_out ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & update\_breakpoints\_after\_exec() & breakpoint.c & \cxreffunc{update_breakpoints_after_exec}{breakpoint.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function rbr\_break\_command()}
\label{func_rbr_break_command_breakpoint.c}

{\stt void rbr\_break\_command ( const char* arg, int from\_tty, int use\_msymbol\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & rbreak\_command() & symtab.c & \cxreffunc{rbreak_command}{symtab.c}\\
Refs Func:\ & restore\_saved\_pending\_break\_support() & breakpoint.c & \cxreffunc{restore_saved_pending_break_support}{breakpoint.c}\\
Refs Var:\ & pending\_break\_support & breakpoint.c & \cxrefvar{pending_break_support}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function re\_enable\_breakpoints\_in\_shlibs()}
\label{func_re_enable_breakpoints_in_shlibs_breakpoint.c}

{\stt void re\_enable\_breakpoints\_in\_shlibs ( int silent )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & target\_read\_memory() & target/target.c & \cxreffunc{target_read_memory}{target/target.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ catch\_errors()} &\\
Called by:\ & add\_symbol\_file\_command() & symfile.c & \cxreffunc{add_symbol_file_command}{symfile.c}\\
\ & attach\_command() & infcmd.c & \cxreffunc{attach_command}{infcmd.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & remote\_open\_1() & remote.c & \cxreffunc{remote_open_1}{remote.c}\\
Refs Func:\ & resolve\_pending\_breakpoint() & breakpoint.c & \cxreffunc{resolve_pending_breakpoint}{breakpoint.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Global Function reattach\_breakpoints()}
\label{func_reattach_breakpoints_breakpoint.c}

{\stt int reattach\_breakpoints ( int pid )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & pid\_to\_ptid() & infrun.c & \cxreffunc{pid_to_ptid}{infrun.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & save\_inferior\_ptid() & infrun.c & \cxreffunc{save_inferior_ptid}{infrun.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remove\_breakpoints()}
\label{func_remove_breakpoints_breakpoint.c}

{\stt int remove\_breakpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & extended\_remote\_async\_create\_inferior() & remote.c & \cxreffunc{extended_remote_async_create_inferior}{remote.c}\\
\ & extended\_remote\_create\_inferior() & remote.c & \cxreffunc{extended_remote_create_inferior}{remote.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & normal\_stop() & infrun.c & \cxreffunc{normal_stop}{infrun.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remove\_duplicate\_sals()}
\label{func_remove_duplicate_sals_breakpoint.c}

{\stt void remove\_duplicate\_sals ( struct symtabs\_and\_lines* new\_sals, struct symtabs\_and\_lines old\_sals, char** new\_canonical )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & decode\_all\_variables() & linespec.c & \cxreffunc{decode_all_variables}{linespec.c}\\
\end{cxreftabiii}


\subsubsection{Global Function remove\_hw\_watchpoints()}
\label{func_remove_hw_watchpoints_breakpoint.c}

{\stt int remove\_hw\_watchpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
Called by:\ & resume() & infrun.c & \cxreffunc{resume}{infrun.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function remove\_solib\_event\_breakpoints()}
\label{func_remove_solib_event_breakpoints_breakpoint.c}

{\stt void remove\_solib\_event\_breakpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & gdb\_check\_fatal() & utils.c & \cxreffunc{gdb_check_fatal}{utils.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function remove\_thread\_event\_breakpoints()}
\label{func_remove_thread_event_breakpoints_breakpoint.c}

{\stt void remove\_thread\_event\_breakpoints ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function resolve\_sal\_pc()}
\label{func_resolve_sal_pc_breakpoint.c}

{\stt void resolve\_sal\_pc ( struct symtab\_and\_line* sal )}

\smallskip
\begin{cxreftabiii}
Prototype:& symtab.h & \ & \cxreffile{symtab.h}\\
Calls:\ & block\_function() & block.c & \cxreffunc{block_function}{block.c}\\
\ & blockvector\_for\_pc\_sect() & block.c & \cxreffunc{blockvector_for_pc_sect}{block.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_line\_pc\_range() & symtab.c & \cxreffunc{find_line_pc_range}{symtab.c}\\
\ & fixup\_symbol\_section() & symtab.c & \cxreffunc{fixup_symbol_section}{symtab.c}\\
\ & lookup\_minimal\_symbol\_by\_pc() & minsyms.c & \cxreffunc{lookup_minimal_symbol_by_pc}{minsyms.c}\\
Called by:\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & breakpoint\_sals\_to\_pc() & breakpoint.c & \cxreffunc{breakpoint_sals_to_pc}{breakpoint.c}\\
\ & jump\_command() & infcmd.c & \cxreffunc{jump_command}{infcmd.c}\\
\ & scope\_info() & tracepoint.c & \cxreffunc{scope_info}{tracepoint.c}\\
\ & solib\_load\_unload\_1() & breakpoint.c & \cxreffunc{solib_load_unload_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & trace\_command() & tracepoint.c & \cxreffunc{trace_command}{tracepoint.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function rwatch\_command\_wrapper()}
\label{func_rwatch_command_wrapper_breakpoint.c}

{\stt void rwatch\_command\_wrapper ( const char* arg, int by\_location, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_breakpoint\_count()}
\label{func_set_breakpoint_count_breakpoint.c}

{\stt void set\_breakpoint\_count ( int num )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & lookup\_internalvar() & value.c & \cxreffunc{lookup_internalvar}{value.c}\\
\ & set\_internalvar() & value.c & \cxreffunc{set_internalvar}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & create\_exception\_catchpoint() & breakpoint.c & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\ & create\_exec\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_exec_event_catchpoint}{breakpoint.c}\\
\ & create\_fork\_vfork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_fork_vfork_event_catchpoint}{breakpoint.c}\\
\ & set\_breakpoint\_sal() & breakpoint.c & \cxreffunc{set_breakpoint_sal}{breakpoint.c}\\
\ & solib\_load\_unload\_1() & breakpoint.c & \cxreffunc{solib_load_unload_1}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_breakpoint\_sal()}
\label{func_set_breakpoint_sal_breakpoint.c}

{\stt struct breakpoint* set\_breakpoint\_sal ( struct symtab\_and\_line sal )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_default\_breakpoint()}
\label{func_set_default_breakpoint_breakpoint.c}

{\stt void set\_default\_breakpoint ( int valid, CORE\_ADDR addr, struct symtab* symtab, int line )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Called by:\ & clear\_symtab\_users() & symfile.c & \cxreffunc{clear_symtab_users}{symfile.c}\\
\ & print\_frame\_info() & stack.c & \cxreffunc{print_frame_info}{stack.c}\\
Refs Var:\ & default\_breakpoint\_address & breakpoint.c & \cxrefvar{default_breakpoint_address}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & default\_breakpoint\_line & breakpoint.c & \cxrefvar{default_breakpoint_line}{breakpoint.c}\\
\ & default\_breakpoint\_symtab & breakpoint.c & \cxrefvar{default_breakpoint_symtab}{breakpoint.c}\\
\ & default\_breakpoint\_valid & breakpoint.c & \cxrefvar{default_breakpoint_valid}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_ignore\_count()}
\label{func_set_ignore_count_breakpoint.c}

{\stt void set\_ignore\_count ( int bptnum, int count, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & \cxreftabiiispan{ breakpoint\_modify\_event(), breakpoints\_changed()} &\\
Called by:\ & continue\_command() & infcmd.c & \cxreffunc{continue_command}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & ignore\_command() & breakpoint.c & \cxreffunc{ignore_command}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_longjmp\_resume\_breakpoint()}
\label{func_set_longjmp_resume_breakpoint_breakpoint.c}

{\stt void set\_longjmp\_resume\_breakpoint ( CORE\_ADDR pc, struct frame\_id frame\_id )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & adjust\_breakpoint\_address() & breakpoint.c & \cxreffunc{adjust_breakpoint_address}{breakpoint.c}\\
\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
Called by:\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_momentary\_breakpoint()}
\label{func_set_momentary_breakpoint_breakpoint.c}

{\stt struct breakpoint* set\_momentary\_breakpoint ( struct symtab\_and\_line sal, struct frame\_id frame\_id, enum bptype type )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & in\_thread\_list() & thread.c & \cxreffunc{in_thread_list}{thread.c}\\
\ & pid\_to\_thread\_id() & thread.c & \cxreffunc{pid_to_thread_id}{thread.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & finish\_command() & infcmd.c & \cxreffunc{finish_command}{infcmd.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & insert\_step\_resume\_breakpoint\_at\_sal() & infrun.c & \cxreffunc{insert_step_resume_breakpoint_at_sal}{infrun.c}\\
\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
Refs Var:\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_raw\_breakpoint()}
\label{func_set_raw_breakpoint_breakpoint.c}

{\stt struct breakpoint* set\_raw\_breakpoint ( struct symtab\_and\_line sal, enum bptype bptype, int pending\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & adjust\_breakpoint\_address() & breakpoint.c & \cxreffunc{adjust_breakpoint_address}{breakpoint.c}\\
\ & allocate\_bp\_location() & breakpoint.c & \cxreffunc{allocate_bp_location}{breakpoint.c}\\
\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & set\_bp\_objfile() & breakpoint.c & \cxreffunc{set_bp_objfile}{breakpoint.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), breakpoints\_changed(), strlen()} &\\
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & create\_exception\_catchpoint() & breakpoint.c & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\ & create\_exec\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_exec_event_catchpoint}{breakpoint.c}\\
\ & create\_fork\_vfork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_fork_vfork_event_catchpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_internal\_breakpoint() & breakpoint.c & \cxreffunc{create_internal_breakpoint}{breakpoint.c}\\
\ & set\_breakpoint\_sal() & breakpoint.c & \cxreffunc{set_breakpoint_sal}{breakpoint.c}\\
\ & set\_momentary\_breakpoint() & breakpoint.c & \cxreffunc{set_momentary_breakpoint}{breakpoint.c}\\
\ & solib\_load\_unload\_1() & breakpoint.c & \cxreffunc{solib_load_unload_1}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\ & input\_radix & valprint.c & \cxrefvar{input_radix}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\end{cxreftabiii}


\subsubsection{Global Function software\_breakpoint\_inserted\_here\_p()}
\label{func_software_breakpoint_inserted_here_p_breakpoint.c}

{\stt int software\_breakpoint\_inserted\_here\_p ( CORE\_ADDR pc )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & section\_is\_mapped() & symfile.c & \cxreffunc{section_is_mapped}{symfile.c}\\
\ & section\_is\_overlay() & symfile.c & \cxreffunc{section_is_overlay}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & adjust\_pc\_after\_break() & infrun.c & \cxreffunc{adjust_pc_after_break}{infrun.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\end{cxreftabiii}


\subsubsection{Global Function tbreak\_command()}
\label{func_tbreak_command_breakpoint.c}

{\stt void tbreak\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
Called by:\ & go\_command() & infcmd.c & \cxreffunc{go_command}{infcmd.c}\\
\ & run\_command\_1() & infcmd.c & \cxreffunc{run_command_1}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function tell\_breakpoints\_objfile\_changed()}
\label{func_tell_breakpoints_objfile_changed_breakpoint.c}

{\stt void tell\_breakpoints\_objfile\_changed ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & tell\_breakpoints\_objfile\_changed\_internal() & breakpoint.c & \cxreffunc{tell_breakpoints_objfile_changed_internal}{breakpoint.c}\\
Called by:\ & remove\_symbol\_file\_command() & symfile.c & \cxreffunc{remove_symbol_file_command}{symfile.c}\\
\ & reopen\_exec\_file() & corefile.c & \cxreffunc{reopen_exec_file}{corefile.c}\\
\cxreftabbreak{cxreftabiii}
\ & replace\_psymbols\_with\_correct\_psymbols() & symfile.c & \cxreffunc{replace_psymbols_with_correct_psymbols}{symfile.c}\\
\ & reread\_symbols\_for\_objfile() & symfile.c & \cxreffunc{reread_symbols_for_objfile}{symfile.c}\\
\end{cxreftabiii}


\subsubsection{Global Function tell\_breakpoints\_objfile\_removed()}
\label{func_tell_breakpoints_objfile_removed_breakpoint.c}

{\stt void tell\_breakpoints\_objfile\_removed ( struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & tell\_breakpoints\_objfile\_changed\_internal() & breakpoint.c & \cxreffunc{tell_breakpoints_objfile_changed_internal}{breakpoint.c}\\
Called by:\ & free\_objfile() & objfiles.c & \cxreffunc{free_objfile}{objfiles.c}\\
\end{cxreftabiii}


\subsubsection{Global Function until\_break\_command()}
\label{func_until_break_command_breakpoint.c}

{\stt void until\_break\_command ( const char* arg, int from\_tty, int anywhere )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & add\_continuation() & utils.c & \cxreffunc{add_continuation}{utils.c}\\
\ & clear\_proceed\_status() & infrun.c & \cxreffunc{clear_proceed_status}{infrun.c}\\
\ & decode\_line\_1() & linespec.c & \cxreffunc{decode_line_1}{linespec.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_pc\_line() & symtab.c & \cxreffunc{find_pc_line}{symtab.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_frame\_pc() & frame.c & \cxreffunc{get_frame_pc}{frame.c}\\
\ & get\_prev\_frame() & frame.c & \cxreffunc{get_prev_frame}{frame.c}\\
\ & make\_cleanup\_delete\_breakpoint() & breakpoint.c & \cxreffunc{make_cleanup_delete_breakpoint}{breakpoint.c}\\
\ & make\_exec\_cleanup\_delete\_breakpoint() & breakpoint.c & \cxreffunc{make_exec_cleanup_delete_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & proceed() & infrun.c & \cxreffunc{proceed}{infrun.c}\\
\ & resolve\_sal\_pc() & breakpoint.c & \cxreffunc{resolve_sal_pc}{breakpoint.c}\\
\ & set\_momentary\_breakpoint() & breakpoint.c & \cxreffunc{set_momentary_breakpoint}{breakpoint.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & advance\_command() & infcmd.c & \cxreffunc{advance_command}{infcmd.c}\\
\ & until\_command() & infcmd.c & \cxreffunc{until_command}{infcmd.c}\\
Refs Func:\ & until\_break\_command\_continuation() & breakpoint.c & \cxreffunc{until_break_command_continuation}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & default\_breakpoint\_line & breakpoint.c & \cxrefvar{default_breakpoint_line}{breakpoint.c}\\
\ & default\_breakpoint\_symtab & breakpoint.c & \cxrefvar{default_breakpoint_symtab}{breakpoint.c}\\
\ & default\_breakpoint\_valid & breakpoint.c & \cxrefvar{default_breakpoint_valid}{breakpoint.c}\\
\ & deprecated\_selected\_frame & frame.c & \cxrefvar{deprecated_selected_frame}{frame.c}\\
\ & gdb\_override\_async & target/target.c & \cxrefvar{gdb_override_async}{target/target.c}\\
\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\end{cxreftabiii}


\subsubsection{Global Function update\_breakpoints\_after\_exec()}
\label{func_update_breakpoints_after_exec_breakpoint.c}

{\stt void update\_breakpoints\_after\_exec ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & create\_overlay\_event\_breakpoint() & breakpoint.c & \cxreffunc{create_overlay_event_breakpoint}{breakpoint.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & mark\_breakpoints\_out() & breakpoint.c & \cxreffunc{mark_breakpoints_out}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & follow\_exec() & infrun.c & \cxreffunc{follow_exec}{infrun.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function update\_exception\_catchpoints()}
\label{func_update_exception_catchpoints_breakpoint.c}

{\stt int update\_exception\_catchpoints ( enum exception\_event\_kind ex\_event, int tempflag, const char* cond\_string, int delete\_it, struct objfile* objfile )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & create\_exception\_catchpoint() & breakpoint.c & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & catch\_exception\_command\_1() & breakpoint.c & \cxreffunc{catch_exception_command_1}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & exception\_catchpoint\_catch\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_catch_enabled}{breakpoint.c}\\
\ & exception\_catchpoint\_throw\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_throw_enabled}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function watch\_command\_wrapper()}
\label{func_watch_command_wrapper_breakpoint.c}

{\stt void watch\_command\_wrapper ( const char* arg, int by\_location, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.h & \ & \cxreffile{breakpoint.h}\\
Calls:\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function add\_breakpoint\_to\_new\_list()}
\label{func_add_breakpoint_to_new_list_breakpoint.c}

{\stt static void add\_breakpoint\_to\_new\_list ( struct breakpoint\_list** new\_breakpoints, struct breakpoint* bp )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function adjust\_breakpoint\_address()}
\label{func_adjust_breakpoint_address_breakpoint.c}

{\stt static CORE\_ADDR adjust\_breakpoint\_address ( CORE\_ADDR bpaddr, enum bptype bptype )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & breakpoint\_adjustment\_warning() & breakpoint.c & \cxreffunc{breakpoint_adjustment_warning}{breakpoint.c}\\
\ & gdbarch\_adjust\_breakpoint\_address() & gdbarch.c & \cxreffunc{gdbarch_adjust_breakpoint_address}{gdbarch.c}\\
\ & gdbarch\_adjust\_breakpoint\_address\_p() & gdbarch.c & \cxreffunc{gdbarch_adjust_breakpoint_address_p}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & set\_longjmp\_resume\_breakpoint() & breakpoint.c & \cxreffunc{set_longjmp_resume_breakpoint}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Local Function allocate\_bp\_location()}
\label{func_allocate_bp_location_breakpoint.c}

{\stt static struct bp\_location* allocate\_bp\_location ( struct breakpoint* bpt, enum bptype bp\_type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function async\_breakpoint\_command\_continuation()}
\label{func_async_breakpoint_command_continuation_breakpoint.c}

{\stt static void async\_breakpoint\_command\_continuation ( struct continuation\_arg* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & bpstat\_do\_actions() & breakpoint.c & \cxreffunc{bpstat_do_actions}{breakpoint.c}\\
Used in:\ & bpstat\_do\_actions() & breakpoint.c & \cxreffunc{bpstat_do_actions}{breakpoint.c}\\
Refs Var:\ & stop\_bpstat & infcmd.c & \cxrefvar{stop_bpstat}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function awatch\_command()}
\label{func_awatch_command_breakpoint.c}

{\stt static void awatch\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & detect\_location\_arg() & breakpoint.c & \cxreffunc{detect_location_arg}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function bpstat\_alloc()}
\label{func_bpstat_alloc_breakpoint.c}

{\stt static bpstat bpstat\_alloc ( struct breakpoint* b, bpstat cbs )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & bpstat\_get\_triggered\_catchpoints() & breakpoint.c & \cxreffunc{bpstat_get_triggered_catchpoints}{breakpoint.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function break\_command\_1()}
\label{func_break_command_1_breakpoint.c}

{\stt static int break\_command\_1 ( const char* arg, int flag, int from\_tty, struct breakpoint* pending\_bp, int use\_msymbol\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), isspace(), strstr()} &\\
Called by:\ & break\_command() & breakpoint.c & \cxreffunc{break_command}{breakpoint.c}\\
\ & future\_break\_command() & breakpoint.c & \cxreffunc{future_break_command}{breakpoint.c}\\
\ & hbreak\_command() & breakpoint.c & \cxreffunc{hbreak_command}{breakpoint.c}\\
\ & rbr\_break\_command() & breakpoint.c & \cxreffunc{rbr_break_command}{breakpoint.c}\\
\ & stopat\_command() & breakpoint.c & \cxreffunc{stopat_command}{breakpoint.c}\\
\ & stopin\_command() & breakpoint.c & \cxreffunc{stopin_command}{breakpoint.c}\\
\ & tbreak\_command() & breakpoint.c & \cxreffunc{tbreak_command}{breakpoint.c}\\
\ & thbreak\_command() & breakpoint.c & \cxreffunc{thbreak_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function break\_command\_2()}
\label{func_break_command_2_breakpoint.c}

{\stt static int break\_command\_2 ( const char* arg, int flag, int from\_tty, struct breakpoint* pending\_bp, char* requested\_shlib, int* indices, struct breakpoint\_list** new\_breakpoints, int use\_msymbol\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & add\_breakpoint\_to\_new\_list() & breakpoint.c & \cxreffunc{add_breakpoint_to_new_list}{breakpoint.c}\\
\ & block\_for\_pc() & block.c & \cxreffunc{block_for_pc}{block.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & discard\_cleanups() & utils.c & \cxreffunc{discard_cleanups}{utils.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_pc\_sect\_function() & blockframe.c & \cxreffunc{find_pc_sect_function}{blockframe.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_ui\_out\_list\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_list_begin_end}{ui-out.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & nquery() & utils.c & \cxreffunc{nquery}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_exp\_1() & parse.c & \cxreffunc{parse_exp_1}{parse.c}\\
\ & remove\_duplicates() & breakpoint.c & \cxreffunc{remove_duplicates}{breakpoint.c}\\
\ & remove\_non\_msymbol\_sals() & breakpoint.c & \cxreffunc{remove_non_msymbol_sals}{breakpoint.c}\\
\ & safe\_breakpoint\_sals\_to\_pc() & breakpoint.c & \cxreffunc{safe_breakpoint_sals_to_pc}{breakpoint.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_field\_core\_addr() & ui-out.c & \cxreffunc{ui_out_field_core_addr}{ui-out.c}\\
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & ui\_out\_field\_skip() & ui-out.c & \cxreffunc{ui_out_field_skip}{ui-out.c}\\
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\ & valid\_thread\_id() & thread.c & \cxreffunc{valid_thread_id}{thread.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xcalloc() & utils.c & \cxreffunc{xcalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ catch\_exception(), exception\_print(), strncmp(), strtol(), throw\_exception(), xstrdup()} &\\
Called by:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
\ & gdb\_breakpoint() & breakpoint.c & \cxreffunc{gdb_breakpoint}{breakpoint.c}\\
\ & resolve\_pending\_breakpoint() & breakpoint.c & \cxreffunc{resolve_pending_breakpoint}{breakpoint.c}\\
Refs Func:\ & do\_captured\_parse\_breakpoint() & breakpoint.c & \cxreffunc{do_captured_parse_breakpoint}{breakpoint.c}\\
\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\ & demangle & utils.c & \cxrefvar{demangle}{utils.c}\\
\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\ & pending\_break\_support & breakpoint.c & \cxrefvar{pending_break_support}{breakpoint.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function breakpoint\_1()}
\label{func_breakpoint_1_breakpoint.c}

{\stt static void breakpoint\_1 ( int bnum, int allflag )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & gdbarch\_addr\_bit() & gdbarch.c & \cxreffunc{gdbarch_addr_bit}{gdbarch.c}\\
\ & make\_cleanup\_ui\_out\_table\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_table_begin_end}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_one\_breakpoint() & breakpoint.c & \cxreffunc{print_one_breakpoint}{breakpoint.c}\\
\ & set\_next\_address() & printcmd.c & \cxreffunc{set_next_address}{printcmd.c}\\
\ & ui\_out\_message() & ui-out.c & \cxreffunc{ui_out_message}{ui-out.c}\\
\ & ui\_out\_table\_body() & ui-out.c & \cxreffunc{ui_out_table_body}{ui-out.c}\\
\ & ui\_out\_table\_header() & ui-out.c & \cxreffunc{ui_out_table_header}{ui-out.c}\\
\ & user\_settable\_breakpoint() & breakpoint.c & \cxreffunc{user_settable_breakpoint}{breakpoint.c}\\
\ & \cxreftabiiispan{ annotate\_breakpoints\_headers(), annotate\_breakpoints\_table(), annotate\_breakpoints\_table\_end(), annotate\_field()} &\\
Called by:\ & breakpoints\_info() & breakpoint.c & \cxreffunc{breakpoints_info}{breakpoint.c}\\
\ & maintenance\_info\_breakpoints() & breakpoint.c & \cxreffunc{maintenance_info_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & addressprint & valprint.c & \cxrefvar{addressprint}{valprint.c}\\
\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function breakpoint\_address\_is\_meaningful()}
\label{func_breakpoint_address_is_meaningful_breakpoint.c}

{\stt static int breakpoint\_address\_is\_meaningful ( struct breakpoint* bpt )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Called by:\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\ & describe\_other\_breakpoints() & breakpoint.c & \cxreffunc{describe_other_breakpoints}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function breakpoint\_adjustment\_warning()}
\label{func_breakpoint_adjustment_warning_breakpoint.c}

{\stt static void breakpoint\_adjustment\_warning ( CORE\_ADDR from\_addr, CORE\_ADDR to\_addr, int bnum, int have\_bnum )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & hex\_string\_custom() & utils.c & \cxreffunc{hex_string_custom}{utils.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk()} &\\
Called by:\ & adjust\_breakpoint\_address() & breakpoint.c & \cxreffunc{adjust_breakpoint_address}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_it\_typical() & breakpoint.c & \cxreffunc{print_it_typical}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function breakpoint\_cond\_eval()}
\label{func_breakpoint_cond_eval_breakpoint.c}

{\stt static int breakpoint\_cond\_eval ( void* exp )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_true() & language.c & \cxreffunc{value_true}{language.c}\\
Used in:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function breakpoint\_enabled()}
\label{func_breakpoint_enabled_breakpoint.c}

{\stt static int breakpoint\_enabled ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Called by:\ & bpstat\_have\_active\_hw\_watchpoints() & breakpoint.c & \cxreffunc{bpstat_have_active_hw_watchpoints}{breakpoint.c}\\
\ & bpstat\_should\_step() & breakpoint.c & \cxreffunc{bpstat_should_step}{breakpoint.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & breakpoint\_here\_p() & breakpoint.c & \cxreffunc{breakpoint_here_p}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & breakpoint\_thread\_match() & breakpoint.c & \cxreffunc{breakpoint_thread_match}{breakpoint.c}\\
\ & disable\_breakpoints\_in\_shlibs() & breakpoint.c & \cxreffunc{disable_breakpoints_in_shlibs}{breakpoint.c}\\
\ & disable\_breakpoints\_in\_unloaded\_shlib() & breakpoint.c & \cxreffunc{disable_breakpoints_in_unloaded_shlib}{breakpoint.c}\\
\ & disable\_user\_breakpoints\_before\_operation() & breakpoint.c & \cxreffunc{disable_user_breakpoints_before_operation}{breakpoint.c}\\
\ & disable\_watchpoints\_before\_interactive\_call\_start() & breakpoint.c & \cxreffunc{disable_watchpoints_before_interactive_call_start}{breakpoint.c}\\
\ & hw\_watchpoint\_used\_count() & breakpoint.c & \cxreffunc{hw_watchpoint_used_count}{breakpoint.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & software\_breakpoint\_inserted\_here\_p() & breakpoint.c & \cxreffunc{software_breakpoint_inserted_here_p}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function breakpoint\_re\_set\_all()}
\label{func_breakpoint_re_set_all_breakpoint.c}

{\stt static void breakpoint\_re\_set\_all ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & create\_longjmp\_breakpoint() & breakpoint.c & \cxreffunc{create_longjmp_breakpoint}{breakpoint.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_get\_longjmp\_target\_p() & gdbarch.c & \cxreffunc{gdbarch_get_longjmp_target_p}{gdbarch.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objfile\_restrict\_search() & objfiles.c & \cxreffunc{objfile_restrict_search}{objfiles.c}\\
\ & set\_language() & language.c & \cxreffunc{set_language}{language.c}\\
\ & user\_settable\_breakpoint() & breakpoint.c & \cxreffunc{user_settable_breakpoint}{breakpoint.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ catch\_errors()} &\\
Called by:\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
Refs Func:\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\ & input\_radix & valprint.c & \cxrefvar{input_radix}{valprint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function breakpoint\_re\_set\_one()}
\label{func_breakpoint_re_set_one_breakpoint.c}

{\stt static int breakpoint\_re\_set\_one ( void* bint )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & adjust\_breakpoint\_address() & breakpoint.c & \cxreffunc{adjust_breakpoint_address}{breakpoint.c}\\
\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & decode\_line\_1() & linespec.c & \cxreffunc{decode_line_1}{linespec.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & find\_pc\_sect\_section() & objfiles.c & \cxreffunc{find_pc_sect_section}{objfiles.c}\\
\ & find\_pc\_section() & objfiles.c & \cxreffunc{find_pc_section}{objfiles.c}\\
\ & gdb\_parse\_exp\_1() & wrapper.c & \cxreffunc{gdb_parse_exp_1}{wrapper.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_restrict\_to\_objfile\_by\_name() & objfiles.c & \cxreffunc{make_cleanup_restrict_to_objfile_by_name}{objfiles.c}\\
\ & make\_cleanup\_restrict\_to\_shlib() & objfiles.c & \cxreffunc{make_cleanup_restrict_to_shlib}{objfiles.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & objfile\_name\_set\_load\_state() & objfiles.c & \cxreffunc{objfile_name_set_load_state}{objfiles.c}\\
\ & parse\_exp\_1() & parse.c & \cxreffunc{parse_exp_1}{parse.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & resolve\_sal\_pc() & breakpoint.c & \cxreffunc{resolve_sal_pc}{breakpoint.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & set\_bp\_objfile() & breakpoint.c & \cxreffunc{set_bp_objfile}{breakpoint.c}\\
\ & set\_language() & language.c & \cxreffunc{set_language}{language.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ breakpoints\_changed(), deprecated\_modify\_breakpoint\_hook(), strcmp(), strlen()} &\\
Used in:\ & breakpoint\_re\_set\_all() & breakpoint.c & \cxreffunc{breakpoint_re_set_all}{breakpoint.c}\\
\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
Refs Func:\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & deprecated\_modify\_breakpoint\_hook & top.c & \cxrefvar{deprecated_modify_breakpoint_hook}{top.c}\\
\cxreftabbreak{cxreftabiii}
\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\ & input\_radix & valprint.c & \cxrefvar{input_radix}{valprint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function breakpoint\_sals\_to\_pc()}
\label{func_breakpoint_sals_to_pc_breakpoint.c}

{\stt static void breakpoint\_sals\_to\_pc ( struct symtabs\_and\_lines* sals, const char* address )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & resolve\_sal\_pc() & breakpoint.c & \cxreffunc{resolve_sal_pc}{breakpoint.c}\\
Called by:\ & do\_captured\_breakpoint() & breakpoint.c & \cxreffunc{do_captured_breakpoint}{breakpoint.c}\\
\ & wrap\_breakpoint\_sals\_to\_pc() & breakpoint.c & \cxreffunc{wrap_breakpoint_sals_to_pc}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function breakpoints\_info()}
\label{func_breakpoints_info_breakpoint.c}

{\stt static void breakpoints\_info ( const char* bnum\_exp, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & breakpoint\_1() & breakpoint.c & \cxreffunc{breakpoint_1}{breakpoint.c}\\
\ & parse\_and\_eval\_long() & eval.c & \cxreffunc{parse_and_eval_long}{eval.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function can\_use\_hardware\_watchpoint()}
\label{func_can_use_hardware_watchpoint_breakpoint.c}

{\stt static int can\_use\_hardware\_watchpoint ( struct value* v )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_modifiable() & value.c & \cxreffunc{deprecated_value_modifiable}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_next() & value.c & \cxreffunc{value_next}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ i386\_region\_ok\_for\_watchpoint()} &\\
Called by:\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
Refs Var:\ & can\_use\_hw\_watchpoints & breakpoint.c & \cxrefvar{can_use_hw_watchpoints}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function catch\_command()}
\label{func_catch_command_breakpoint.c}

{\stt static void catch\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & catch\_command\_1() & breakpoint.c & \cxreffunc{catch_command_1}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function catch\_command\_1()}
\label{func_catch_command_1_breakpoint.c}

{\stt static void catch\_command\_1 ( const char* arg, int tempflag, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & catch\_exception\_command\_1() & breakpoint.c & \cxreffunc{catch_exception_command_1}{breakpoint.c}\\
\ & catch\_exec\_command\_1() & breakpoint.c & \cxreffunc{catch_exec_command_1}{breakpoint.c}\\
\ & catch\_fork\_command\_1() & breakpoint.c & \cxreffunc{catch_fork_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & catch\_load\_command\_1() & breakpoint.c & \cxreffunc{catch_load_command_1}{breakpoint.c}\\
\ & catch\_unload\_command\_1() & breakpoint.c & \cxreffunc{catch_unload_command_1}{breakpoint.c}\\
\ & ep\_find\_event\_name\_end() & breakpoint.c & \cxreffunc{ep_find_event_name_end}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & \cxreftabiiispan{ strncmp()} &\\
Called by:\ & catch\_command() & breakpoint.c & \cxreffunc{catch_command}{breakpoint.c}\\
\ & tcatch\_command() & breakpoint.c & \cxreffunc{tcatch_command}{breakpoint.c}\\
Refs Var:\ & exception\_catchpoint\_catch\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_catch_enabled}{breakpoint.c}\\
\ & exception\_catchpoint\_throw\_enabled & breakpoint.c & \cxrefvar{exception_catchpoint_throw_enabled}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function catch\_exception\_command\_1()}
\label{func_catch_exception_command_1_breakpoint.c}

{\stt static void catch\_exception\_command\_1 ( enum exception\_event\_kind ex\_event, const char* arg, int tempflag, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & ep\_parse\_optional\_if\_clause() & breakpoint.c & \cxreffunc{ep_parse_optional_if_clause}{breakpoint.c}\\
\ & ep\_skip\_leading\_whitespace() & breakpoint.c & \cxreffunc{ep_skip_leading_whitespace}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnu\_v3\_update\_exception\_catchpoints() & breakpoint.c & \cxreffunc{gnu_v3_update_exception_catchpoints}{breakpoint.c}\\
\ & handle\_gnu\_v3\_exceptions() & breakpoint.c & \cxreffunc{handle_gnu_v3_exceptions}{breakpoint.c}\\
\ & update\_exception\_catchpoints() & breakpoint.c & \cxreffunc{update_exception_catchpoints}{breakpoint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ isspace()} &\\
Called by:\ & catch\_command\_1() & breakpoint.c & \cxreffunc{catch_command_1}{breakpoint.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Local Function catch\_exec\_command\_1()}
\label{func_catch_exec_command_1_breakpoint.c}

{\stt static void catch\_exec\_command\_1 ( const char* arg, int tempflag, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & create\_exec\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_exec_event_catchpoint}{breakpoint.c}\\
\ & ep\_parse\_optional\_if\_clause() & breakpoint.c & \cxreffunc{ep_parse_optional_if_clause}{breakpoint.c}\\
\ & ep\_skip\_leading\_whitespace() & breakpoint.c & \cxreffunc{ep_skip_leading_whitespace}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ isspace()} &\\
Called by:\ & catch\_command\_1() & breakpoint.c & \cxreffunc{catch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function catch\_fork\_command\_1()}
\label{func_catch_fork_command_1_breakpoint.c}

{\stt static void catch\_fork\_command\_1 ( catch\_fork\_kind fork\_kind, const char* arg, int tempflag, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & create\_fork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_fork_event_catchpoint}{breakpoint.c}\\
\ & create\_vfork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_vfork_event_catchpoint}{breakpoint.c}\\
\ & ep\_parse\_optional\_if\_clause() & breakpoint.c & \cxreffunc{ep_parse_optional_if_clause}{breakpoint.c}\\
\ & ep\_skip\_leading\_whitespace() & breakpoint.c & \cxreffunc{ep_skip_leading_whitespace}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & \cxreftabiiispan{ isspace()} &\\
Called by:\ & catch\_command\_1() & breakpoint.c & \cxreffunc{catch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function catch\_load\_command\_1()}
\label{func_catch_load_command_1_breakpoint.c}

{\stt static void catch\_load\_command\_1 ( const char* arg, int tempflag, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ep\_parse\_optional\_filename() & breakpoint.c & \cxreffunc{ep_parse_optional_filename}{breakpoint.c}\\
\ & ep\_parse\_optional\_if\_clause() & breakpoint.c & \cxreffunc{ep_parse_optional_if_clause}{breakpoint.c}\\
\ & ep\_skip\_leading\_whitespace() & breakpoint.c & \cxreffunc{ep_skip_leading_whitespace}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ isspace()} &\\
Called by:\ & catch\_command\_1() & breakpoint.c & \cxreffunc{catch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function catch\_unload\_command\_1()}
\label{func_catch_unload_command_1_breakpoint.c}

{\stt static void catch\_unload\_command\_1 ( const char* arg, int tempflag, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & ep\_parse\_optional\_filename() & breakpoint.c & \cxreffunc{ep_parse_optional_filename}{breakpoint.c}\\
\ & ep\_parse\_optional\_if\_clause() & breakpoint.c & \cxreffunc{ep_parse_optional_if_clause}{breakpoint.c}\\
\ & ep\_skip\_leading\_whitespace() & breakpoint.c & \cxreffunc{ep_skip_leading_whitespace}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ isspace()} &\\
Called by:\ & catch\_command\_1() & breakpoint.c & \cxreffunc{catch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function check\_duplicates()}
\label{func_check_duplicates_breakpoint.c}

{\stt static void check\_duplicates ( struct breakpoint* bpt )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & breakpoint\_address\_is\_meaningful() & breakpoint.c & \cxreffunc{breakpoint_address_is_meaningful}{breakpoint.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
Called by:\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & disable\_breakpoint() & breakpoint.c & \cxreffunc{disable_breakpoint}{breakpoint.c}\\
\ & disable\_longjmp\_breakpoint() & breakpoint.c & \cxreffunc{disable_longjmp_breakpoint}{breakpoint.c}\\
\ & disable\_overlay\_breakpoints() & breakpoint.c & \cxreffunc{disable_overlay_breakpoints}{breakpoint.c}\\
\ & disable\_user\_breakpoints\_before\_operation() & breakpoint.c & \cxreffunc{disable_user_breakpoints_before_operation}{breakpoint.c}\\
\ & disable\_watchpoints\_before\_interactive\_call\_start() & breakpoint.c & \cxreffunc{disable_watchpoints_before_interactive_call_start}{breakpoint.c}\\
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & enable\_longjmp\_breakpoint() & breakpoint.c & \cxreffunc{enable_longjmp_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & enable\_overlay\_breakpoints() & breakpoint.c & \cxreffunc{enable_overlay_breakpoints}{breakpoint.c}\\
\ & enable\_user\_breakpoints\_after\_operation() & breakpoint.c & \cxreffunc{enable_user_breakpoints_after_operation}{breakpoint.c}\\
\ & enable\_watchpoints\_after\_interactive\_call\_stop() & breakpoint.c & \cxreffunc{enable_watchpoints_after_interactive_call_stop}{breakpoint.c}\\
\ & set\_longjmp\_resume\_breakpoint() & breakpoint.c & \cxreffunc{set_longjmp_resume_breakpoint}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
Refs Var:\ & bp\_location\_chain & breakpoint.c & \cxrefvar{bp_location_chain}{breakpoint.c}\\
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cleanup\_executing\_breakpoints()}
\label{func_cleanup_executing_breakpoints_breakpoint.c}

{\stt static void cleanup\_executing\_breakpoints ( void* ignore )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & bpstat\_do\_actions() & breakpoint.c & \cxreffunc{bpstat_do_actions}{breakpoint.c}\\
Refs Var:\ & executing\_breakpoint\_commands & breakpoint.c & \cxrefvar{executing_breakpoint_commands}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function clear\_command()}
\label{func_clear_command_breakpoint.c}

{\stt static void clear\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & decode\_line\_spec() & symtab.c & \cxreffunc{decode_line_spec}{symtab.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & putchar\_unfiltered() & utils.c & \cxreffunc{putchar_unfiltered}{utils.c}\\
\ & section\_is\_overlay() & symfile.c & \cxreffunc{section_is_overlay}{symfile.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ breakpoints\_changed(), strcmp()} &\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & default\_breakpoint\_address & breakpoint.c & \cxrefvar{default_breakpoint_address}{breakpoint.c}\\
\ & default\_breakpoint\_line & breakpoint.c & \cxrefvar{default_breakpoint_line}{breakpoint.c}\\
\ & default\_breakpoint\_symtab & breakpoint.c & \cxrefvar{default_breakpoint_symtab}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function clear\_new\_breakpoint\_list()}
\label{func_clear_new_breakpoint_list_breakpoint.c}

{\stt static void clear\_new\_breakpoint\_list ( struct breakpoint\_list* new\_breakpoints )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & gdb\_breakpoint() & breakpoint.c & \cxreffunc{gdb_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function commands\_command()}
\label{func_commands_command_breakpoint.c}

{\stt static void commands\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_number() & breakpoint.c & \cxreffunc{get_number}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ breakpoint\_modify\_event(), breakpoints\_changed(), free\_command\_lines(), read\_command\_lines()} &\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & executing\_breakpoint\_commands & breakpoint.c & \cxrefvar{executing_breakpoint_commands}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function condition\_command()}
\label{func_condition_command_breakpoint.c}

{\stt static void condition\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & condition\_command\_1() & breakpoint.c & \cxreffunc{condition_command_1}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_number() & breakpoint.c & \cxreffunc{get_number}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ breakpoint\_modify\_event(), breakpoints\_changed(), error\_no\_arg()} &\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function condition\_command\_1()}
\label{func_condition_command_1_breakpoint.c}

{\stt static void condition\_command\_1 ( struct breakpoint* b, const char* condition, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & block\_for\_pc() & block.c & \cxreffunc{block_for_pc}{block.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdb\_parse\_exp\_1() & wrapper.c & \cxreffunc{gdb_parse_exp_1}{wrapper.c}\\
\cxreftabbreak{cxreftabiii}
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & condition\_command() & breakpoint.c & \cxreffunc{condition_command}{breakpoint.c}\\
\ & gdb\_breakpoint() & breakpoint.c & \cxreffunc{gdb_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cover\_target\_enable\_exception\_callback()}
\label{func_cover_target_enable_exception_callback_breakpoint.c}

{\stt static int cover\_target\_enable\_exception\_callback ( void* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function create\_breakpoints()}
\label{func_create_breakpoints_breakpoint.c}

{\stt static void create\_breakpoints ( struct symtabs\_and\_lines sals, char** addr\_string, struct expression** cond, char** cond\_string, char* requested\_shlib, enum bptype type, enum bpdisp disposition, int thread, int ignore\_count, int from\_tty, struct breakpoint* pending\_bp, struct breakpoint\_list** new\_breakpoints )}

\smallskip
\begin{cxreftabiii}
Calls:\ & add\_breakpoint\_to\_new\_list() & breakpoint.c & \cxreffunc{add_breakpoint_to_new_list}{breakpoint.c}\\
\ & block\_for\_pc() & block.c & \cxreffunc{block_for_pc}{block.c}\\
\ & check\_for\_additional\_inlined\_breakpoint\_locations() & inlining.c & \cxreffunc{check_for_additional_inlined_breakpoint_locations}{inlining.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & describe\_other\_breakpoints() & breakpoint.c & \cxreffunc{describe_other_breakpoints}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdb\_parse\_exp\_1() & wrapper.c & \cxreffunc{gdb_parse_exp_1}{wrapper.c}\\
\ & hw\_breakpoint\_used\_count() & breakpoint.c & \cxreffunc{hw_breakpoint_used_count}{breakpoint.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & paddr() & utils.c & \cxreffunc{paddr}{utils.c}\\
\ & remove\_duplicate\_sals() & breakpoint.c & \cxreffunc{remove_duplicate_sals}{breakpoint.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_bp\_objfile() & breakpoint.c & \cxreffunc{set_bp_objfile}{breakpoint.c}\\
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ breakpoint\_resolve\_event(), copy\_command\_lines(), strlen(), xstrdup()} &\\
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_captured\_breakpoint() & breakpoint.c & \cxreffunc{do_captured_breakpoint}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\end{cxreftabiii}


\subsubsection{Local Function create\_fork\_vfork\_event\_catchpoint()}
\label{func_create_fork_vfork_event_catchpoint_breakpoint.c}

{\stt static void create\_fork\_vfork\_event\_catchpoint ( int tempflag, const char* cond\_string, enum bptype bp\_kind )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\ & \cxreftabiiispan{ strlen()} &\\
Called by:\ & create\_fork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_fork_event_catchpoint}{breakpoint.c}\\
\ & create\_vfork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_vfork_event_catchpoint}{breakpoint.c}\\
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function create\_internal\_breakpoint()}
\label{func_create_internal_breakpoint_breakpoint.c}

{\stt static struct breakpoint* create\_internal\_breakpoint ( CORE\_ADDR address, enum bptype type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & find\_pc\_overlay() & symfile.c & \cxreffunc{find_pc_overlay}{symfile.c}\\
\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
Called by:\ & create\_longjmp\_breakpoint() & breakpoint.c & \cxreffunc{create_longjmp_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_objc\_hook\_breakpoint() & breakpoint.c & \cxreffunc{create_objc_hook_breakpoint}{breakpoint.c}\\
\ & create\_overlay\_event\_breakpoint() & breakpoint.c & \cxreffunc{create_overlay_event_breakpoint}{breakpoint.c}\\
\ & create\_solib\_event\_breakpoint() & breakpoint.c & \cxreffunc{create_solib_event_breakpoint}{breakpoint.c}\\
\ & create\_thread\_event\_breakpoint() & breakpoint.c & \cxreffunc{create_thread_event_breakpoint}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function create\_longjmp\_breakpoint()}
\label{func_create_longjmp_breakpoint_breakpoint.c}

{\stt static void create\_longjmp\_breakpoint ( const char* func\_name )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & create\_internal\_breakpoint() & breakpoint.c & \cxreffunc{create_internal_breakpoint}{breakpoint.c}\\
\ & lookup\_minimal\_symbol\_text() & minsyms.c & \cxreffunc{lookup_minimal_symbol_text}{minsyms.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & breakpoint\_re\_set\_all() & breakpoint.c & \cxreffunc{breakpoint_re_set_all}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function create\_overlay\_event\_breakpoint()}
\label{func_create_overlay_event_breakpoint_breakpoint.c}

{\stt static void create\_overlay\_event\_breakpoint ( const char* func\_name )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & create\_internal\_breakpoint() & breakpoint.c & \cxreffunc{create_internal_breakpoint}{breakpoint.c}\\
\ & lookup\_minimal\_symbol\_text() & minsyms.c & \cxreffunc{lookup_minimal_symbol_text}{minsyms.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Called by:\ & update\_breakpoints\_after\_exec() & breakpoint.c & \cxreffunc{update_breakpoints_after_exec}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\ & overlay\_events\_enabled & breakpoint.c & \cxrefvar{overlay_events_enabled}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function current\_exception\_should\_stop()}
\label{func_current_exception_should_stop_breakpoint.c}

{\stt static int current\_exception\_should\_stop ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & re\_comp() & utils.c & \cxreffunc{re_comp}{utils.c}\\
\ & re\_exec() & utils.c & \cxreffunc{re_exec}{utils.c}\\
\ & re\_set\_syntax() & utils.c & \cxreffunc{re_set_syntax}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & \cxreftabiiispan{ strcmp()} &\\
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
Refs Var:\ & current\_exception\_event & breakpoint.c & \cxrefvar{current_exception_event}{breakpoint.c}\\
\ & exception\_catch\_type\_regexp & breakpoint.c & \cxrefvar{exception_catch_type_regexp}{breakpoint.c}\\
\ & exception\_throw\_type\_regexp & breakpoint.c & \cxrefvar{exception_throw_type_regexp}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function describe\_other\_breakpoints()}
\label{func_describe_other_breakpoints_breakpoint.c}

{\stt static void describe\_other\_breakpoints ( CORE\_ADDR pc, asection* section )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & breakpoint\_address\_is\_meaningful() & breakpoint.c & \cxreffunc{breakpoint_address_is_meaningful}{breakpoint.c}\\
\ & deprecated\_print\_address\_numeric() & printcmd.c & \cxreffunc{deprecated_print_address_numeric}{printcmd.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\end{cxreftabiii}


\subsubsection{Local Function disable\_command()}
\label{func_disable_command_breakpoint.c}

{\stt static void disable\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & disable\_breakpoint() & breakpoint.c & \cxreffunc{disable_breakpoint}{breakpoint.c}\\
\ & map\_breakpoint\_numbers() & breakpoint.c & \cxreffunc{map_breakpoint_numbers}{breakpoint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & disable\_breakpoint() & breakpoint.c & \cxreffunc{disable_breakpoint}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function disable\_user\_breakpoints\_before\_operation()}
\label{func_disable_user_breakpoints_before_operation_breakpoint.c}

{\stt static void disable\_user\_breakpoints\_before\_operation ( void )}

\smallskip
\begin{cxreftabiii}
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\ & is\_objc\_exception\_throw\_breakpoint() & objc-lang.c & \cxreffunc{is_objc_exception_throw_breakpoint}{objc-lang.c}\\
Called by:\ & make\_cleanup\_enable\_disable\_bpts\_during\_operation() & breakpoint.c & \cxreffunc{make_cleanup_enable_disable_bpts_during_operation}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_captured\_breakpoint()}
\label{func_do_captured_breakpoint_breakpoint.c}

{\stt static int do\_captured\_breakpoint ( struct ui\_out* uiout, void* data )}

\smallskip
\begin{cxreftabiii}
Calls:\ & block\_for\_pc() & block.c & \cxreffunc{block_for_pc}{block.c}\\
\ & breakpoint\_sals\_to\_pc() & breakpoint.c & \cxreffunc{breakpoint_sals_to_pc}{breakpoint.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & discard\_cleanups() & utils.c & \cxreffunc{discard_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & parse\_breakpoint\_sals() & breakpoint.c & \cxreffunc{parse_breakpoint_sals}{breakpoint.c}\\
\ & parse\_exp\_1() & parse.c & \cxreffunc{parse_exp_1}{parse.c}\\
\ & remove\_duplicates() & breakpoint.c & \cxreffunc{remove_duplicates}{breakpoint.c}\\
\ & xcalloc() & utils.c & \cxreffunc{xcalloc}{utils.c}\\
\ & \cxreftabiiispan{ xstrdup()} &\\
Used in:\ & fsf\_gdb\_breakpoint() & breakpoint.c & \cxreffunc{fsf_gdb_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Func:\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_captured\_breakpoint\_query()}
\label{func_do_captured_breakpoint_query_breakpoint.c}

{\stt static int do\_captured\_breakpoint\_query ( struct ui\_out* uiout, void* data )}

\smallskip
\begin{cxreftabiii}
Calls:\ & print\_one\_breakpoint() & breakpoint.c & \cxreffunc{print_one_breakpoint}{breakpoint.c}\\
Used in:\ & gdb\_breakpoint\_query() & breakpoint.c & \cxreffunc{gdb_breakpoint_query}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_captured\_parse\_breakpoint()}
\label{func_do_captured_parse_breakpoint_breakpoint.c}

{\stt static void do\_captured\_parse\_breakpoint ( struct ui\_out* ui, void* data )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & parse\_breakpoint\_sals() & breakpoint.c & \cxreffunc{parse_breakpoint_sals}{breakpoint.c}\\
Used in:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_delete\_breakpoint\_cleanup()}
\label{func_do_delete_breakpoint_cleanup_breakpoint.c}

{\stt static void do\_delete\_breakpoint\_cleanup ( void* b )}

\smallskip
\begin{cxreftabiii}
Calls:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
Used in:\ & make\_cleanup\_delete\_breakpoint() & breakpoint.c & \cxreffunc{make_cleanup_delete_breakpoint}{breakpoint.c}\\
\ & make\_exec\_cleanup\_delete\_breakpoint() & breakpoint.c & \cxreffunc{make_exec_cleanup_delete_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_enable\_breakpoint()}
\label{func_do_enable_breakpoint_breakpoint.c}

{\stt static void do\_enable\_breakpoint ( struct breakpoint* bpt, enum bpdisp disposition )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\ & check\_duplicates() & breakpoint.c & \cxreffunc{check_duplicates}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_selected\_frame() & frame.c & \cxreffunc{get_selected_frame}{frame.c}\\
\ & hw\_breakpoint\_used\_count() & breakpoint.c & \cxreffunc{hw_breakpoint_used_count}{breakpoint.c}\\
\ & hw\_watchpoint\_used\_count() & breakpoint.c & \cxreffunc{hw_watchpoint_used_count}{breakpoint.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & resolve\_pending\_breakpoint() & breakpoint.c & \cxreffunc{resolve_pending_breakpoint}{breakpoint.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
\ & \cxreftabiiispan{ breakpoint\_modify\_event(), breakpoints\_changed(), deprecated\_modify\_breakpoint\_hook()} &\\
Called by:\ & enable\_breakpoint() & breakpoint.c & \cxreffunc{enable_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & enable\_delete\_breakpoint() & breakpoint.c & \cxreffunc{enable_delete_breakpoint}{breakpoint.c}\\
\ & enable\_once\_breakpoint() & breakpoint.c & \cxreffunc{enable_once_breakpoint}{breakpoint.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & deprecated\_modify\_breakpoint\_hook & top.c & \cxrefvar{deprecated_modify_breakpoint_hook}{top.c}\\
\end{cxreftabiii}


\subsubsection{Local Function do\_restore\_lang\_radix\_cleanup()}
\label{func_do_restore_lang_radix_cleanup_breakpoint.c}

{\stt static void do\_restore\_lang\_radix\_cleanup ( void* old )}

\smallskip
\begin{cxreftabiii}
Calls:\ & set\_language() & language.c & \cxreffunc{set_language}{language.c}\\
Used in:\ & resolve\_pending\_breakpoint() & breakpoint.c & \cxreffunc{resolve_pending_breakpoint}{breakpoint.c}\\
Refs Var:\ & input\_radix & valprint.c & \cxrefvar{input_radix}{valprint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function enable\_command()}
\label{func_enable_command_breakpoint.c}

{\stt static void enable\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & enable\_breakpoint() & breakpoint.c & \cxreffunc{enable_breakpoint}{breakpoint.c}\\
\ & map\_breakpoint\_numbers() & breakpoint.c & \cxreffunc{map_breakpoint_numbers}{breakpoint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & enable\_breakpoint() & breakpoint.c & \cxreffunc{enable_breakpoint}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function enable\_delete\_breakpoint()}
\label{func_enable_delete_breakpoint_breakpoint.c}

{\stt static void enable\_delete\_breakpoint ( struct breakpoint* bpt )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
Used in:\ & enable\_delete\_command() & breakpoint.c & \cxreffunc{enable_delete_command}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function enable\_delete\_command()}
\label{func_enable_delete_command_breakpoint.c}

{\stt static void enable\_delete\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & map\_breakpoint\_numbers() & breakpoint.c & \cxreffunc{map_breakpoint_numbers}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & enable\_delete\_breakpoint() & breakpoint.c & \cxreffunc{enable_delete_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function enable\_once\_breakpoint()}
\label{func_enable_once_breakpoint_breakpoint.c}

{\stt static void enable\_once\_breakpoint ( struct breakpoint* bpt )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
Used in:\ & enable\_once\_command() & breakpoint.c & \cxreffunc{enable_once_command}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function enable\_once\_command()}
\label{func_enable_once_command_breakpoint.c}

{\stt static void enable\_once\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & map\_breakpoint\_numbers() & breakpoint.c & \cxreffunc{map_breakpoint_numbers}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & enable\_once\_breakpoint() & breakpoint.c & \cxreffunc{enable_once_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function ep\_find\_event\_name\_end()}
\label{func_ep_find_event_name_end_breakpoint.c}

{\stt static const char* ep\_find\_event\_name\_end ( const char* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & \cxreftabiiispan{ isalnum()} &\\
Called by:\ & catch\_command\_1() & breakpoint.c & \cxreffunc{catch_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ep\_parse\_optional\_filename()}
\label{func_ep_parse_optional_filename_breakpoint.c}

{\stt static char* ep\_parse\_optional\_filename ( const char** arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & \cxreftabiiispan{ isspace()} &\\
Called by:\ & catch\_load\_command\_1() & breakpoint.c & \cxreffunc{catch_load_command_1}{breakpoint.c}\\
\ & catch\_unload\_command\_1() & breakpoint.c & \cxreffunc{catch_unload_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ep\_parse\_optional\_if\_clause()}
\label{func_ep_parse_optional_if_clause_breakpoint.c}

{\stt static const char* ep\_parse\_optional\_if\_clause ( const char** arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & ep\_skip\_leading\_whitespace() & breakpoint.c & \cxreffunc{ep_skip_leading_whitespace}{breakpoint.c}\\
\ & \cxreftabiiispan{ isspace(), strlen()} &\\
Called by:\ & catch\_exception\_command\_1() & breakpoint.c & \cxreffunc{catch_exception_command_1}{breakpoint.c}\\
\ & catch\_exec\_command\_1() & breakpoint.c & \cxreffunc{catch_exec_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & catch\_fork\_command\_1() & breakpoint.c & \cxreffunc{catch_fork_command_1}{breakpoint.c}\\
\ & catch\_load\_command\_1() & breakpoint.c & \cxreffunc{catch_load_command_1}{breakpoint.c}\\
\ & catch\_unload\_command\_1() & breakpoint.c & \cxreffunc{catch_unload_command_1}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ep\_skip\_leading\_whitespace()}
\label{func_ep_skip_leading_whitespace_breakpoint.c}

{\stt static void ep\_skip\_leading\_whitespace ( const char** s )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & \cxreftabiiispan{ isspace()} &\\
Called by:\ & catch\_exception\_command\_1() & breakpoint.c & \cxreffunc{catch_exception_command_1}{breakpoint.c}\\
\ & catch\_exec\_command\_1() & breakpoint.c & \cxreffunc{catch_exec_command_1}{breakpoint.c}\\
\ & catch\_fork\_command\_1() & breakpoint.c & \cxreffunc{catch_fork_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & catch\_load\_command\_1() & breakpoint.c & \cxreffunc{catch_load_command_1}{breakpoint.c}\\
\ & catch\_unload\_command\_1() & breakpoint.c & \cxreffunc{catch_unload_command_1}{breakpoint.c}\\
\ & ep\_parse\_optional\_if\_clause() & breakpoint.c & \cxreffunc{ep_parse_optional_if_clause}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function free\_valchain()}
\label{func_free_valchain_breakpoint.c}

{\stt static void free\_valchain ( struct bp\_location* b )}

\smallskip
\begin{cxreftabiii}
Calls:\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & value\_next() & value.c & \cxreffunc{value_next}{value.c}\\
Called by:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function get\_number\_trailer()}
\label{func_get_number_trailer_breakpoint.c}

{\stt static int get\_number\_trailer ( const char** pp, int trailer )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & lookup\_internalvar() & value.c & \cxreffunc{lookup_internalvar}{value.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_of\_internalvar() & value.c & \cxreffunc{value_of_internalvar}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strncpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_strncpy\_chk(), atoi(), isalnum(), isspace()} &\\
Called by:\ & get\_number() & breakpoint.c & \cxreffunc{get_number}{breakpoint.c}\\
\ & get\_number\_or\_range() & breakpoint.c & \cxreffunc{get_number_or_range}{breakpoint.c}\\
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function hbreak\_command()}
\label{func_hbreak_command_breakpoint.c}

{\stt static void hbreak\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function hw\_breakpoint\_used\_count()}
\label{func_hw_breakpoint_used_count_breakpoint.c}

{\stt static int hw\_breakpoint\_used\_count ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Called by:\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function hw\_watchpoint\_used\_count()}
\label{func_hw_watchpoint_used_count_breakpoint.c}

{\stt static int hw\_watchpoint\_used\_count ( enum bptype type, int* other\_type\_used )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
Called by:\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function ignore\_command()}
\label{func_ignore_command_breakpoint.c}

{\stt static void ignore\_command ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & get\_number() & breakpoint.c & \cxreffunc{get_number}{breakpoint.c}\\
\ & longest\_to\_int() & valprint.c & \cxreffunc{longest_to_int}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_and\_eval() & eval.c & \cxreffunc{parse_and_eval}{eval.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & set\_ignore\_count() & breakpoint.c & \cxreffunc{set_ignore_count}{breakpoint.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & \cxreftabiiispan{ error\_no\_arg()} &\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function insert\_bp\_location()}
\label{func_insert_bp_location_breakpoint.c}

{\stt static int insert\_bp\_location ( struct bp\_location* bpt, struct ui\_file* tmp\_error\_stream, int* disabled\_breaks, int* process\_warning, int* hw\_breakpoint\_error )}

\smallskip
\begin{cxreftabiii}
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_print\_address\_numeric() & printcmd.c & \cxreffunc{deprecated_print_address_numeric}{printcmd.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & ep\_is\_exception\_catchpoint() & breakpoint.c & \cxreffunc{ep_is_exception_catchpoint}{breakpoint.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & free\_valchain() & breakpoint.c & \cxreffunc{free_valchain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & overlay\_unmapped\_address() & symfile.c & \cxreffunc{overlay_unmapped_address}{symfile.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & safe\_strerror() & utils.c & \cxreffunc{safe_strerror}{utils.c}\\
\ & section\_is\_mapped() & symfile.c & \cxreffunc{section_is_mapped}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & section\_is\_overlay() & symfile.c & \cxreffunc{section_is_overlay}{symfile.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
\ & value\_next() & value.c & \cxreffunc{value_next}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_release\_to\_mark() & value.c & \cxreffunc{value_release_to_mark}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xstrprintf() & utils.c & \cxreffunc{xstrprintf}{utils.c}\\
\ & \cxreftabiiispan{ catch\_errors(), catch\_exception(), exception\_fprintf()} &\\
Called by:\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
Refs Func:\ & cover\_target\_enable\_exception\_callback() & breakpoint.c & \cxreffunc{cover_target_enable_exception_callback}{breakpoint.c}\\
\ & insert\_catchpoint() & breakpoint.c & \cxreffunc{insert_catchpoint}{breakpoint.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_selected\_frame & frame.c & \cxrefvar{deprecated_selected_frame}{frame.c}\\
\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\ & overlay\_events\_enabled & breakpoint.c & \cxrefvar{overlay_events_enabled}{breakpoint.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function insert\_catchpoint()}
\label{func_insert_catchpoint_breakpoint.c}

{\stt static void insert\_catchpoint ( struct ui\_out* uo, void* args )}

\smallskip
\begin{cxreftabiii}
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
Used in:\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\end{cxreftabiii}


\subsubsection{Local Function maintenance\_info\_breakpoints()}
\label{func_maintenance_info_breakpoints_breakpoint.c}

{\stt static void maintenance\_info\_breakpoints ( const char* bnum\_exp, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & breakpoint\_1() & breakpoint.c & \cxreffunc{breakpoint_1}{breakpoint.c}\\
\ & parse\_and\_eval\_long() & eval.c & \cxreffunc{parse_and_eval_long}{eval.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function map\_breakpoint\_numbers()}
\label{func_map_breakpoint_numbers_breakpoint.c}

{\stt static void map\_breakpoint\_numbers ( const char* args, void (*function)(struct breakpoint*) )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & get\_number\_or\_range() & breakpoint.c & \cxreffunc{get_number_or_range}{breakpoint.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ error\_no\_arg()} &\\
Called by:\ & delete\_command() & breakpoint.c & \cxreffunc{delete_command}{breakpoint.c}\\
\ & disable\_command() & breakpoint.c & \cxreffunc{disable_command}{breakpoint.c}\\
\ & enable\_command() & breakpoint.c & \cxreffunc{enable_command}{breakpoint.c}\\
\ & enable\_delete\_command() & breakpoint.c & \cxreffunc{enable_delete_command}{breakpoint.c}\\
\ & enable\_once\_command() & breakpoint.c & \cxreffunc{enable_once_command}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function mention()}
\label{func_mention_breakpoint.c}

{\stt static void mention ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & deprecated\_print\_address\_numeric() & printcmd.c & \cxreffunc{deprecated_print_address_numeric}{printcmd.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & gdb\_print\_expression() & wrapper.c & \cxreffunc{gdb_print_expression}{wrapper.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup\_ui\_out\_stream\_delete() & ui-out.c & \cxreffunc{make_cleanup_ui_out_stream_delete}{ui-out.c}\\
\ & make\_cleanup\_ui\_out\_tuple\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_tuple_begin_end}{ui-out.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & ui\_out\_field\_stream() & ui-out.c & \cxreffunc{ui_out_field_stream}{ui-out.c}\\
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_stream\_new() & ui-out.c & \cxreffunc{ui_out_stream_new}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\ & \cxreftabiiispan{ breakpoint\_create\_event(), deprecated\_create\_breakpoint\_hook()} &\\
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & create\_exception\_catchpoint() & breakpoint.c & \cxreffunc{create_exception_catchpoint}{breakpoint.c}\\
\ & create\_exec\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_exec_event_catchpoint}{breakpoint.c}\\
\ & create\_fork\_vfork\_event\_catchpoint() & breakpoint.c & \cxreffunc{create_fork_vfork_event_catchpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_it\_typical() & breakpoint.c & \cxreffunc{print_it_typical}{breakpoint.c}\\
\ & solib\_load\_unload\_1() & breakpoint.c & \cxreffunc{solib_load_unload_1}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
Refs Var:\ & addressprint & valprint.c & \cxrefvar{addressprint}{valprint.c}\\
\ & deprecated\_create\_breakpoint\_hook & top.c & \cxrefvar{deprecated_create_breakpoint_hook}{top.c}\\
\ & dont\_mention & breakpoint.c & \cxrefvar{dont_mention}{breakpoint.c}\\
\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function parse\_breakpoint\_sals()}
\label{func_parse_breakpoint_sals_breakpoint.c}

{\stt static void parse\_breakpoint\_sals ( const char** address, struct symtabs\_and\_lines* sals, char*** addr\_string, char* requested\_shlib, int* not\_found\_ptr )}

\smallskip
\begin{cxreftabiii}
Calls:\ & decode\_line\_1() & linespec.c & \cxreffunc{decode_line_1}{linespec.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_pc\_overlay() & symfile.c & \cxreffunc{find_pc_overlay}{symfile.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_current\_source\_symtab\_and\_line() & source.c & \cxreffunc{get_current_source_symtab_and_line}{source.c}\\
\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_restrict\_to\_shlib() & objfiles.c & \cxreffunc{make_cleanup_restrict_to_shlib}{objfiles.c}\\
\ & objfile\_get\_first() & objfiles.c & \cxreffunc{objfile_get_first}{objfiles.c}\\
\ & objfile\_get\_next() & objfiles.c & \cxreffunc{objfile_get_next}{objfiles.c}\\
\ & objfile\_set\_load\_state() & objfiles.c & \cxreffunc{objfile_set_load_state}{objfiles.c}\\
\ & paddr\_u() & utils.c & \cxreffunc{paddr_u}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & xcalloc() & utils.c & \cxreffunc{xcalloc}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), isspace(), strchr(), strlen(), strncmp(), throw\_error()} &\\
Called by:\ & do\_captured\_breakpoint() & breakpoint.c & \cxreffunc{do_captured_breakpoint}{breakpoint.c}\\
\ & do\_captured\_parse\_breakpoint() & breakpoint.c & \cxreffunc{do_captured_parse_breakpoint}{breakpoint.c}\\
Refs Func:\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
Refs Var:\ & default\_breakpoint\_address & breakpoint.c & \cxrefvar{default_breakpoint_address}{breakpoint.c}\\
\ & default\_breakpoint\_line & breakpoint.c & \cxrefvar{default_breakpoint_line}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & default\_breakpoint\_symtab & breakpoint.c & \cxrefvar{default_breakpoint_symtab}{breakpoint.c}\\
\ & default\_breakpoint\_valid & breakpoint.c & \cxrefvar{default_breakpoint_valid}{breakpoint.c}\\
\ & pending\_break\_support & breakpoint.c & \cxrefvar{pending_break_support}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function print\_bp\_stop\_message()}
\label{func_print_bp_stop_message_breakpoint.c}

{\stt static enum print\_stop\_action print\_bp\_stop\_message ( bpstat bs )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & print\_it\_typical() & breakpoint.c & \cxreffunc{print_it_typical}{breakpoint.c}\\
Called by:\ & bpstat\_print() & breakpoint.c & \cxreffunc{bpstat_print}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function print\_catch\_info()}
\label{func_print_catch_info_breakpoint.c}

{\stt static void print\_catch\_info ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & ui\_out\_field\_skip() & ui-out.c & \cxreffunc{ui_out_field_skip}{ui-out.c}\\
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
Called by:\ & print\_exception\_catchpoint() & breakpoint.c & \cxreffunc{print_exception_catchpoint}{breakpoint.c}\\
Refs Var:\ & current\_exception\_event & breakpoint.c & \cxrefvar{current_exception_event}{breakpoint.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function print\_exception\_catchpoint()}
\label{func_print_exception_catchpoint_breakpoint.c}

{\stt static enum print\_stop\_action print\_exception\_catchpoint ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & print\_catch\_info() & breakpoint.c & \cxreffunc{print_catch_info}{breakpoint.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_print\_annotation\_string() & ui-out.c & \cxreffunc{ui_out_print_annotation_string}{ui-out.c}\\
\ & \cxreftabiiispan{ annotate\_catchpoint()} &\\
Called by:\ & print\_it\_typical() & breakpoint.c & \cxreffunc{print_it_typical}{breakpoint.c}\\
Used in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Refs Var:\ & current\_exception\_event & breakpoint.c & \cxrefvar{current_exception_event}{breakpoint.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function print\_it\_typical()}
\label{func_print_it_typical_breakpoint.c}

{\stt static enum print\_stop\_action print\_it\_typical ( bpstat bs )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & breakpoint\_adjustment\_warning() & breakpoint.c & \cxreffunc{breakpoint_adjustment_warning}{breakpoint.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & make\_cleanup\_ui\_out\_stream\_delete() & ui-out.c & \cxreffunc{make_cleanup_ui_out_stream_delete}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup\_ui\_out\_tuple\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_tuple_begin_end}{ui-out.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & print\_exception\_catchpoint() & breakpoint.c & \cxreffunc{print_exception_catchpoint}{breakpoint.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & ui\_out\_field\_stream() & ui-out.c & \cxreffunc{ui_out_field_stream}{ui-out.c}\\
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\ & ui\_out\_print\_annotation\_int() & ui-out.c & \cxreffunc{ui_out_print_annotation_int}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_print\_annotation\_string() & ui-out.c & \cxreffunc{ui_out_print_annotation_string}{ui-out.c}\\
\ & ui\_out\_stream\_new() & ui-out.c & \cxreffunc{ui_out_stream_new}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
\ & value\_print() & valprint.c & \cxreffunc{value_print}{valprint.c}\\
\ & \cxreftabiiispan{ annotate\_breakpoint(), annotate\_catchpoint(), annotate\_watchpoint(), async\_reason\_lookup()} &\\
Called by:\ & print\_bp\_stop\_message() & breakpoint.c & \cxreffunc{print_bp_stop_message}{breakpoint.c}\\
Refs Var:\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function print\_mention\_exception\_catchpoint()}
\label{func_print_mention_exception_catchpoint_breakpoint.c}

{\stt static void print\_mention\_exception\_catchpoint ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & \cxreftabiiispan{ strstr()} &\\
Used in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function print\_one\_breakpoint()}
\label{func_print_one_breakpoint_breakpoint.c}

{\stt static void print\_one\_breakpoint ( struct breakpoint* b, CORE\_ADDR* last\_addr )}

\smallskip
\begin{cxreftabiii}
Calls:\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & ep\_is\_catchpoint() & breakpoint.c & \cxreffunc{ep_is_catchpoint}{breakpoint.c}\\
\ & find\_pc\_sect\_function() & blockframe.c & \cxreffunc{find_pc_sect_function}{blockframe.c}\\
\ & frame\_id\_p() & frame.c & \cxreffunc{frame_id_p}{frame.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_print\_expression() & wrapper.c & \cxreffunc{gdb_print_expression}{wrapper.c}\\
\ & gdbarch\_addr\_bit() & gdbarch.c & \cxreffunc{gdbarch_addr_bit}{gdbarch.c}\\
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & make\_cleanup\_ui\_out\_stream\_delete() & ui-out.c & \cxreffunc{make_cleanup_ui_out_stream_delete}{ui-out.c}\\
\ & make\_cleanup\_ui\_out\_tuple\_begin\_end() & ui-out.c & \cxreffunc{make_cleanup_ui_out_tuple_begin_end}{ui-out.c}\\
\ & print\_address\_symbolic() & printcmd.c & \cxreffunc{print_address_symbolic}{printcmd.c}\\
\ & print\_one\_exception\_catchpoint() & breakpoint.c & \cxreffunc{print_one_exception_catchpoint}{breakpoint.c}\\
\ & symbol\_natural\_name() & symtab.c & \cxreffunc{symbol_natural_name}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_field\_core\_addr() & ui-out.c & \cxreffunc{ui_out_field_core_addr}{ui-out.c}\\
\ & ui\_out\_field\_fmt() & ui-out.c & \cxreffunc{ui_out_field_fmt}{ui-out.c}\\
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & ui\_out\_field\_skip() & ui-out.c & \cxreffunc{ui_out_field_skip}{ui-out.c}\\
\ & ui\_out\_field\_stream() & ui-out.c & \cxreffunc{ui_out_field_stream}{ui-out.c}\\
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\ & ui\_out\_is\_mi\_like\_p() & ui-out.c & \cxreffunc{ui_out_is_mi_like_p}{ui-out.c}\\
\ & ui\_out\_spaces() & ui-out.c & \cxreffunc{ui_out_spaces}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_stream\_new() & ui-out.c & \cxreffunc{ui_out_stream_new}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\ & ui\_out\_wrap\_hint() & ui-out.c & \cxreffunc{ui_out_wrap_hint}{ui-out.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcat\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcat\_chk(), \_\_inline\_strcpy\_chk(), annotate\_field(), annotate\_record(), print\_command\_lines()} &\\
Called by:\ & breakpoint\_1() & breakpoint.c & \cxreffunc{breakpoint_1}{breakpoint.c}\\
\ & do\_captured\_breakpoint\_query() & breakpoint.c & \cxreffunc{do_captured_breakpoint_query}{breakpoint.c}\\
Refs Var:\ & addressprint & valprint.c & \cxrefvar{addressprint}{valprint.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & demangle & utils.c & \cxrefvar{demangle}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdb\_null & main.c & \cxrefvar{gdb_null}{main.c}\\
\ & gdb\_stderr & main.c & \cxrefvar{gdb_stderr}{main.c}\\
\ & show\_breakpoint\_hit\_counts & breakpoint.c & \cxrefvar{show_breakpoint_hit_counts}{breakpoint.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function print\_one\_exception\_catchpoint()}
\label{func_print_one_exception_catchpoint_breakpoint.c}

{\stt static void print\_one\_exception\_catchpoint ( struct breakpoint* b, CORE\_ADDR* last\_addr )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & ui\_out\_field\_core\_addr() & ui-out.c & \cxreffunc{ui_out_field_core_addr}{ui-out.c}\\
\ & ui\_out\_field\_string() & ui-out.c & \cxreffunc{ui_out_field_string}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & ui\_out\_spaces() & ui-out.c & \cxreffunc{ui_out_spaces}{ui-out.c}\\
\ & \cxreftabiiispan{ annotate\_field()} &\\
Called by:\ & print\_one\_breakpoint() & breakpoint.c & \cxreffunc{print_one_breakpoint}{breakpoint.c}\\
Used in:\ & breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Refs Var:\ & addressprint & valprint.c & \cxrefvar{addressprint}{valprint.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remove\_breakpoint()}
\label{func_remove_breakpoint_breakpoint.c}

{\stt static int remove\_breakpoint ( struct bp\_location* b, insertion\_state\_t is )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & breakpoint\_enabled() & breakpoint.c & \cxreffunc{breakpoint_enabled}{breakpoint.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & ep\_is\_exception\_catchpoint() & breakpoint.c & \cxreffunc{ep_is_exception_catchpoint}{breakpoint.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & overlay\_unmapped\_address() & symfile.c & \cxreffunc{overlay_unmapped_address}{symfile.c}\\
\ & ptid\_get\_pid() & infrun.c & \cxreffunc{ptid_get_pid}{infrun.c}\\
\ & section\_is\_overlay() & symfile.c & \cxreffunc{section_is_overlay}{symfile.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_next() & value.c & \cxreffunc{value_next}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & detach\_breakpoints() & breakpoint.c & \cxreffunc{detach_breakpoints}{breakpoint.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & reattach\_breakpoints() & breakpoint.c & \cxreffunc{reattach_breakpoints}{breakpoint.c}\\
\ & remove\_breakpoints() & breakpoint.c & \cxreffunc{remove_breakpoints}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & remove\_hw\_watchpoints() & breakpoint.c & \cxreffunc{remove_hw_watchpoints}{breakpoint.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & inferior\_ptid & infcmd.c & \cxrefvar{inferior_ptid}{infcmd.c}\\
\ & overlay\_debugging & symfile.c & \cxrefvar{overlay_debugging}{symfile.c}\\
\ & overlay\_events\_enabled & breakpoint.c & \cxrefvar{overlay_events_enabled}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remove\_duplicates()}
\label{func_remove_duplicates_breakpoint.c}

{\stt static void remove\_duplicates ( struct symtabs\_and\_lines* sals )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & do\_captured\_breakpoint() & breakpoint.c & \cxreffunc{do_captured_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function remove\_non\_msymbol\_sals()}
\label{func_remove_non_msymbol_sals_breakpoint.c}

{\stt static void remove\_non\_msymbol\_sals ( struct symtabs\_and\_lines* sals )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function resolve\_pending\_breakpoint()}
\label{func_resolve_pending_breakpoint_breakpoint.c}

{\stt static int resolve\_pending\_breakpoint ( struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Calls:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & find\_objfile\_by\_name() & objfiles.c & \cxreffunc{find_objfile_by_name}{objfiles.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & set\_language() & language.c & \cxreffunc{set_language}{language.c}\\
Called by:\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
Used in:\ & re\_enable\_breakpoints\_in\_shlibs() & breakpoint.c & \cxreffunc{re_enable_breakpoints_in_shlibs}{breakpoint.c}\\
Refs Func:\ & do\_restore\_lang\_radix\_cleanup() & breakpoint.c & \cxreffunc{do_restore_lang_radix_cleanup}{breakpoint.c}\\
Refs Var:\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\ & input\_radix & valprint.c & \cxrefvar{input_radix}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function restore\_saved\_pending\_break\_support()}
\label{func_restore_saved_pending_break_support_breakpoint.c}

{\stt static void restore\_saved\_pending\_break\_support ( void* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Used in:\ & future\_break\_command() & breakpoint.c & \cxreffunc{future_break_command}{breakpoint.c}\\
\ & gdb\_breakpoint() & breakpoint.c & \cxreffunc{gdb_breakpoint}{breakpoint.c}\\
\ & rbr\_break\_command() & breakpoint.c & \cxreffunc{rbr_break_command}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & pending\_break\_support & breakpoint.c & \cxrefvar{pending_break_support}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function restrict\_search\_cleanup()}
\label{func_restrict_search_cleanup_breakpoint.c}

{\stt static void restrict\_search\_cleanup ( void* ignored )}

\smallskip
\begin{cxreftabiii}
Calls:\ & objfile\_clear\_restrict\_list() & objfiles.c & \cxreffunc{objfile_clear_restrict_list}{objfiles.c}\\
\ & objfile\_restrict\_search() & objfiles.c & \cxreffunc{objfile_restrict_search}{objfiles.c}\\
Used in:\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function rwatch\_command()}
\label{func_rwatch_command_breakpoint.c}

{\stt static void rwatch\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & detect\_location\_arg() & breakpoint.c & \cxreffunc{detect_location_arg}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function safe\_breakpoint\_sals\_to\_pc()}
\label{func_safe_breakpoint_sals_to_pc_breakpoint.c}

{\stt static int safe\_breakpoint\_sals\_to\_pc ( struct symtabs\_and\_lines* sals, const char* address )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & \cxreftabiiispan{ catch\_errors()} &\\
Called by:\ & break\_command\_2() & breakpoint.c & \cxreffunc{break_command_2}{breakpoint.c}\\
Refs Func:\ & wrap\_breakpoint\_sals\_to\_pc() & breakpoint.c & \cxreffunc{wrap_breakpoint_sals_to_pc}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function save\_breakpoints\_command()}
\label{func_save_breakpoints_command_breakpoint.c}

{\stt static void save\_breakpoints\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Calls:\ & cli\_out\_new() & cli-out.c & \cxreffunc{cli_out_new}{cli-out.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\ & dont\_repeat() & top.c & \cxreffunc{dont_repeat}{top.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & fputc\_unfiltered() & utils.c & \cxreffunc{fputc_unfiltered}{utils.c}\\
\ & fputs\_unfiltered() & ui-file.c & \cxreffunc{fputs_unfiltered}{ui-file.c}\\
\ & gdb\_fopen() & ui-file.c & \cxreffunc{gdb_fopen}{ui-file.c}\\
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & make\_cleanup\_freeargv() & utils.c & \cxreffunc{make_cleanup_freeargv}{utils.c}\\
\ & make\_cleanup\_ui\_file\_delete() & utils.c & \cxreffunc{make_cleanup_ui_file_delete}{utils.c}\\
\ & make\_cleanup\_ui\_out\_delete() & utils.c & \cxreffunc{make_cleanup_ui_out_delete}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & nomem() & utils.c & \cxreffunc{nomem}{utils.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & safe\_strerror() & utils.c & \cxreffunc{safe_strerror}{utils.c}\\
\ & write\_one\_breakpoint() & breakpoint.c & \cxreffunc{write_one_breakpoint}{breakpoint.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_error(), \_\_inline\_strcpy\_chk(), buildargv(), localtime(), setlocale(), strftime(), strlen(), tilde\_expand(), time()} &\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
Refs Func:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function set\_bp\_objfile()}
\label{func_set_bp_objfile_breakpoint.c}

{\stt static void set\_bp\_objfile ( struct breakpoint* b, struct symtab\_and\_line* sal )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & find\_pc\_sect\_section() & objfiles.c & \cxreffunc{find_pc_sect_section}{objfiles.c}\\
\ & find\_pc\_section() & objfiles.c & \cxreffunc{find_pc_section}{objfiles.c}\\
Called by:\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_breakpoints() & breakpoint.c & \cxreffunc{create_breakpoints}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function set\_breakpoint\_cmd()}
\label{func_set_breakpoint_cmd_breakpoint.c}

{\stt static void set\_breakpoint\_cmd ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_breakpoint\_cmd()}
\label{func_show_breakpoint_cmd_breakpoint.c}

{\stt static void show\_breakpoint\_cmd ( const char* args, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_can\_use\_hw\_watchpoints()}
\label{func_show_can_use_hw_watchpoints_breakpoint.c}

{\stt static void show\_can\_use\_hw\_watchpoints ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_pending\_break\_support()}
\label{func_show_pending_break_support_breakpoint.c}

{\stt static void show\_pending\_break\_support ( struct ui\_file* file, int from\_tty, struct cmd\_list\_element* c, const char* value )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_filtered() & utils.c & \cxreffunc{fprintf_filtered}{utils.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function solib\_load\_unload\_1()}
\label{func_solib_load_unload_1_breakpoint.c}

{\stt static void solib\_load\_unload\_1 ( const char* hookname, int tempflag, char* dll\_pathname, char* cond\_string, enum bptype bp\_kind )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & decode\_line\_1() & linespec.c & \cxreffunc{decode_line_1}{linespec.c}\\
\ & discard\_cleanups() & utils.c & \cxreffunc{discard_cleanups}{utils.c}\\
\ & do\_cleanups() & utils.c & \cxreffunc{do_cleanups}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_cleanup() & utils.c & \cxreffunc{make_cleanup}{utils.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & resolve\_sal\_pc() & breakpoint.c & \cxreffunc{resolve_sal_pc}{breakpoint.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcpy\_chk(), strlen()} &\\
Called by:\ & create\_solib\_load\_event\_breakpoint() & breakpoint.c & \cxreffunc{create_solib_load_event_breakpoint}{breakpoint.c}\\
\ & create\_solib\_unload\_event\_breakpoint() & breakpoint.c & \cxreffunc{create_solib_unload_event_breakpoint}{breakpoint.c}\\
Refs Func:\ & null\_cleanup() & utils.c & \cxreffunc{null_cleanup}{utils.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function stop\_command()}
\label{func_stop_command_breakpoint.c}

{\stt static void stop\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function stopat\_command()}
\label{func_stopat_command_breakpoint.c}

{\stt static void stopat\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & \cxreftabiiispan{ isdigit()} &\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function stopin\_command()}
\label{func_stopin_command_breakpoint.c}

{\stt static void stopin\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & \cxreftabiiispan{ isdigit()} &\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function tcatch\_command()}
\label{func_tcatch_command_breakpoint.c}

{\stt static void tcatch\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & catch\_command\_1() & breakpoint.c & \cxreffunc{catch_command_1}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function tell\_breakpoints\_objfile\_changed\_internal()}
\label{func_tell_breakpoints_objfile_changed_internal_breakpoint.c}

{\stt static void tell\_breakpoints\_objfile\_changed\_internal ( struct objfile* objfile, int set\_pending )}

\smallskip
\begin{cxreftabiii}
Calls:\ & bundle\_basename() & utils.c & \cxreffunc{bundle_basename}{utils.c}\\
\ & \cxreftabiiispan{ lbasename(), xstrdup()} &\\
Called by:\ & tell\_breakpoints\_objfile\_changed() & breakpoint.c & \cxreffunc{tell_breakpoints_objfile_changed}{breakpoint.c}\\
\ & tell\_breakpoints\_objfile\_removed() & breakpoint.c & \cxreffunc{tell_breakpoints_objfile_removed}{breakpoint.c}\\
Refs Var:\ & breakpoint\_chain & breakpoint.c & \cxrefvar{breakpoint_chain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_generation & breakpoint.c & \cxrefvar{breakpoint_generation}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function thbreak\_command()}
\label{func_thbreak_command_breakpoint.c}

{\stt static void thbreak\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & break\_command\_1() & breakpoint.c & \cxreffunc{break_command_1}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function until\_break\_command\_continuation()}
\label{func_until_break_command_continuation_breakpoint.c}

{\stt static void until\_break\_command\_continuation ( struct continuation\_arg* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & do\_exec\_cleanups() & utils.c & \cxreffunc{do_exec_cleanups}{utils.c}\\
Used in:\ & until\_break\_command() & breakpoint.c & \cxreffunc{until_break_command}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function user\_settable\_breakpoint()}
\label{func_user_settable_breakpoint_breakpoint.c}

{\stt static int user\_settable\_breakpoint ( const struct breakpoint* b )}

\smallskip
\begin{cxreftabiii}
Called by:\ & breakpoint\_1() & breakpoint.c & \cxreffunc{breakpoint_1}{breakpoint.c}\\
\ & breakpoint\_re\_set\_all() & breakpoint.c & \cxreffunc{breakpoint_re_set_all}{breakpoint.c}\\
\ & breakpoint\_update() & breakpoint.c & \cxreffunc{breakpoint_update}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function watch\_command()}
\label{func_watch_command_breakpoint.c}

{\stt static void watch\_command ( const char* arg, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & detect\_location\_arg() & breakpoint.c & \cxreffunc{detect_location_arg}{breakpoint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
Used in:\ & \_initialize\_breakpoint() & breakpoint.c & \cxreffunc{_initialize_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function watch\_command\_1()}
\label{func_watch_command_1_breakpoint.c}

{\stt static void watch\_command\_1 ( const char* arg, int accessflag, int by\_location, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & adjust\_breakpoint\_address() & breakpoint.c & \cxreffunc{adjust_breakpoint_address}{breakpoint.c}\\
\ & block\_innermost\_frame() & blockframe.c & \cxreffunc{block_innermost_frame}{blockframe.c}\\
\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & create\_internal\_breakpoint() & breakpoint.c & \cxreffunc{create_internal_breakpoint}{breakpoint.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & get\_frame\_id() & frame.c & \cxreffunc{get_frame_id}{frame.c}\\
\ & get\_frame\_pc() & frame.c & \cxreffunc{get_frame_pc}{frame.c}\\
\ & get\_prev\_frame() & frame.c & \cxreffunc{get_prev_frame}{frame.c}\\
\ & hw\_watchpoint\_used\_count() & breakpoint.c & \cxreffunc{hw_watchpoint_used_count}{breakpoint.c}\\
\ & init\_sal() & symtab.c & \cxreffunc{init_sal}{symtab.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & mention() & breakpoint.c & \cxreffunc{mention}{breakpoint.c}\\
\ & paddr\_nz() & utils.c & \cxreffunc{paddr_nz}{utils.c}\\
\ & parse\_exp\_1() & parse.c & \cxreffunc{parse_exp_1}{parse.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & savestring() & utils.c & \cxreffunc{savestring}{utils.c}\\
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_raw\_breakpoint() & breakpoint.c & \cxreffunc{set_raw_breakpoint}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & type\_sprint\_quoted() & typeprint.c & \cxreffunc{type_sprint_quoted}{typeprint.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), strlen(), strncmp()} &\\
Called by:\ & awatch\_command() & breakpoint.c & \cxreffunc{awatch_command}{breakpoint.c}\\
\ & awatch\_command\_wrapper() & breakpoint.c & \cxreffunc{awatch_command_wrapper}{breakpoint.c}\\
\ & rwatch\_command() & breakpoint.c & \cxreffunc{rwatch_command}{breakpoint.c}\\
\ & rwatch\_command\_wrapper() & breakpoint.c & \cxreffunc{rwatch_command_wrapper}{breakpoint.c}\\
\ & watch\_command() & breakpoint.c & \cxreffunc{watch_command}{breakpoint.c}\\
\ & watch\_command\_wrapper() & breakpoint.c & \cxreffunc{watch_command_wrapper}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & breakpoint\_count & breakpoint.c & \cxrefvar{breakpoint_count}{breakpoint.c}\\
\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & innermost\_block & parse.c & \cxrefvar{innermost_block}{parse.c}\\
\end{cxreftabiii}


\subsubsection{Local Function watchpoint\_check()}
\label{func_watchpoint_check_breakpoint.c}

{\stt static int watchpoint\_check ( void* p )}

\smallskip
\begin{cxreftabiii}
Prototype:& breakpoint.c & \ & \cxreffile{breakpoint.c}\\
Calls:\ & evaluate\_expression() & eval.c & \cxreffunc{evaluate_expression}{eval.c}\\
\ & frame\_find\_by\_id() & frame.c & \cxreffunc{frame_find_by_id}{frame.c}\\
\ & gdbarch\_in\_function\_epilogue\_p() & gdbarch.c & \cxreffunc{gdbarch_in_function_epilogue_p}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_current\_frame() & frame.c & \cxreffunc{get_current_frame}{frame.c}\\
\ & read\_pc() & regcache.c & \cxreffunc{read_pc}{regcache.c}\\
\ & reinit\_frame\_cache() & frame.c & \cxreffunc{reinit_frame_cache}{frame.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & select\_frame() & frame.c & \cxreffunc{select_frame}{frame.c}\\
\ & ui\_out\_field\_int() & ui-out.c & \cxreffunc{ui_out_field_int}{ui-out.c}\\
\ & ui\_out\_print\_annotation\_string() & ui-out.c & \cxreffunc{ui_out_print_annotation_string}{ui-out.c}\\
\ & ui\_out\_text() & ui-out.c & \cxreffunc{ui_out_text}{ui-out.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_mark() & value.c & \cxreffunc{value_mark}{value.c}\\
\ & watchpoint\_equal() & breakpoint.c & \cxreffunc{watchpoint_equal}{breakpoint.c}\\
\ & \cxreftabiiispan{ async\_reason\_lookup()} &\\
Used in:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & uiout & ui-out.c & \cxrefvar{uiout}{ui-out.c}\\
\end{cxreftabiii}


\subsubsection{Local Function watchpoint\_equal()}
\label{func_watchpoint_equal_breakpoint.c}

{\stt static int watchpoint\_equal ( struct value* arg1, struct value* arg2 )}

\smallskip
\begin{cxreftabiii}
Calls:\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & watchpoint\_check() & breakpoint.c & \cxreffunc{watchpoint_check}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function wrap\_breakpoint\_sals\_to\_pc()}
\label{func_wrap_breakpoint_sals_to_pc_breakpoint.c}

{\stt static int wrap\_breakpoint\_sals\_to\_pc ( char* a )}

\smallskip
\begin{cxreftabiii}
Calls:\ & breakpoint\_sals\_to\_pc() & breakpoint.c & \cxreffunc{breakpoint_sals_to_pc}{breakpoint.c}\\
Used in:\ & safe\_breakpoint\_sals\_to\_pc() & breakpoint.c & \cxreffunc{safe_breakpoint_sals_to_pc}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function write\_one\_breakpoint()}
\label{func_write_one_breakpoint_breakpoint.c}

{\stt static void write\_one\_breakpoint ( struct breakpoint* b, struct ui\_file* stream, struct ui\_out* uiout )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fprintf\_unfiltered() & utils.c & \cxreffunc{fprintf_unfiltered}{utils.c}\\
\ & fputc\_unfiltered() & utils.c & \cxreffunc{fputc_unfiltered}{utils.c}\\
\ & fputs\_unfiltered() & ui-file.c & \cxreffunc{fputs_unfiltered}{ui-file.c}\\
\ & hex\_string\_custom() & utils.c & \cxreffunc{hex_string_custom}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & \cxreftabiiispan{ print\_command\_lines(), strlen()} &\\
Called by:\ & save\_breakpoints\_command() & breakpoint.c & \cxreffunc{save_breakpoints_command}{breakpoint.c}\\
\end{cxreftabiii}

