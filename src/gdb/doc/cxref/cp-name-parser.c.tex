% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF cp-name-parser.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File cp-name-parser.c}{File cp-name-parser.c}
\section{File cp-name-parser.c}
\label{file_cp-name-parser.c}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include <stdio.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <stdlib.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <unistd.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/safe-ctype.h"} &\cxreffile{../include/safe-ctype.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/demangle.h"} &\cxreffile{../include/demangle.h}\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include <stdio.h>} &\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define YYBISON 1}

\medskip
{\stt \#define YYBISON\_VERSION "3.3.2"}

\medskip
{\stt \#define YYSKELETON\_NAME "yacc.c"}

\medskip
{\stt \#define YYPURE 0}

\medskip
{\stt \#define YYPUSH 0}

\medskip
{\stt \#define YYPULL 1}

\medskip
{\stt \#define HAVE\_DECL\_BASENAME 0}

\medskip
{\stt \#define d\_grab}

\medskip
{\stt \#define QUAL\_CONST 1}

\medskip
{\stt \#define QUAL\_RESTRICT 2}

\medskip
{\stt \#define QUAL\_VOLATILE 4}

\medskip
{\stt \#define INT\_CHAR}

\medskip
{\stt \#define INT\_SHORT}

\medskip
{\stt \#define INT\_LONG}

\medskip
{\stt \#define INT\_LLONG}

\medskip
{\stt \#define INT\_SIGNED}

\medskip
{\stt \#define INT\_UNSIGNED}

\medskip
{\stt \#define yymaxdepth cpname\_maxdepth}

\medskip
{\stt \#define yyparse cpname\_parse}

\medskip
{\stt \#define yylex cpname\_lex}

\medskip
{\stt \#define yyerror cpname\_error}

\medskip
{\stt \#define yylval cpname\_lval}

\medskip
{\stt \#define yychar cpname\_char}

\medskip
{\stt \#define yydebug cpname\_debug}

\medskip
{\stt \#define yypact cpname\_pact}

\medskip
{\stt \#define yyr1 cpname\_r1}

\medskip
{\stt \#define yyr2 cpname\_r2}

\medskip
{\stt \#define yydef cpname\_def}

\medskip
{\stt \#define yychk cpname\_chk}

\medskip
{\stt \#define yypgo cpname\_pgo}

\medskip
{\stt \#define yyact cpname\_act}

\medskip
{\stt \#define yyexca cpname\_exca}

\medskip
{\stt \#define yyerrflag cpname\_errflag}

\medskip
{\stt \#define yynerrs cpname\_nerrs}

\medskip
{\stt \#define yyps cpname\_ps}

\medskip
{\stt \#define yypv cpname\_pv}

\medskip
{\stt \#define yys cpname\_s}

\medskip
{\stt \#define yy\_yys cpname\_yys}

\medskip
{\stt \#define yystate cpname\_state}

\medskip
{\stt \#define yytmp cpname\_tmp}

\medskip
{\stt \#define yyv cpname\_v}

\medskip
{\stt \#define yy\_yyv cpname\_yyv}

\medskip
{\stt \#define yyval cpname\_val}

\medskip
{\stt \#define yylloc cpname\_lloc}

\medskip
{\stt \#define yyreds cpname\_reds}

\medskip
{\stt \#define yytoks cpname\_toks}

\medskip
{\stt \#define yyname cpname\_name}

\medskip
{\stt \#define yyrule cpname\_rule}

\medskip
{\stt \#define yylhs cpname\_yylhs}

\medskip
{\stt \#define yylen cpname\_yylen}

\medskip
{\stt \#define yydefred cpname\_yydefred}

\medskip
{\stt \#define yydgoto cpname\_yydgoto}

\medskip
{\stt \#define yysindex cpname\_yysindex}

\medskip
{\stt \#define yyrindex cpname\_yyrindex}

\medskip
{\stt \#define yygindex cpname\_yygindex}

\medskip
{\stt \#define yytable cpname\_yytable}

\medskip
{\stt \#define yycheck cpname\_yycheck}

\medskip
{\stt \#define d\_left( dc )}

\medskip
{\stt \#define d\_right( dc )}

\medskip
{\stt \#define YY\_NULLPTR}

\medskip
{\stt \#define YYERROR\_VERBOSE 0}

\medskip
{\stt \#define YY\_YY\_Y\_TAB\_H\_INCLUDED}

\medskip
{\stt \#define YYDEBUG 1}

\medskip
{\stt \#define YYTOKENTYPE}

\medskip
{\stt \#define YYSTYPE\_IS\_TRIVIAL 1}

\medskip
{\stt \#define YYSTYPE\_IS\_DECLARED 1}

\medskip
{\stt \#define YYSIZE\_T \_\_SIZE\_TYPE\_\_}

\medskip
{\stt \#define YYSIZE\_MAXIMUM}

\medskip
{\stt \#define YY\_( Msgid )}

\medskip
{\stt \#define YY\_ATTRIBUTE( Spec )}

\medskip
{\stt \#define YY\_ATTRIBUTE\_PURE}

\medskip
{\stt \#define YY\_ATTRIBUTE\_UNUSED}

\medskip
{\stt \#define YYUSE( E )}

\medskip
{\stt \#define YY\_INITIAL\_VALUE( Value )}

\medskip
{\stt \#define YY\_IGNORE\_MAYBE\_UNINITIALIZED\_BEGIN}

\medskip
{\stt \#define YY\_IGNORE\_MAYBE\_UNINITIALIZED\_END}

\medskip
{\stt \#define YYSTACK\_ALLOC YYMALLOC}

\medskip
{\stt \#define YYSTACK\_FREE YYFREE}

\medskip
{\stt \#define YYSTACK\_ALLOC\_MAXIMUM YYSIZE\_MAXIMUM}

\medskip
{\stt \#define YYMALLOC xmalloc}

\medskip
{\stt \#define YYFREE xfree}

\medskip
{\stt \#define YYSTACK\_GAP\_MAXIMUM}

\medskip
{\stt \#define YYSTACK\_BYTES( N )}

\medskip
{\stt \#define YYCOPY\_NEEDED 1}

\medskip
{\stt \#define YYSTACK\_RELOCATE( Stack\_alloc, Stack )}

\medskip
{\stt \#define YYCOPY( Dst, Src, Count )}

\medskip
{\stt \#define YYFINAL 85}

\medskip
{\stt \#define YYLAST 1165}

\medskip
{\stt \#define YYNTOKENS 76}

\medskip
{\stt \#define YYNNTS 40}

\medskip
{\stt \#define YYNRULES 195}

\medskip
{\stt \#define YYNSTATES 330}

\medskip
{\stt \#define YYUNDEFTOK 2}

\medskip
{\stt \#define YYMAXUTOK 308}

\medskip
{\stt \#define YYTRANSLATE( YYX )}

\medskip
{\stt \#define YYPACT\_NINF -204}

\medskip
{\stt \#define yypact\_value\_is\_default( Yystate )}

\medskip
{\stt \#define YYTABLE\_NINF -1}

\medskip
{\stt \#define yytable\_value\_is\_error( Yytable\_value )}

\medskip
{\stt \#define yyerrok}

\medskip
{\stt \#define yyclearin}

\medskip
{\stt \#define YYEMPTY -2}

\medskip
{\stt \#define YYEOF 0}

\medskip
{\stt \#define YYACCEPT}

\medskip
{\stt \#define YYABORT}

\medskip
{\stt \#define YYERROR}

\medskip
{\stt \#define YYRECOVERING}

\medskip
{\stt \#define YYBACKUP( Token, Value )}

\medskip
{\stt \#define YYTERROR 1}

\medskip
{\stt \#define YYERRCODE 256}

\medskip
{\stt \#define YYFPRINTF fprintf}

\medskip
{\stt \#define YYDPRINTF( Args )}

\medskip
{\stt \#define YY\_LOCATION\_PRINT( File, Loc )}

\medskip
{\stt \#define YY\_SYMBOL\_PRINT( Title, Type, Value, Location )}

\medskip
{\stt \#define YY\_STACK\_PRINT( Bottom, Top )}

\medskip
{\stt \#define YY\_REDUCE\_PRINT( Rule )}

\medskip
{\stt \#define YYINITDEPTH 200}

\medskip
{\stt \#define YYMAXDEPTH 10000}

\medskip
{\stt \#define YYPOPSTACK( N )}

\medskip
{\stt \#define HANDLE\_QUAL( TYPE, MTYPE, QUAL )}

\medskip
{\stt \#define HANDLE\_SPECIAL( string, comp )}

\medskip
{\stt \#define HANDLE\_TOKEN2( string, token )}

\medskip
{\stt \#define HANDLE\_TOKEN3( string, token )}


\subsection{Type definitions}


\subsubsection{Type struct demangle\_info}
\label{type_struct_demangle_info_cp-name-parser.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct demangle\_info} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt int used;} &\\
\hspace*{0.2in}{\stt struct demangle\_component comps[1];} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type enum yytokentype}
\label{type_enum_yytokentype_cp-name-parser.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum yytokentype} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt INT;} &\\
\hspace*{0.2in}{\stt FLOAT;} &\\
\hspace*{0.2in}{\stt NAME;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt STRUCT;} &\\
\hspace*{0.2in}{\stt CLASS;} &\\
\hspace*{0.2in}{\stt UNION;} &\\
\hspace*{0.2in}{\stt ENUM;} &\\
\hspace*{0.2in}{\stt SIZEOF;} &\\
\hspace*{0.2in}{\stt UNSIGNED;} &\\
\hspace*{0.2in}{\stt COLONCOLON;} &\\
\hspace*{0.2in}{\stt TEMPLATE;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt ERROR;} &\\
\hspace*{0.2in}{\stt NEW;} &\\
\hspace*{0.2in}{\stt DELETE;} &\\
\hspace*{0.2in}{\stt OPERATOR;} &\\
\hspace*{0.2in}{\stt STATIC\_CAST;} &\\
\hspace*{0.2in}{\stt REINTERPRET\_CAST;} &\\
\hspace*{0.2in}{\stt DYNAMIC\_CAST;} &\\
\hspace*{0.2in}{\stt SIGNED\_KEYWORD;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt LONG;} &\\
\hspace*{0.2in}{\stt SHORT;} &\\
\hspace*{0.2in}{\stt INT\_KEYWORD;} &\\
\hspace*{0.2in}{\stt CONST\_KEYWORD;} &\\
\hspace*{0.2in}{\stt VOLATILE\_KEYWORD;} &\\
\hspace*{0.2in}{\stt DOUBLE\_KEYWORD;} &\\
\hspace*{0.2in}{\stt BOOL;} &\\
\hspace*{0.2in}{\stt ELLIPSIS;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt RESTRICT;} &\\
\hspace*{0.2in}{\stt VOID;} &\\
\hspace*{0.2in}{\stt FLOAT\_KEYWORD;} &\\
\hspace*{0.2in}{\stt CHAR;} &\\
\hspace*{0.2in}{\stt WCHAR\_T;} &\\
\hspace*{0.2in}{\stt ASSIGN\_MODIFY;} &\\
\hspace*{0.2in}{\stt TRUEKEYWORD;} &\\
\hspace*{0.2in}{\stt FALSEKEYWORD;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt DEMANGLER\_SPECIAL;} &\\
\hspace*{0.2in}{\stt CONSTRUCTION\_VTABLE;} &\\
\hspace*{0.2in}{\stt CONSTRUCTION\_IN;} &\\
\hspace*{0.2in}{\stt GLOBAL;} &\\
\hspace*{0.2in}{\stt OROR;} &\\
\hspace*{0.2in}{\stt ANDAND;} &\\
\hspace*{0.2in}{\stt EQUAL;} &\\
\hspace*{0.2in}{\stt NOTEQUAL;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt LEQ;} &\\
\hspace*{0.2in}{\stt GEQ;} &\\
\hspace*{0.2in}{\stt LSH;} &\\
\hspace*{0.2in}{\stt RSH;} &\\
\hspace*{0.2in}{\stt UNARY;} &\\
\hspace*{0.2in}{\stt INCREMENT;} &\\
\hspace*{0.2in}{\stt DECREMENT;} &\\
\hspace*{0.2in}{\stt ARROW;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct nested}
\label{type_struct_nested_cp-name-parser.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct nested} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct demangle\_component* comp;} &\\
\hspace*{0.2in}{\stt struct demangle\_component** last;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type union YYSTYPE}
\label{type_union_YYSTYPE_cp-name-parser.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt union YYSTYPE} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct demangle\_component* comp;} &\\
\hspace*{0.2in}{\stt struct nested} &\\
\hspace*{0.3in}{\stt \{} &\\
\hspace*{0.4in}{\stt struct demangle\_component* comp;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.4in}{\stt struct demangle\_component** last;} &\\
\hspace*{0.3in}{\stt \}} &\\
\hspace*{0.3in}{\stt nested;} &\\
\hspace*{0.2in}{\stt struct} &\\
\hspace*{0.3in}{\stt \{} &\\
\hspace*{0.4in}{\stt struct demangle\_component* comp;} &\\
\hspace*{0.4in}{\stt struct demangle\_component* last;} &\\
\hspace*{0.3in}{\stt \}} &\\
\hspace*{0.3in}{\stt nested1;} &\\
\hspace*{0.2in}{\stt struct} &\\
\hspace*{0.3in}{\stt \{} &\\
\hspace*{0.4in}{\stt struct demangle\_component* comp;} &\\
\hspace*{0.4in}{\stt struct demangle\_component** last;} &\\
\hspace*{0.4in}{\stt struct nested fn;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.4in}{\stt struct demangle\_component* start;} &\\
\hspace*{0.4in}{\stt int fold\_flag;} &\\
\hspace*{0.3in}{\stt \}} &\\
\hspace*{0.3in}{\stt abstract;} &\\
\hspace*{0.2in}{\stt int lval;} &\\
\hspace*{0.2in}{\stt struct} &\\
\hspace*{0.3in}{\stt \{} &\\
\hspace*{0.4in}{\stt int val;} &\\
\hspace*{0.4in}{\stt struct demangle\_component* type;} &\\
\hspace*{0.3in}{\stt \}} &\\
\hspace*{0.3in}{\stt typed\_val\_int;} &\\
\hspace*{0.2in}{\stt const char* opname;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef YYSTYPE}
\label{type_YYSTYPE_cp-name-parser.c}

{\stt typedef union YYSTYPE YYSTYPE}

\smallskip
\begin{cxreftabii}
See:& Type union YYSTYPE & \cxreftype{union_YYSTYPE}{cp-name-parser.c}\\
\end{cxreftabii}


\subsubsection{Type enum demangle\_component\_type\_extensions}
\label{type_enum_demangle_component_type_extensions_cp-name-parser.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt enum demangle\_component\_type\_extensions} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt GLOBAL\_CONSTRUCTORS;} &\\
\hspace*{0.2in}{\stt GLOBAL\_DESTRUCTORS;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Typedef yytype\_uint8}
\label{type_yytype_uint8_cp-name-parser.c}

{\stt typedef unsigned char yytype\_uint8}


\subsubsection{Typedef yytype\_int8}
\label{type_yytype_int8_cp-name-parser.c}

{\stt typedef signed char yytype\_int8}


\subsubsection{Typedef yytype\_uint16}
\label{type_yytype_uint16_cp-name-parser.c}

{\stt typedef unsigned short yytype\_uint16}


\subsubsection{Typedef yytype\_int16}
\label{type_yytype_int16_cp-name-parser.c}

{\stt typedef short yytype\_int16}


\subsubsection{Type union yyalloc}
\label{type_union_yyalloc_cp-name-parser.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt union yyalloc} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt yytype\_int16 yyss\_alloc;} &\\
\hspace*{0.2in}{\stt YYSTYPE yyvs\_alloc;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{Variable cpname\_debug}
\label{var_cpname_debug_cp-name-parser.c}

{\stt int cpname\_debug}

\smallskip
\begin{cxreftabiii}
Visible in:\ & cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Used in:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & yydestruct() & cp-name-parser.c & \cxreffunc{yydestruct}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Variable cpname\_lval}
\label{var_cpname_lval_cp-name-parser.c}

{\stt YYSTYPE cpname\_lval}

\smallskip
\begin{cxreftabiii}
Visible in:\ & cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Used in:\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & parse\_number() & cp-name-parser.c & \cxreffunc{parse_number}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Variable cpname\_char}
\label{var_cpname_char_cp-name-parser.c}

{\stt int cpname\_char}

\smallskip
\begin{cxreftabiii}
Visible in:\ & cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Used in:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Variable cpname\_nerrs}
\label{var_cpname_nerrs_cp-name-parser.c}

{\stt int cpname\_nerrs}

\smallskip
\begin{cxreftabiii}
Visible in:\ & cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Used in:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf lexptr}
\label{var_lexptr_cp-name-parser.c}

{\stt static const char* lexptr}

\smallskip
\begin{cxreftabiii}
Used in:\ & ada\_error() & \ & \cxreffunc{ada_error}{ada-exp.c}\\
\ & ada\_lex() & \ & \cxreffunc{ada_lex}{ada-exp.c}\\
\ & c\_error() & \ & \cxreffunc{c_error}{c-exp.c}\\
\ & c\_lex() & \ & \cxreffunc{c_lex}{c-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & cp\_demangled\_name\_to\_comp() & \ & \cxreffunc{cp_demangled_name_to_comp}{cp-name-parser.c}\\
\ & cpname\_lex() & \ & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\ & f\_error() & \ & \cxreffunc{f_error}{f-exp.c}\\
\ & f\_lex() & \ & \cxreffunc{f_lex}{f-exp.c}\\
\ & finished\_macro\_expansion() & \ & \cxreffunc{finished_macro_expansion}{c-lang.c}\\
\ & java\_error() & \ & \cxreffunc{java_error}{jv-exp.c}\\
\ & java\_lex() & \ & \cxreffunc{java_lex}{jv-exp.c}\\
\ & m2\_error() & \ & \cxreffunc{m2_error}{m2-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & m2\_lex() & \ & \cxreffunc{m2_lex}{m2-exp.c}\\
\ & match\_string\_literal() & \ & \cxreffunc{match_string_literal}{f-exp.c}\\
\ & objc\_error() & \ & \cxreffunc{objc_error}{objc-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_lex() & \ & \cxreffunc{objc_lex}{objc-exp.c}\\
\ & parse\_exp\_in\_context() & \ & \cxreffunc{parse_exp_in_context}{parse.c}\\
\ & parse\_number() & \ & \cxreffunc{parse_number}{m2-exp.c}\\
\ & pascal\_error() & \ & \cxreffunc{pascal_error}{p-exp.c}\\
\ & pascal\_lex() & \ & \cxreffunc{pascal_lex}{p-exp.c}\\
\ & scan\_macro\_expansion() & \ & \cxreffunc{scan_macro_expansion}{c-lang.c}\\
\ & scm\_lreadparen() & \ & \cxreffunc{scm_lreadparen}{scm-exp.c}\\
\ & scm\_lreadr() & \ & \cxreffunc{scm_lreadr}{scm-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & scm\_parse() & \ & \cxreffunc{scm_parse}{scm-exp.c}\\
\ & scm\_read\_token() & \ & \cxreffunc{scm_read_token}{scm-exp.c}\\
\ & scm\_skip\_ws() & \ & \cxreffunc{scm_skip_ws}{scm-exp.c}\\
\ & yy\_get\_next\_buffer() & \ & \cxreffunc{yy_get_next_buffer}{ada-exp.c}\\
\end{cxreftabiii}

\medskip
{\bf prev\_lexptr}
\label{var_prev_lexptr_cp-name-parser.c}

{\stt static const char* prev\_lexptr}

\smallskip
\begin{cxreftabiii}
Used in:\ & c\_error() & \ & \cxreffunc{c_error}{c-exp.c}\\
\ & c\_lex() & \ & \cxreffunc{c_lex}{c-exp.c}\\
\ & cp\_demangled\_name\_to\_comp() & \ & \cxreffunc{cp_demangled_name_to_comp}{cp-name-parser.c}\\
\ & cpname\_error() & \ & \cxreffunc{cpname_error}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & cpname\_lex() & \ & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\ & f\_error() & \ & \cxreffunc{f_error}{f-exp.c}\\
\ & f\_lex() & \ & \cxreffunc{f_lex}{f-exp.c}\\
\ & java\_error() & \ & \cxreffunc{java_error}{jv-exp.c}\\
\ & java\_lex() & \ & \cxreffunc{java_lex}{jv-exp.c}\\
\ & m2\_error() & \ & \cxreffunc{m2_error}{m2-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & m2\_lex() & \ & \cxreffunc{m2_lex}{m2-exp.c}\\
\ & parse\_exp\_in\_context() & \ & \cxreffunc{parse_exp_in_context}{parse.c}\\
\ & pascal\_error() & \ & \cxreffunc{pascal_error}{p-exp.c}\\
\ & pascal\_lex() & \ & \cxreffunc{pascal_lex}{p-exp.c}\\
\end{cxreftabiii}

\medskip
{\bf error\_lexptr}
\label{var_error_lexptr_cp-name-parser.c}

{\stt static const char* error\_lexptr}

\smallskip
\begin{cxreftabiii}
Used in:\ & cp\_demangled\_name\_to\_comp() & \ & \cxreffunc{cp_demangled_name_to_comp}{cp-name-parser.c}\\
\ & cpname\_error() & \ & \cxreffunc{cpname_error}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf global\_errmsg}
\label{var_global_errmsg_cp-name-parser.c}

{\stt static const char* global\_errmsg}

\smallskip
\begin{cxreftabiii}
Used in:\ & cp\_demangled\_name\_to\_comp() & \ & \cxreffunc{cp_demangled_name_to_comp}{cp-name-parser.c}\\
\ & cpname\_error() & \ & \cxreffunc{cpname_error}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf demangle\_info}
\label{var_demangle_info_cp-name-parser.c}

{\stt static struct demangle\_info* demangle\_info}

\smallskip
\begin{cxreftabiii}
Used in:\ & cp\_demangled\_name\_to\_comp() & \ & \cxreffunc{cp_demangled_name_to_comp}{cp-name-parser.c}\\
\ & fill\_comp() & \ & \cxreffunc{fill_comp}{cp-name-parser.c}\\
\ & make\_builtin\_type() & \ & \cxreffunc{make_builtin_type}{cp-name-parser.c}\\
\ & make\_dtor() & \ & \cxreffunc{make_dtor}{cp-name-parser.c}\\
\ & make\_empty() & \ & \cxreffunc{make_empty}{cp-name-parser.c}\\
\ & make\_name() & \ & \cxreffunc{make_name}{cp-name-parser.c}\\
\ & make\_operator() & \ & \cxreffunc{make_operator}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf global\_result}
\label{var_global_result_cp-name-parser.c}

{\stt static struct demangle\_component* global\_result}

\smallskip
\begin{cxreftabiii}
Used in:\ & cp\_demangled\_name\_to\_comp() & \ & \cxreffunc{cp_demangled_name_to_comp}{cp-name-parser.c}\\
\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf yytranslate}
\label{var_yytranslate_cp-name-parser.c}

{\stt static const yytype\_uint8 yytranslate[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf yyrline}
\label{var_yyrline_cp-name-parser.c}

{\stt static const yytype\_uint16 yyrline[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & yy\_reduce\_print() & \ & \cxreffunc{yy_reduce_print}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf yytname}
\label{var_yytname_cp-name-parser.c}

{\stt static const char* const yytname[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & yy\_symbol\_print() & \ & \cxreffunc{yy_symbol_print}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf cpname\_pact}
\label{var_cpname_pact_cp-name-parser.c}

{\stt static const yytype\_int16 cpname\_pact[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf yydefact}
\label{var_yydefact_cp-name-parser.c}

{\stt static const yytype\_uint8 yydefact[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf yypgoto}
\label{var_yypgoto_cp-name-parser.c}

{\stt static const yytype\_int16 yypgoto[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf yydefgoto}
\label{var_yydefgoto_cp-name-parser.c}

{\stt static const yytype\_int16 yydefgoto[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf cpname\_yytable}
\label{var_cpname_yytable_cp-name-parser.c}

{\stt static const yytype\_uint16 cpname\_yytable[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf cpname\_yycheck}
\label{var_cpname_yycheck_cp-name-parser.c}

{\stt static const yytype\_int16 cpname\_yycheck[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf yystos}
\label{var_yystos_cp-name-parser.c}

{\stt static const yytype\_uint8 yystos[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & yy\_reduce\_print() & \ & \cxreffunc{yy_reduce_print}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf cpname\_r1}
\label{var_cpname_r1_cp-name-parser.c}

{\stt static const yytype\_uint8 cpname\_r1[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf cpname\_r2}
\label{var_cpname_r2_cp-name-parser.c}

{\stt static const yytype\_uint8 cpname\_r2[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & cpname\_parse() & \ & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & yy\_reduce\_print() & \ & \cxreffunc{yy_reduce_print}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf backslashable}
\label{var_backslashable_cp-name-parser.c}

{\stt static char backslashable[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & c\_parse\_backslash() & \ & \cxreffunc{c_parse_backslash}{cp-name-parser.c}\\
\end{cxreftabiii}

\medskip
{\bf represented}
\label{var_represented_cp-name-parser.c}

{\stt static char represented[]}

\smallskip
\begin{cxreftabiii}
Used in:\ & c\_parse\_backslash() & \ & \cxreffunc{c_parse_backslash}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function cp\_comp\_to\_string()}
\label{func_cp_comp_to_string_cp-name-parser.c}

{\stt char* cp\_comp\_to\_string ( struct demangle\_component* result, int estimated\_len )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_strcat\_chk(), \_\_builtin\_\_\_strcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcat\_chk(), \_\_inline\_strcpy\_chk(), cplus\_demangle\_print(), strlen()} &\\
Called by:\ & cp\_canonicalize\_string() & cp-support.c & \cxreffunc{cp_canonicalize_string}{cp-support.c}\\
\cxreftabbreak{cxreftabiii}
\ & cp\_class\_name\_from\_physname() & cp-support.c & \cxreffunc{cp_class_name_from_physname}{cp-support.c}\\
\ & cp\_func\_name() & cp-support.c & \cxreffunc{cp_func_name}{cp-support.c}\\
\ & method\_name\_from\_physname() & cp-support.c & \cxreffunc{method_name_from_physname}{cp-support.c}\\
\ & remove\_params() & cp-support.c & \cxreffunc{remove_params}{cp-support.c}\\
\end{cxreftabiii}


\subsubsection{Global Function cp\_demangled\_name\_to\_comp()}
\label{func_cp_demangled_name_to_comp_cp-name-parser.c}

{\stt struct demangle\_component* cp\_demangled\_name\_to\_comp ( const char* demangled\_name, void** memory, const char** errmsg )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Calls:\ & allocate\_info() & cp-name-parser.c & \cxreffunc{allocate_info}{cp-name-parser.c}\\
\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_\_builtin\_\_\_snprintf\_chk(), \_\_builtin\_\_\_strcat\_chk(), \_\_builtin\_object\_size(), \_\_inline\_strcat\_chk(), strlen()} &\\
Called by:\ & cp\_canonicalize\_string() & cp-support.c & \cxreffunc{cp_canonicalize_string}{cp-support.c}\\
\ & cp\_func\_name() & cp-support.c & \cxreffunc{cp_func_name}{cp-support.c}\\
\ & mangled\_name\_to\_comp() & cp-support.c & \cxreffunc{mangled_name_to_comp}{cp-support.c}\\
\ & remove\_params() & cp-support.c & \cxreffunc{remove_params}{cp-support.c}\\
Refs Var:\ & demangle\_info & cp-name-parser.c & \cxrefvar{demangle_info}{cp-name-parser.c}\\
\ & error\_lexptr & cp-name-parser.c & \cxrefvar{error_lexptr}{cp-name-parser.c}\\
\ & global\_errmsg & cp-name-parser.c & \cxrefvar{global_errmsg}{cp-name-parser.c}\\
\ & global\_result & cp-name-parser.c & \cxrefvar{global_result}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & lexptr & cp-name-parser.c & \cxrefvar{lexptr}{cp-name-parser.c}\\
\ & prev\_lexptr & cp-name-parser.c & \cxrefvar{prev_lexptr}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Global Function cpname\_parse()}
\label{func_cpname_parse_cp-name-parser.c}

{\stt int cpname\_parse ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Calls:\ & cpname\_error() & cp-name-parser.c & \cxreffunc{cpname_error}{cp-name-parser.c}\\
\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\ & d\_binary() & cp-name-parser.c & \cxreffunc{d_binary}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & d\_int\_type() & cp-name-parser.c & \cxreffunc{d_int_type}{cp-name-parser.c}\\
\ & d\_qualify() & cp-name-parser.c & \cxreffunc{d_qualify}{cp-name-parser.c}\\
\ & d\_unary() & cp-name-parser.c & \cxreffunc{d_unary}{cp-name-parser.c}\\
\ & fill\_comp() & cp-name-parser.c & \cxreffunc{fill_comp}{cp-name-parser.c}\\
\ & make\_builtin\_type() & cp-name-parser.c & \cxreffunc{make_builtin_type}{cp-name-parser.c}\\
\ & make\_dtor() & cp-name-parser.c & \cxreffunc{make_dtor}{cp-name-parser.c}\\
\ & make\_empty() & cp-name-parser.c & \cxreffunc{make_empty}{cp-name-parser.c}\\
\ & make\_name() & cp-name-parser.c & \cxreffunc{make_name}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_operator() & cp-name-parser.c & \cxreffunc{make_operator}{cp-name-parser.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & yy\_reduce\_print() & cp-name-parser.c & \cxreffunc{yy_reduce_print}{cp-name-parser.c}\\
\ & yy\_stack\_print() & cp-name-parser.c & \cxreffunc{yy_stack_print}{cp-name-parser.c}\\
\ & yy\_symbol\_print() & cp-name-parser.c & \cxreffunc{yy_symbol_print}{cp-name-parser.c}\\
\ & yydestruct() & cp-name-parser.c & \cxreffunc{yydestruct}{cp-name-parser.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_memcpy(), fprintf()} &\\
Called by:\ & cp\_demangled\_name\_to\_comp() & cp-name-parser.c & \cxreffunc{cp_demangled_name_to_comp}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & cpname\_char & cp-name-parser.c & \cxrefvar{cpname_char}{cp-name-parser.c}\\
\ & cpname\_debug & cp-name-parser.c & \cxrefvar{cpname_debug}{cp-name-parser.c}\\
\ & cpname\_lval & cp-name-parser.c & \cxrefvar{cpname_lval}{cp-name-parser.c}\\
\ & cpname\_nerrs & cp-name-parser.c & \cxrefvar{cpname_nerrs}{cp-name-parser.c}\\
\ & cpname\_pact & cp-name-parser.c & \cxrefvar{cpname_pact}{cp-name-parser.c}\\
\ & cpname\_r1 & cp-name-parser.c & \cxrefvar{cpname_r1}{cp-name-parser.c}\\
\ & cpname\_r2 & cp-name-parser.c & \cxrefvar{cpname_r2}{cp-name-parser.c}\\
\ & cpname\_yycheck & cp-name-parser.c & \cxrefvar{cpname_yycheck}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & cpname\_yytable & cp-name-parser.c & \cxrefvar{cpname_yytable}{cp-name-parser.c}\\
\ & global\_result & cp-name-parser.c & \cxrefvar{global_result}{cp-name-parser.c}\\
\ & yydefact & cp-name-parser.c & \cxrefvar{yydefact}{cp-name-parser.c}\\
\ & yydefgoto & cp-name-parser.c & \cxrefvar{yydefgoto}{cp-name-parser.c}\\
\ & yypgoto & cp-name-parser.c & \cxrefvar{yypgoto}{cp-name-parser.c}\\
\ & yystos & cp-name-parser.c & \cxrefvar{yystos}{cp-name-parser.c}\\
\ & yytranslate & cp-name-parser.c & \cxrefvar{yytranslate}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Global Function d\_qualify()}
\label{func_d_qualify_cp-name-parser.c}

{\stt struct demangle\_component* d\_qualify ( struct demangle\_component* lhs, int qualifiers, int is\_method )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Calls:\ & fill\_comp() & cp-name-parser.c & \cxreffunc{fill_comp}{cp-name-parser.c}\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function allocate\_info()}
\label{func_allocate_info_cp-name-parser.c}

{\stt static struct demangle\_info* allocate\_info ( int comps )}

\smallskip
\begin{cxreftabiii}
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
Called by:\ & cp\_demangled\_name\_to\_comp() & cp-name-parser.c & \cxreffunc{cp_demangled_name_to_comp}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function c\_parse\_backslash()}
\label{func_c_parse_backslash_cp-name-parser.c}

{\stt static int c\_parse\_backslash ( int host\_char, int* target\_char )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ strchr()} &\\
Called by:\ & parse\_escape() & cp-name-parser.c & \cxreffunc{parse_escape}{cp-name-parser.c}\\
Refs Var:\ & backslashable & cp-name-parser.c & \cxrefvar{backslashable}{cp-name-parser.c}\\
\ & represented & cp-name-parser.c & \cxrefvar{represented}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cpname\_error()}
\label{func_cpname_error_cp-name-parser.c}

{\stt static void cpname\_error ( const char* msg )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Called by:\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
Refs Var:\ & error\_lexptr & cp-name-parser.c & \cxrefvar{error_lexptr}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & global\_errmsg & cp-name-parser.c & \cxrefvar{global_errmsg}{cp-name-parser.c}\\
\ & prev\_lexptr & cp-name-parser.c & \cxrefvar{prev_lexptr}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function cpname\_lex()}
\label{func_cpname_lex_cp-name-parser.c}

{\stt static int cpname\_lex ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Calls:\ & cpname\_error() & cp-name-parser.c & \cxreffunc{cpname_error}{cp-name-parser.c}\\
\ & fill\_comp() & cp-name-parser.c & \cxreffunc{fill_comp}{cp-name-parser.c}\\
\ & make\_builtin\_type() & cp-name-parser.c & \cxreffunc{make_builtin_type}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & make\_name() & cp-name-parser.c & \cxreffunc{make_name}{cp-name-parser.c}\\
\ & parse\_escape() & cp-name-parser.c & \cxreffunc{parse_escape}{cp-name-parser.c}\\
\ & parse\_number() & cp-name-parser.c & \cxreffunc{parse_number}{cp-name-parser.c}\\
\ & symbol\_end() & cp-name-parser.c & \cxreffunc{symbol_end}{cp-name-parser.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_alloca(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), strncmp()} &\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
Refs Var:\ & cpname\_lval & cp-name-parser.c & \cxrefvar{cpname_lval}{cp-name-parser.c}\\
\ & lexptr & cp-name-parser.c & \cxrefvar{lexptr}{cp-name-parser.c}\\
\ & prev\_lexptr & cp-name-parser.c & \cxrefvar{prev_lexptr}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ \_sch\_istable} &\\
\end{cxreftabiii}


\subsubsection{Local Function d\_binary()}
\label{func_d_binary_cp-name-parser.c}

{\stt static struct demangle\_component* d\_binary ( const char* name, struct demangle\_component* lhs, struct demangle\_component* rhs )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Calls:\ & fill\_comp() & cp-name-parser.c & \cxreffunc{fill_comp}{cp-name-parser.c}\\
\ & make\_operator() & cp-name-parser.c & \cxreffunc{make_operator}{cp-name-parser.c}\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function d\_int\_type()}
\label{func_d_int_type_cp-name-parser.c}

{\stt static struct demangle\_component* d\_int\_type ( int flags )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Calls:\ & make\_builtin\_type() & cp-name-parser.c & \cxreffunc{make_builtin_type}{cp-name-parser.c}\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function d\_unary()}
\label{func_d_unary_cp-name-parser.c}

{\stt static struct demangle\_component* d\_unary ( const char* name, struct demangle\_component* lhs )}

\smallskip
\begin{cxreftabiii}
Prototype:& cp-name-parser.c & \ & \cxreffile{cp-name-parser.c}\\
Calls:\ & fill\_comp() & cp-name-parser.c & \cxreffunc{fill_comp}{cp-name-parser.c}\\
\ & make\_operator() & cp-name-parser.c & \cxreffunc{make_operator}{cp-name-parser.c}\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function fill\_comp()}
\label{func_fill_comp_cp-name-parser.c}

{\stt static struct demangle\_component* fill\_comp ( enum demangle\_component\_type d\_type, struct demangle\_component* lhs, struct demangle\_component* rhs )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ cplus\_demangle\_fill\_component()} &\\
Called by:\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & d\_binary() & cp-name-parser.c & \cxreffunc{d_binary}{cp-name-parser.c}\\
\ & d\_qualify() & cp-name-parser.c & \cxreffunc{d_qualify}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & d\_unary() & cp-name-parser.c & \cxreffunc{d_unary}{cp-name-parser.c}\\
\ & parse\_number() & cp-name-parser.c & \cxreffunc{parse_number}{cp-name-parser.c}\\
Refs Var:\ & demangle\_info & cp-name-parser.c & \cxrefvar{demangle_info}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function make\_builtin\_type()}
\label{func_make_builtin_type_cp-name-parser.c}

{\stt static struct demangle\_component* make\_builtin\_type ( const char* name )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ cplus\_demangle\_fill\_builtin\_type()} &\\
Called by:\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & d\_int\_type() & cp-name-parser.c & \cxreffunc{d_int_type}{cp-name-parser.c}\\
\ & parse\_number() & cp-name-parser.c & \cxreffunc{parse_number}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & demangle\_info & cp-name-parser.c & \cxrefvar{demangle_info}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function make\_dtor()}
\label{func_make_dtor_cp-name-parser.c}

{\stt static struct demangle\_component* make\_dtor ( enum gnu\_v3\_dtor\_kinds kind, struct demangle\_component* name )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ cplus\_demangle\_fill\_dtor()} &\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
Refs Var:\ & demangle\_info & cp-name-parser.c & \cxrefvar{demangle_info}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function make\_empty()}
\label{func_make_empty_cp-name-parser.c}

{\stt static struct demangle\_component* make\_empty ( enum demangle\_component\_type d\_type )}

\smallskip
\begin{cxreftabiii}
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
Refs Var:\ & demangle\_info & cp-name-parser.c & \cxrefvar{demangle_info}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function make\_name()}
\label{func_make_name_cp-name-parser.c}

{\stt static struct demangle\_component* make\_name ( const char* name, int len )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ cplus\_demangle\_fill\_name()} &\\
Called by:\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & parse\_number() & cp-name-parser.c & \cxreffunc{parse_number}{cp-name-parser.c}\\
Refs Var:\ & demangle\_info & cp-name-parser.c & \cxrefvar{demangle_info}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function make\_operator()}
\label{func_make_operator_cp-name-parser.c}

{\stt static struct demangle\_component* make\_operator ( const char* name, int args )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ cplus\_demangle\_fill\_operator()} &\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & d\_binary() & cp-name-parser.c & \cxreffunc{d_binary}{cp-name-parser.c}\\
\ & d\_unary() & cp-name-parser.c & \cxreffunc{d_unary}{cp-name-parser.c}\\
Refs Var:\ & demangle\_info & cp-name-parser.c & \cxrefvar{demangle_info}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Local Function parse\_escape()}
\label{func_parse_escape_cp-name-parser.c}

{\stt static int parse\_escape ( const char** string\_ptr )}

\smallskip
\begin{cxreftabiii}
Calls:\ & c\_parse\_backslash() & cp-name-parser.c & \cxreffunc{c_parse_backslash}{cp-name-parser.c}\\
\ & parse\_escape() & cp-name-parser.c & \cxreffunc{parse_escape}{cp-name-parser.c}\\
Called by:\ & c\_lex() & c-exp.c & \cxreffunc{c_lex}{c-exp.c}\\
\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & get\_character\_constant() & macroexp.c & \cxreffunc{get_character_constant}{macroexp.c}\\
\ & get\_string\_literal() & macroexp.c & \cxreffunc{get_string_literal}{macroexp.c}\\
\ & java\_lex() & jv-exp.c & \cxreffunc{java_lex}{jv-exp.c}\\
\ & objc\_lex() & objc-exp.c & \cxreffunc{objc_lex}{objc-exp.c}\\
\ & parse\_escape() & cp-name-parser.c & \cxreffunc{parse_escape}{cp-name-parser.c}\\
\ & pascal\_lex() & p-exp.c & \cxreffunc{pascal_lex}{p-exp.c}\\
\end{cxreftabiii}


\subsubsection{Local Function parse\_number()}
\label{func_parse_number_cp-name-parser.c}

{\stt static int parse\_number ( const char* p, int len, int parsed\_float )}

\smallskip
\begin{cxreftabiii}
Calls:\ & fill\_comp() & cp-name-parser.c & \cxreffunc{fill_comp}{cp-name-parser.c}\\
\ & make\_builtin\_type() & cp-name-parser.c & \cxreffunc{make_builtin_type}{cp-name-parser.c}\\
\ & make\_name() & cp-name-parser.c & \cxreffunc{make_name}{cp-name-parser.c}\\
Called by:\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & cpname\_lval & cp-name-parser.c & \cxrefvar{cpname_lval}{cp-name-parser.c}\\
\ & \cxreftabiiispan{ \_sch\_istable, \_sch\_tolower} &\\
\end{cxreftabiii}


\subsubsection{Local Function symbol\_end()}
\label{func_symbol_end_cp-name-parser.c}

{\stt static const char* symbol\_end ( const char* lexptr )}

\smallskip
\begin{cxreftabiii}
Called by:\ & cpname\_lex() & cp-name-parser.c & \cxreffunc{cpname_lex}{cp-name-parser.c}\\
Refs Var:\ & \cxreftabiiispan{ \_sch\_istable} &\\
\end{cxreftabiii}


\subsubsection{Local Function yy\_reduce\_print()}
\label{func_yy_reduce_print_cp-name-parser.c}

{\stt static void yy\_reduce\_print ( yytype\_int16* yyssp, YYSTYPE* yyvsp, int cpname\_rule )}

\smallskip
\begin{cxreftabiii}
Calls:\ & yy\_symbol\_print() & cp-name-parser.c & \cxreffunc{yy_symbol_print}{cp-name-parser.c}\\
\ & \cxreftabiiispan{ fprintf()} &\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
Refs Var:\ & cpname\_r2 & cp-name-parser.c & \cxrefvar{cpname_r2}{cp-name-parser.c}\\
\ & yyrline & cp-name-parser.c & \cxrefvar{yyrline}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
\ & yystos & cp-name-parser.c & \cxrefvar{yystos}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function yy\_stack\_print()}
\label{func_yy_stack_print_cp-name-parser.c}

{\stt static void yy\_stack\_print ( yytype\_int16* yybottom, yytype\_int16* yytop )}

\smallskip
\begin{cxreftabiii}
Calls:\ & \cxreftabiiispan{ fprintf()} &\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function yy\_symbol\_print()}
\label{func_yy_symbol_print_cp-name-parser.c}

{\stt static void yy\_symbol\_print ( FILE* yyo, int yytype, YYSTYPE const* const yyvaluep )}

\smallskip
\begin{cxreftabiii}
Calls:\ & yy\_symbol\_value\_print() & cp-name-parser.c & \cxreffunc{yy_symbol_value_print}{cp-name-parser.c}\\
\ & \cxreftabiiispan{ fprintf()} &\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
\ & yy\_reduce\_print() & cp-name-parser.c & \cxreffunc{yy_reduce_print}{cp-name-parser.c}\\
\ & yydestruct() & cp-name-parser.c & \cxreffunc{yydestruct}{cp-name-parser.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & yytname & cp-name-parser.c & \cxrefvar{yytname}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function yy\_symbol\_value\_print()}
\label{func_yy_symbol_value_print_cp-name-parser.c}

{\stt static void yy\_symbol\_value\_print ( FILE* yyo, int yytype, YYSTYPE const* const yyvaluep )}

\smallskip
\begin{cxreftabiii}
Called by:\ & yy\_symbol\_print() & cp-name-parser.c & \cxreffunc{yy_symbol_print}{cp-name-parser.c}\\
\end{cxreftabiii}


\subsubsection{Local Function yydestruct()}
\label{func_yydestruct_cp-name-parser.c}

{\stt static void yydestruct ( const char* yymsg, int yytype, YYSTYPE* yyvaluep )}

\smallskip
\begin{cxreftabiii}
Calls:\ & yy\_symbol\_print() & cp-name-parser.c & \cxreffunc{yy_symbol_print}{cp-name-parser.c}\\
\ & \cxreftabiiispan{ fprintf()} &\\
Called by:\ & cpname\_parse() & cp-name-parser.c & \cxreffunc{cpname_parse}{cp-name-parser.c}\\
Refs Var:\ & cpname\_debug & cp-name-parser.c & \cxrefvar{cpname_debug}{cp-name-parser.c}\\
\end{cxreftabiii}

