% This LaTeX file generated by cxref (version 1.6e).
% cxref program (c) Andrew M. Bishop 1995-2014.

% Cxref: cxref -Odoc/cxref -Ngdb.cxref -R. -xref -I. -Imacosx -I. -I. -I./config -I./target -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I./../include/opcode -I./../readline/.. -I../bfd -I./../bfd -I./../include -I../intl -I./../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -warn-xref -U__BLOCKS__ -index -latex -html -rtf -sgml -raw -no-comments -DRUNNING_CXREF value.c
% CPP  : cxref-cpp -lang-c -C -dD -dI -I. -Imacosx -I. -I. -Iconfig -Itarget -DHAVE_CONFIG_H -DHAVE_SYS_TYPES_H -DLOCALEDIR="/usr/local/share/locale" -I../include/opcode -I.. -I../bfd -I../bfd -I../include -I../intl -I../intl -I/opt/local/include/libxml2 -D__MigTypeCheck=1 -D__DARWIN_UNIX03=1 -DS_SPLINT_S -U__BLOCKS__ -DRUNNING_CXREF

\markboth{File value.c}{File value.c}
\section{File value.c}
\label{file_value.c}


\subsection*{Included Files}

\begin{cxreftabi}
{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.2in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/time.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <time.h>} &\\
\hspace*{0.2in}{\stt \#include <sys/types.h>} &\\
\hspace*{0.2in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include <errno.h>} &\\
\hspace*{0.2in}{\stt \#include <limits.h>} &\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\hspace*{0.2in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <unistd.h>} &\\
\hspace*{0.2in}{\stt \#include <stdint.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_locale.h"} &\cxreffile{gdb_locale.h}\\
\hspace*{0.4in}{\stt \#include "config.h"} &\cxreffile{config.h}\\
\hspace*{0.4in}{\stt \#include <locale.h>} &\\
\hspace*{0.4in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "../gdb/signals.h"} &\cxreffile{../gdb/signals.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\hspace*{0.4in}{\stt \#include <stddef.h>} &\\
\hspace*{0.4in}{\stt \#include <stdarg.h>} &\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "../include/symcat.h"} &\cxreffile{../include/symcat.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include <../intl/libintl.h>} &\\
\hspace*{0.2in}{\stt \#include "ui-file.h"} &\cxreffile{ui-file.h}\\
\hspace*{0.4in}{\stt \#include <stdio.h>} &\\
\hspace*{0.2in}{\stt \#include "xm.h"} &\cxreffile{xm.h}\\
\hspace*{0.4in}{\stt \#include "macosx/xm-macosx.h"} &\cxreffile{macosx/xm-macosx.h}\\
\hspace*{0.6in}{\stt \#include <mach/mach.h>} &\\
\hspace*{0.6in}{\stt \#include <signal.h>} &\\
\hspace*{0.6in}{\stt \#include <limits.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "nm.h"} &\cxreffile{nm.h}\\
\hspace*{0.4in}{\stt \#include "config/i386/nm-i386.h"} &\cxreffile{config/i386/nm-i386.h}\\
\hspace*{0.4in}{\stt \#include "macosx/nm-macosx.h"} &\cxreffile{macosx/nm-macosx.h}\\
\hspace*{0.2in}{\stt \#include "tm.h"} &\cxreffile{tm.h}\\
\hspace*{0.4in}{\stt \#include "config/tm-macosx.h"} &\cxreffile{config/tm-macosx.h}\\
\hspace*{0.6in}{\stt \#include "macosx/macosx-tdep.h"} &\cxreffile{macosx/macosx-tdep.h}\\
\hspace*{0.8in}{\stt \#include "defs.h"} &\cxreffile{defs.h}\\
\hspace*{0.8in}{\stt \#include "macosx/i386-macosx-tdep.h"} &\cxreffile{macosx/i386-macosx-tdep.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{1.0in}{\stt \#include "macosx/i386-macosx-thread-status.h"} &\cxreffile{macosx/i386-macosx-thread-status.h}\\
\hspace*{1.2in}{\stt \#include <stdint.h>} &\\
\hspace*{1.2in}{\stt \#include <mach/mach\_types.h>} &\\
\hspace*{0.8in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{1.0in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.8in}{\stt \#include <inttypes.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/mach\_vm.h>} &\\
\hspace*{0.8in}{\stt \#include <mach/kmod.h>} &\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "macosx/tm-i386-macosx.h"} &\cxreffile{macosx/tm-i386-macosx.h}\\
\hspace*{0.2in}{\stt \#include "../include/fopen-bin.h"} &\cxreffile{../include/fopen-bin.h}\\
\hspace*{0.2in}{\stt \#include <stddef.h>} &\\
\hspace*{0.2in}{\stt \#include <stdlib.h>} &\\
\hspace*{0.2in}{\stt \#include "gdbarch.h"} &\cxreffile{gdbarch.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_string.h"} &\cxreffile{gdb_string.h}\\
\hspace*{0.2in}{\stt \#include <string.h>} &\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.4in}{\stt \#include "../include/floatformat.h"} &\cxreffile{../include/floatformat.h}\\
\hspace*{0.6in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "gdb\_regex.h"} &\cxreffile{gdb_regex.h}\\
\hspace*{0.4in}{\stt \#include <regex.h>} &\\
\hspace*{0.2in}{\stt \#include "frame.h"} &\cxreffile{frame.h}\\
\hspace*{0.4in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.4in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "gdbtypes.h"} &\cxreffile{gdbtypes.h}\\
\hspace*{0.2in}{\stt \#include "expression.h"} &\cxreffile{expression.h}\\
\hspace*{0.4in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\hspace*{0.4in}{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcore.h"} &\cxreffile{gdbcore.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdbcmd.h"} &\cxreffile{gdbcmd.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "command.h"} &\cxreffile{command.h}\\
\hspace*{0.2in}{\stt \#include "ui-out.h"} &\cxreffile{ui-out.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "target.h"} &\cxreffile{target.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\hspace*{0.2in}{\stt \#include "../bfd/bfd.h"} &\cxreffile{../bfd/bfd.h}\\
\hspace*{0.2in}{\stt \#include "symtab.h"} &\cxreffile{symtab.h}\\
\cxreftabbreak{cxreftabi}
\hspace*{0.2in}{\stt \#include "dcache.h"} &\cxreffile{dcache.h}\\
\hspace*{0.2in}{\stt \#include "memattr.h"} &\cxreffile{memattr.h}\\
\hspace*{0.2in}{\stt \#include "value.h"} &\cxreffile{value.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "language.h"} &\cxreffile{language.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "scm-lang.h"} &\cxreffile{scm-lang.h}\\
\hspace*{0.2in}{\stt \#include "scm-tags.h"} &\cxreffile{scm-tags.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "../include/demangle.h"} &\cxreffile{../include/demangle.h}\\
\hspace*{0.2in}{\stt \#include "../include/libiberty.h"} &\cxreffile{../include/libiberty.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "doublest.h"} &\cxreffile{doublest.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "gdb\_assert.h"} &\cxreffile{gdb_assert.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "regcache.h"} &\cxreffile{regcache.h}\\
\hspace*{0.2in}{\stt \#include "../include/ansidecl.h"} &\cxreffile{../include/ansidecl.h}\\
\end{cxreftabi}

\medskip
\begin{cxreftabi}
{\stt \#include "block.h"} &\cxreffile{block.h}\\
\end{cxreftabi}


\subsection*{Preprocessor definitions}

{\stt \#define VALUE\_HISTORY\_CHUNK 60}


\subsection{Type definitions}


\subsubsection{Type struct value}
\label{type_struct_value_value.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct value} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt enum lval\_type lval;} &\\
\hspace*{0.2in}{\stt int modifiable;} &\\
\hspace*{0.2in}{\stt union} &\\
\hspace*{0.3in}{\stt \{} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.4in}{\stt CORE\_ADDR address;} &\\
\hspace*{0.4in}{\stt struct internalvar* internalvar;} &\\
\hspace*{0.3in}{\stt \}} &\\
\hspace*{0.3in}{\stt location;} &\\
\hspace*{0.2in}{\stt int offset;} &\\
\hspace*{0.2in}{\stt int bitsize;} &\\
\hspace*{0.2in}{\stt int bitpos;} &\\
\hspace*{0.2in}{\stt struct frame\_id frame\_id;} &\\
\hspace*{0.2in}{\stt struct type* type;} &\\
\hspace*{0.2in}{\stt struct type* enclosing\_type;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int embedded\_offset;} &\\
\hspace*{0.2in}{\stt int pointed\_to\_offset;} &\\
\hspace*{0.2in}{\stt struct value* next;} &\\
\hspace*{0.2in}{\stt short regnum;} &\\
\hspace*{0.2in}{\stt char lazy;} &\\
\hspace*{0.2in}{\stt enum opt\_state optimized\_out;} &\\
\hspace*{0.2in}{\stt int var\_status;} &\\
\hspace*{0.2in}{\stt union} &\\
\hspace*{0.3in}{\stt \{} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.4in}{\stt gdb\_byte contents[1];} &\\
\hspace*{0.4in}{\stt DOUBLEST force\_doublest\_align;} &\\
\hspace*{0.4in}{\stt long force\_longest\_align;} &\\
\hspace*{0.4in}{\stt CORE\_ADDR force\_core\_addr\_align;} &\\
\hspace*{0.4in}{\stt void* force\_pointer\_align;} &\\
\hspace*{0.3in}{\stt \}} &\\
\hspace*{0.3in}{\stt aligner;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct cached\_value}
\label{type_struct_cached_value_value.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct cached\_value} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt char* name;} &\\
\hspace*{0.2in}{\stt struct type* type;} &\\
\hspace*{0.2in}{\stt struct value val;} &\\
\cxreftabbreak{cxreftabiia}
\hspace*{0.2in}{\stt int bound;} &\\
\hspace*{0.2in}{\stt unsigned int generation;} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsubsection{Type struct value\_history\_chunk}
\label{type_struct_value_history_chunk_value.c}

\smallskip
\begin{cxreftabiia}
\hspace*{0.0in}{\stt struct value\_history\_chunk} &\\
\hspace*{0.1in}{\stt \{} &\\
\hspace*{0.2in}{\stt struct value\_history\_chunk* next;} &\\
\hspace*{0.2in}{\stt struct value* values[60];} &\\
\hspace*{0.1in}{\stt \}} &\\
\end{cxreftabiia}


\subsection{Variables}


\subsubsection{External Variables}

{\bf symbol\_generation}
\label{var_symbol_generation_value.c}

{\stt extern unsigned int symbol\_generation}

\smallskip
\begin{cxreftabiii}
Defined in:& breakpoint.c & \ & \cxrefvar{symbol_generation}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Local Variables}

{\bf value\_history\_chain}
\label{var_value_history_chain_value.c}

{\stt static struct value\_history\_chunk* value\_history\_chain}

\smallskip
\begin{cxreftabiii}
Used in:\ & access\_value\_history() & \ & \cxreffunc{access_value_history}{value.c}\\
\ & clear\_value\_history() & \ & \cxreffunc{clear_value_history}{value.c}\\
\ & record\_latest\_value() & \ & \cxreffunc{record_latest_value}{value.c}\\
\end{cxreftabiii}

\medskip
{\bf value\_history\_count}
\label{var_value_history_count_value.c}

{\stt static int value\_history\_count}

\smallskip
\begin{cxreftabiii}
Used in:\ & access\_value\_history() & \ & \cxreffunc{access_value_history}{value.c}\\
\ & clear\_value\_history() & \ & \cxreffunc{clear_value_history}{value.c}\\
\ & record\_latest\_value() & \ & \cxreffunc{record_latest_value}{value.c}\\
\ & show\_values() & \ & \cxreffunc{show_values}{value.c}\\
\end{cxreftabiii}

\medskip
{\bf all\_values}
\label{var_all_values_value.c}

{\stt static struct value* all\_values}

\smallskip
\begin{cxreftabiii}
Used in:\ & allocate\_value() & \ & \cxreffunc{allocate_value}{value.c}\\
\ & free\_all\_values() & \ & \cxreffunc{free_all_values}{value.c}\\
\ & release\_value() & \ & \cxreffunc{release_value}{value.c}\\
\ & value\_change\_enclosing\_type() & \ & \cxreffunc{value_change_enclosing_type}{value.c}\\
\ & value\_free\_to\_mark() & \ & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_mark() & \ & \cxreffunc{value_mark}{value.c}\\
\ & value\_release\_to\_mark() & \ & \cxreffunc{value_release_to_mark}{value.c}\\
\end{cxreftabiii}

\medskip
{\bf internalvars}
\label{var_internalvars_value.c}

{\stt static struct internalvar* internalvars}

\smallskip
\begin{cxreftabiii}
Used in:\ & clear\_internalvars() & \ & \cxreffunc{clear_internalvars}{value.c}\\
\ & lookup\_internalvar() & \ & \cxreffunc{lookup_internalvar}{value.c}\\
\ & show\_convenience() & \ & \cxreffunc{show_convenience}{value.c}\\
\end{cxreftabiii}


\subsection{Functions}


\subsubsection{Global Function \_initialize\_values()}
\label{func__initialize_values_value.c}

{\stt void \_initialize\_values ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.c & \ & \cxreffile{value.c}\\
Calls:\ & \cxreftabiiispan{ add\_cmd()} &\\
Refs Func:\ & show\_convenience() & value.c & \cxreffunc{show_convenience}{value.c}\\
\ & show\_values() & value.c & \cxreffunc{show_values}{value.c}\\
Refs Var:\ & \cxreftabiiispan{ showlist} &\\
\end{cxreftabiii}


\subsubsection{Global Function access\_value\_history()}
\label{func_access_value_history_value.c}

{\stt struct value* access\_value\_history ( int num )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
Called by:\ & decode\_dollar() & linespec.c & \cxreffunc{decode_dollar}{linespec.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & print\_command\_1() & printcmd.c & \cxreffunc{print_command_1}{printcmd.c}\\
\ & show\_values() & value.c & \cxreffunc{show_values}{value.c}\\
\ & whatis\_exp() & typeprint.c & \cxreffunc{whatis_exp}{typeprint.c}\\
Refs Var:\ & value\_history\_chain & value.c & \cxrefvar{value_history_chain}{value.c}\\
\ & value\_history\_count & value.c & \cxrefvar{value_history_count}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function allocate\_repeat\_value()}
\label{func_allocate_repeat_value_value.c}

{\stt struct value* allocate\_repeat\_value ( struct type* type, int count )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & value\_repeat() & valops.c & \cxreffunc{value_repeat}{valops.c}\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function allocate\_value()}
\label{func_allocate_value_value.c}

{\stt struct value* allocate\_value ( struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_frame\_id\_hack() & value.c & \cxreffunc{deprecated_value_frame_id_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & deprecated\_value\_regnum\_hack() & value.c & \cxreffunc{deprecated_value_regnum_hack}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & xzalloc() & utils.c & \cxreffunc{xzalloc}{utils.c}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_value\_binop() & ada-lang.c & \cxreffunc{ada_value_binop}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & allocate\_repeat\_value() & value.c & \cxreffunc{allocate_repeat_value}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & cast\_into\_complex() & valops.c & \cxreffunc{cast_into_complex}{valops.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & dwarf2\_evaluate\_loc\_desc() & dwarf2loc.c & \cxreffunc{dwarf2_evaluate_loc_desc}{dwarf2loc.c}\\
\ & empty\_array() & ada-lang.c & \cxreffunc{empty_array}{ada-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & hpacc\_virtual\_fn\_field() & hpacc-abi.c & \cxreffunc{hpacc_virtual_fn_field}{hpacc-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & loclist\_read\_variable() & dwarf2loc.c & \cxreffunc{loclist_read_variable}{dwarf2loc.c}\\
\ & lookup\_cached\_function() & value.c & \cxreffunc{lookup_cached_function}{value.c}\\
\ & lookup\_internalvar() & value.c & \cxreffunc{lookup_internalvar}{value.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\ & print\_return\_value() & infcmd.c & \cxreffunc{print_return_value}{infcmd.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_traceframe\_context() & tracepoint.c & \cxreffunc{set_traceframe_context}{tracepoint.c}\\
\ & value\_array() & valops.c & \cxreffunc{value_array}{valops.c}\\
\ & value\_at() & valops.c & \cxreffunc{value_at}{valops.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_bitstring() & valops.c & \cxreffunc{value_bitstring}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
\ & value\_from\_double() & value.c & \cxreffunc{value_from_double}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\ & value\_from\_string() & value.c & \cxreffunc{value_from_string}{value.c}\\
\ & value\_literal\_complex() & valops.c & \cxreffunc{value_literal_complex}{valops.c}\\
\ & value\_maybe\_namespace\_elt() & valops.c & \cxreffunc{value_maybe_namespace_elt}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_of\_builtin\_frame\_fp\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_fp_reg}{std-regs.c}\\
\ & value\_of\_builtin\_frame\_pc\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_pc_reg}{std-regs.c}\\
\ & value\_of\_builtin\_frame\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_reg}{std-regs.c}\\
\ & value\_of\_register() & findvar.c & \cxreffunc{value_of_register}{findvar.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_string() & valops.c & \cxreffunc{value_string}{valops.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
Refs Var:\ & all\_values & value.c & \cxrefvar{all_values}{value.c}\\
\ & null\_frame\_id & frame.c & \cxrefvar{null_frame_id}{frame.c}\\
\end{cxreftabiii}


\subsubsection{Global Function clear\_internalvars()}
\label{func_clear_internalvars_value.c}

{\stt void clear\_internalvars ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & clear\_symtab\_users() & symfile.c & \cxreffunc{clear_symtab_users}{symfile.c}\\
Refs Var:\ & internalvars & value.c & \cxrefvar{internalvars}{value.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function clear\_value\_history()}
\label{func_clear_value_history_value.c}

{\stt void clear\_value\_history ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & clear\_symtab\_users() & symfile.c & \cxreffunc{clear_symtab_users}{symfile.c}\\
Refs Var:\ & value\_history\_chain & value.c & \cxrefvar{value_history_chain}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_history\_count & value.c & \cxrefvar{value_history_count}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function coerce\_array()}
\label{func_coerce_array_value.c}

{\stt struct value* coerce\_array ( struct value* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\ & value\_coerce\_function() & valops.c & \cxreffunc{value_coerce_function}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & check\_field() & valops.c & \cxreffunc{check_field}{valops.c}\\
\ & coerce\_number() & value.c & \cxreffunc{coerce_number}{value.c}\\
\ & value\_add() & valarith.c & \cxreffunc{value_add}{valarith.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_find\_oload\_method\_list() & valops.c & \cxreffunc{value_find_oload_method_list}{valops.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_less() & valarith.c & \cxreffunc{value_less}{valarith.c}\\
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
\ & varobj\_value\_struct\_elt\_by\_index() & varobj.c & \cxreffunc{varobj_value_struct_elt_by_index}{varobj.c}\\
Refs Var:\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function coerce\_enum()}
\label{func_coerce_enum_value.c}

{\stt struct value* coerce\_enum ( struct value* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & coerce\_number() & value.c & \cxreffunc{coerce_number}{value.c}\\
\ & value\_x\_binop() & valarith.c & \cxreffunc{value_x_binop}{valarith.c}\\
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
Refs Var:\ & builtin\_type\_unsigned\_int & gdbtypes.c & \cxrefvar{builtin_type_unsigned_int}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function coerce\_number()}
\label{func_coerce_number_value.c}

{\stt struct value* coerce\_number ( struct value* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & coerce\_enum() & value.c & \cxreffunc{coerce_enum}{value.c}\\
Called by:\ & value\_logical\_not() & valarith.c & \cxreffunc{value_logical_not}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function coerce\_ref()}
\label{func_coerce_ref_value.c}

{\stt struct value* coerce\_ref ( struct value* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & unpack\_pointer() & value.c & \cxreffunc{unpack_pointer}{value.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_coerce\_ref() & ada-lang.c & \cxreffunc{ada_coerce_ref}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_binop() & ada-lang.c & \cxreffunc{ada_value_binop}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_complement() & valarith.c & \cxreffunc{value_complement}{valarith.c}\\
\ & value\_neg() & valarith.c & \cxreffunc{value_neg}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_pos() & valarith.c & \cxreffunc{value_pos}{valarith.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_x\_binop() & valarith.c & \cxreffunc{value_x_binop}{valarith.c}\\
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
\end{cxreftabiii}


\subsubsection{Global Function create\_cached\_function()}
\label{func_create_cached_function_value.c}

{\stt struct cached\_value* create\_cached\_function ( const char* name, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk(), xstrdup()} &\\
Called by:\ & allocate\_space\_in\_inferior\_malloc() & valops.c & \cxreffunc{allocate_space_in_inferior_malloc}{valops.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_child\_selector\_nocache() & objc-lang.c & \cxreffunc{lookup_child_selector_nocache}{objc-lang.c}\\
\ & lookup\_objc\_class() & objc-lang.c & \cxreffunc{lookup_objc_class}{objc-lang.c}\\
\ & make\_cleanup\_set\_restore\_debugger\_mode() & objc-lang.c & \cxreffunc{make_cleanup_set_restore_debugger_mode}{objc-lang.c}\\
\ & new\_objc\_runtime\_class\_getClass() & objc-lang.c & \cxreffunc{new_objc_runtime_class_getClass}{objc-lang.c}\\
\ & new\_objc\_runtime\_find\_impl() & objc-lang.c & \cxreffunc{new_objc_runtime_find_impl}{objc-lang.c}\\
\ & new\_objc\_runtime\_get\_classname() & objc-lang.c & \cxreffunc{new_objc_runtime_get_classname}{objc-lang.c}\\
\ & objc\_runtime\_lock\_taken\_p() & objc-lang.c & \cxreffunc{objc_runtime_lock_taken_p}{objc-lang.c}\\
\ & read\_objc\_object() & objc-lang.c & \cxreffunc{read_objc_object}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_set\_value\_modifiable()}
\label{func_deprecated_set_value_modifiable_value.c}

{\stt void deprecated\_set\_value\_modifiable ( struct value* value, int modifiable )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & set\_traceframe\_context() & tracepoint.c & \cxreffunc{set_traceframe_context}{tracepoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_set\_value\_type()}
\label{func_deprecated_set_value_type_value.c}

{\stt void deprecated\_set\_value\_type ( struct value* value, struct type* type )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_coerce\_to\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_type}{ada-lang.c}\\
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & coerce\_for\_assign() & ada-lang.c & \cxreffunc{coerce_for_assign}{ada-lang.c}\\
\ & cp\_print\_hpacc\_virtual\_table\_entries() & cp-valprint.c & \cxreffunc{cp_print_hpacc_virtual_table_entries}{cp-valprint.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & hpacc\_virtual\_fn\_field() & hpacc-abi.c & \cxreffunc{hpacc_virtual_fn_field}{hpacc-abi.c}\\
\ & printf\_command() & printcmd.c & \cxreffunc{printf_command}{printcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_traceframe\_context() & tracepoint.c & \cxreffunc{set_traceframe_context}{tracepoint.c}\\
\ & type\_from\_class() & jv-lang.c & \cxreffunc{type_from_class}{jv-lang.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_arg\_coerce() & infcall.c & \cxreffunc{value_arg_coerce}{infcall.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & varobj\_fixup\_value() & varobj.c & \cxreffunc{varobj_fixup_value}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_value\_address\_hack()}
\label{func_deprecated_value_address_hack_value.c}

{\stt CORE\_ADDR* deprecated\_value\_address\_hack ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_to\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_fixed_value}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & common\_val\_print() & valprint.c & \cxreffunc{common_val_print}{valprint.c}\\
\ & cp\_print\_static\_field() & cp-valprint.c & \cxreffunc{cp_print_static_field}{cp-valprint.c}\\
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & dwarf2\_evaluate\_loc\_desc() & dwarf2loc.c & \cxreffunc{dwarf2_evaluate_loc_desc}{dwarf2loc.c}\\
\ & encode\_actions() & tracepoint.c & \cxreffunc{encode_actions}{tracepoint.c}\\
\ & ensure\_lval() & ada-lang.c & \cxreffunc{ensure_lval}{ada-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & find\_function\_addr() & infcall.c & \cxreffunc{find_function_addr}{infcall.c}\\
\cxreftabbreak{cxreftabiii}
\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & get\_java\_utf8\_name() & jv-lang.c & \cxreffunc{get_java_utf8_name}{jv-lang.c}\\
\ & gnuv2\_value\_rtti\_type() & gnu-v2-abi.c & \cxreffunc{gnuv2_value_rtti_type}{gnu-v2-abi.c}\\
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\ & hpacc\_virtual\_fn\_field() & hpacc-abi.c & \cxreffunc{hpacc_virtual_fn_field}{hpacc-abi.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & java\_link\_class\_type() & jv-lang.c & \cxreffunc{java_link_class_type}{jv-lang.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & locate\_var\_value() & findvar.c & \cxreffunc{locate_var_value}{findvar.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\ & pascal\_object\_print\_static\_field() & p-valprint.c & \cxreffunc{pascal_object_print_static_field}{p-valprint.c}\\
\ & print\_formatted() & printcmd.c & \cxreffunc{print_formatted}{printcmd.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\ & type\_from\_class() & jv-lang.c & \cxreffunc{type_from_class}{jv-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_at() & valops.c & \cxreffunc{value_at}{valops.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\ & value\_coerce\_function() & valops.c & \cxreffunc{value_coerce_function}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\ & value\_of\_register() & findvar.c & \cxreffunc{value_of_register}{findvar.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_repeat() & valops.c & \cxreffunc{value_repeat}{valops.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_static\_field() & value.c & \cxreffunc{value_static_field}{value.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_value\_frame\_id\_hack()}
\label{func_deprecated_value_frame_id_hack_value.c}

{\stt struct frame\_id* deprecated\_value\_frame\_id\_hack ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\ & value\_of\_register() & findvar.c & \cxreffunc{value_of_register}{findvar.c}\\
\ & value\_of\_user\_reg() & user-regs.c & \cxreffunc{value_of_user_reg}{user-regs.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_value\_internalvar\_hack()}
\label{func_deprecated_value_internalvar_hack_value.c}

{\stt struct internalvar** deprecated\_value\_internalvar\_hack ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_of\_internalvar() & value.c & \cxreffunc{value_of_internalvar}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_value\_lval\_hack()}
\label{func_deprecated_value_lval_hack_value.c}

{\stt enum lval\_type* deprecated\_value\_lval\_hack ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & dwarf2\_evaluate\_loc\_desc() & dwarf2loc.c & \cxreffunc{dwarf2_evaluate_loc_desc}{dwarf2loc.c}\\
\ & ensure\_lval() & ada-lang.c & \cxreffunc{ensure_lval}{ada-lang.c}\\
\ & evaluate\_subexp\_for\_address() & eval.c & \cxreffunc{evaluate_subexp_for_address}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & locate\_var\_value() & findvar.c & \cxreffunc{locate_var_value}{findvar.c}\\
\ & loclist\_read\_variable() & dwarf2loc.c & \cxreffunc{loclist_read_variable}{dwarf2loc.c}\\
\ & print\_formatted() & printcmd.c & \cxreffunc{print_formatted}{printcmd.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_at() & valops.c & \cxreffunc{value_at}{valops.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_coerce\_function() & valops.c & \cxreffunc{value_coerce_function}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\ & value\_of\_builtin\_frame\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_reg}{std-regs.c}\\
\ & value\_of\_internalvar() & value.c & \cxreffunc{value_of_internalvar}{value.c}\\
\ & value\_of\_register() & findvar.c & \cxreffunc{value_of_register}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_repeat() & valops.c & \cxreffunc{value_repeat}{valops.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_static\_field() & value.c & \cxreffunc{value_static_field}{value.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_subscript\_packed() & ada-lang.c & \cxreffunc{value_subscript_packed}{ada-lang.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\ & value\_x\_binop() & valarith.c & \cxreffunc{value_x_binop}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
\ & value\_zero() & valops.c & \cxreffunc{value_zero}{valops.c}\\
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_value\_modifiable()}
\label{func_deprecated_value_modifiable_value.c}

{\stt int deprecated\_value\_modifiable ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function deprecated\_value\_regnum\_hack()}
\label{func_deprecated_value_regnum_hack_value.c}

{\stt short* deprecated\_value\_regnum\_hack ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & locate\_var\_value() & findvar.c & \cxreffunc{locate_var_value}{findvar.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\ & value\_of\_register() & findvar.c & \cxreffunc{value_of_register}{findvar.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\end{cxreftabiii}


\subsubsection{Global Function free\_all\_values()}
\label{func_free_all_values_value.c}

{\stt void free\_all\_values ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & execute\_command() & top.c & \cxreffunc{execute_command}{top.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & all\_values & value.c & \cxrefvar{all_values}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function generic\_use\_struct\_convention()}
\label{func_generic_use_struct_convention_value.c}

{\stt int generic\_use\_struct\_convention ( int gcc\_p, struct type* value\_type )}

\smallskip
\begin{cxreftabiii}
Calls:\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function internalvar\_name()}
\label{func_internalvar_name_value.c}

{\stt char* internalvar\_name ( struct internalvar* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & print\_subexp\_standard() & expprint.c & \cxreffunc{print_subexp_standard}{expprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function lookup\_cached\_function()}
\label{func_lookup_cached_function_value.c}

{\stt struct value* lookup\_cached\_function ( struct cached\_value* cval )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & find\_function\_in\_inferior() & valops.c & \cxreffunc{find_function_in_inferior}{valops.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & allocate\_space\_in\_inferior\_malloc() & valops.c & \cxreffunc{allocate_space_in_inferior_malloc}{valops.c}\\
\ & do\_end\_debugger\_mode() & objc-lang.c & \cxreffunc{do_end_debugger_mode}{objc-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & lookup\_child\_selector\_nocache() & objc-lang.c & \cxreffunc{lookup_child_selector_nocache}{objc-lang.c}\\
\ & lookup\_objc\_class() & objc-lang.c & \cxreffunc{lookup_objc_class}{objc-lang.c}\\
\ & make\_cleanup\_set\_restore\_debugger\_mode() & objc-lang.c & \cxreffunc{make_cleanup_set_restore_debugger_mode}{objc-lang.c}\\
\ & new\_objc\_runtime\_class\_getClass() & objc-lang.c & \cxreffunc{new_objc_runtime_class_getClass}{objc-lang.c}\\
\ & new\_objc\_runtime\_find\_impl() & objc-lang.c & \cxreffunc{new_objc_runtime_find_impl}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & new\_objc\_runtime\_get\_classname() & objc-lang.c & \cxreffunc{new_objc_runtime_get_classname}{objc-lang.c}\\
\ & objc\_runtime\_lock\_taken\_p() & objc-lang.c & \cxreffunc{objc_runtime_lock_taken_p}{objc-lang.c}\\
\ & read\_objc\_object() & objc-lang.c & \cxreffunc{read_objc_object}{objc-lang.c}\\
Refs Var:\ & current\_target & target/target.c & \cxrefvar{current_target}{target/target.c}\\
\ & symbol\_generation & breakpoint.c & \cxrefvar{symbol_generation}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function lookup\_internalvar()}
\label{func_lookup_internalvar_value.c}

{\stt struct internalvar* lookup\_internalvar ( const char* name )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & \cxreftabiiispan{ concat(), strcmp()} &\\
Called by:\ & \_initialize\_tracepoint() & tracepoint.c & \cxreffunc{_initialize_tracepoint}{tracepoint.c}\\
\ & captured\_main() & main.c & \cxreffunc{captured_main}{main.c}\\
\ & decode\_dollar() & linespec.c & \cxreffunc{decode_dollar}{linespec.c}\\
\ & forward\_search\_command() & source.c & \cxreffunc{forward_search_command}{source.c}\\
\ & get\_number\_trailer() & breakpoint.c & \cxreffunc{get_number_trailer}{breakpoint.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & reverse\_search\_command() & source.c & \cxreffunc{reverse_search_command}{source.c}\\
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_input\_radix\_1() & valprint.c & \cxreffunc{set_input_radix_1}{valprint.c}\\
\ & set\_next\_address() & printcmd.c & \cxreffunc{set_next_address}{printcmd.c}\\
\ & set\_output\_radix\_1() & valprint.c & \cxreffunc{set_output_radix_1}{valprint.c}\\
\ & set\_traceframe\_context() & tracepoint.c & \cxreffunc{set_traceframe_context}{tracepoint.c}\\
\ & set\_traceframe\_num() & tracepoint.c & \cxreffunc{set_traceframe_num}{tracepoint.c}\\
\ & set\_tracepoint\_count() & tracepoint.c & \cxreffunc{set_tracepoint_count}{tracepoint.c}\\
\ & set\_tracepoint\_num() & tracepoint.c & \cxreffunc{set_tracepoint_num}{tracepoint.c}\\
\ & write\_dollar\_variable() & parse.c & \cxreffunc{write_dollar_variable}{parse.c}\\
\cxreftabbreak{cxreftabiii}
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
Refs Var:\ & builtin\_type\_void & gdbtypes.c & \cxrefvar{builtin_type_void}{gdbtypes.c}\\
\ & internalvars & value.c & \cxrefvar{internalvars}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function modify\_field()}
\label{func_modify_field_value.c}

{\stt void modify\_field ( gdb\_byte* addr, long fieldval, int bitpos, int bitsize )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & extract\_unsigned\_integer() & findvar.c & \cxreffunc{extract_unsigned_integer}{findvar.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\ & store\_unsigned\_integer() & findvar.c & \cxreffunc{store_unsigned_integer}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\ & modify\_general\_field() & ada-lang.c & \cxreffunc{modify_general_field}{ada-lang.c}\\
\ & set\_internalvar\_component() & value.c & \cxreffunc{set_internalvar_component}{value.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Global Function pack\_long()}
\label{func_pack_long_value.c}

{\stt void pack\_long ( gdb\_byte* buf, struct type* type, long num )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & store\_signed\_integer() & findvar.c & \cxreffunc{store_signed_integer}{findvar.c}\\
\ & store\_typed\_address() & findvar.c & \cxreffunc{store_typed_address}{findvar.c}\\
Called by:\ & dwarf2\_frame\_prev\_register() & dwarf2-frame.c & \cxreffunc{dwarf2_frame_prev_register}{dwarf2-frame.c}\\
\end{cxreftabiii}


\subsubsection{Global Function record\_latest\_value()}
\label{func_record_latest_value_value.c}

{\stt int record\_latest\_value ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & xmalloc() & utils.c & \cxreffunc{xmalloc}{utils.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memset\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memset\_chk()} &\\
Called by:\ & invoke\_block\_command() & printcmd.c & \cxreffunc{invoke_block_command}{printcmd.c}\\
\ & print\_command\_1() & printcmd.c & \cxreffunc{print_command_1}{printcmd.c}\\
\ & print\_return\_value() & infcmd.c & \cxreffunc{print_return_value}{infcmd.c}\\
Refs Var:\ & value\_history\_chain & value.c & \cxrefvar{value_history_chain}{value.c}\\
\ & value\_history\_count & value.c & \cxrefvar{value_history_count}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function release\_value()}
\label{func_release_value_value.c}

{\stt void release\_value ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & bpstat\_copy() & breakpoint.c & \cxreffunc{bpstat_copy}{breakpoint.c}\\
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & c\_value\_of\_root() & varobj.c & \cxreffunc{c_value_of_root}{varobj.c}\\
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & do\_examine() & printcmd.c & \cxreffunc{do_examine}{printcmd.c}\\
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & lookup\_internalvar() & value.c & \cxreffunc{lookup_internalvar}{value.c}\\
\ & make\_cleanup\_set\_restore\_debugger\_mode() & objc-lang.c & \cxreffunc{make_cleanup_set_restore_debugger_mode}{objc-lang.c}\\
\ & new\_objc\_runtime\_find\_impl() & objc-lang.c & \cxreffunc{new_objc_runtime_find_impl}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & new\_objc\_runtime\_get\_classname() & objc-lang.c & \cxreffunc{new_objc_runtime_get_classname}{objc-lang.c}\\
\ & record\_latest\_value() & value.c & \cxreffunc{record_latest_value}{value.c}\\
\ & set\_internalvar() & value.c & \cxreffunc{set_internalvar}{value.c}\\
\ & value\_of\_child() & varobj.c & \cxreffunc{value_of_child}{varobj.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\ & varobj\_set\_value() & varobj.c & \cxreffunc{varobj_set_value}{varobj.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\ & watchpoint\_check() & breakpoint.c & \cxreffunc{watchpoint_check}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
Refs Var:\ & all\_values & value.c & \cxrefvar{all_values}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_internalvar()}
\label{func_set_internalvar_value.c}

{\stt void set\_internalvar ( struct internalvar* var, struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & release\_value() & value.c & \cxreffunc{release_value}{value.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & \_initialize\_tracepoint() & tracepoint.c & \cxreffunc{_initialize_tracepoint}{tracepoint.c}\\
\ & captured\_main() & main.c & \cxreffunc{captured_main}{main.c}\\
\ & forward\_search\_command() & source.c & \cxreffunc{forward_search_command}{source.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\ & reverse\_search\_command() & source.c & \cxreffunc{reverse_search_command}{source.c}\\
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_input\_radix\_1() & valprint.c & \cxreffunc{set_input_radix_1}{valprint.c}\\
\ & set\_next\_address() & printcmd.c & \cxreffunc{set_next_address}{printcmd.c}\\
\ & set\_output\_radix\_1() & valprint.c & \cxreffunc{set_output_radix_1}{valprint.c}\\
\ & set\_traceframe\_context() & tracepoint.c & \cxreffunc{set_traceframe_context}{tracepoint.c}\\
\ & set\_traceframe\_num() & tracepoint.c & \cxreffunc{set_traceframe_num}{tracepoint.c}\\
\ & set\_tracepoint\_count() & tracepoint.c & \cxreffunc{set_tracepoint_count}{tracepoint.c}\\
\ & set\_tracepoint\_num() & tracepoint.c & \cxreffunc{set_tracepoint_num}{tracepoint.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_internalvar\_component()}
\label{func_set_internalvar_component_value.c}

{\stt void set\_internalvar\_component ( struct internalvar* var, int offset, int bitpos, int bitsize, struct value* newval )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & modify\_field() & value.c & \cxreffunc{modify_field}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_contents\_writeable() & value.c & \cxreffunc{value_contents_writeable}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_value\_bitpos()}
\label{func_set_value_bitpos_value.c}

{\stt void set\_value\_bitpos ( struct value* value, int bit )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function set\_value\_bitsize()}
\label{func_set_value_bitsize_value.c}

{\stt void set\_value\_bitsize ( struct value* value, int bit )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function set\_value\_embedded\_offset()}
\label{func_set_value_embedded_offset_value.c}

{\stt void set\_value\_embedded\_offset ( struct value* value, int val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function set\_value\_lazy()}
\label{func_set_value_lazy_value.c}

{\stt void set\_value\_lazy ( struct value* value, int val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & dwarf2\_evaluate\_loc\_desc() & dwarf2loc.c & \cxreffunc{dwarf2_evaluate_loc_desc}{dwarf2loc.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & java\_link\_class\_type() & jv-lang.c & \cxreffunc{java_link_class_type}{jv-lang.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & value\_at\_lazy() & valops.c & \cxreffunc{value_at_lazy}{valops.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_value\_offset()}
\label{func_set_value_offset_value.c}

{\stt void set\_value\_offset ( struct value* value, int offset )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_value\_optimized\_out()}
\label{func_set_value_optimized_out_value.c}

{\stt void set\_value\_optimized\_out ( struct value* value, enum opt\_state val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & dwarf2\_evaluate\_loc\_desc() & dwarf2loc.c & \cxreffunc{dwarf2_evaluate_loc_desc}{dwarf2loc.c}\\
\ & loclist\_read\_variable() & dwarf2loc.c & \cxreffunc{loclist_read_variable}{dwarf2loc.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\ & value\_of\_register() & findvar.c & \cxreffunc{value_of_register}{findvar.c}\\
\end{cxreftabiii}


\subsubsection{Global Function set\_value\_pointed\_to\_offset()}
\label{func_set_value_pointed_to_offset_value.c}

{\stt void set\_value\_pointed\_to\_offset ( struct value* value, int val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function set\_var\_status()}
\label{func_set_var_status_value.c}

{\stt void set\_var\_status ( struct value* val, int status )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & dwarf2\_evaluate\_loc\_desc() & dwarf2loc.c & \cxreffunc{dwarf2_evaluate_loc_desc}{dwarf2loc.c}\\
\end{cxreftabiii}


\subsubsection{Global Function unpack\_double()}
\label{func_unpack_double_value.c}

{\stt DOUBLEST unpack\_double ( struct type* type, const gdb\_byte* valaddr, int* invp )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & extract\_typed\_floating() & doublest.c & \cxreffunc{extract_typed_floating}{doublest.c}\\
\ & floatformat\_from\_type() & doublest.c & \cxreffunc{floatformat_from_type}{doublest.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & unpack\_long() & value.c & \cxreffunc{unpack_long}{value.c}\\
\ & \cxreftabiiispan{ floatformat\_is\_valid()} &\\
Called by:\ & print\_floating() & valprint.c & \cxreffunc{print_floating}{valprint.c}\\
\ & print\_floating\_in\_hex() & valprint.c & \cxreffunc{print_floating_in_hex}{valprint.c}\\
\ & value\_as\_double() & value.c & \cxreffunc{value_as_double}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function unpack\_field\_as\_long()}
\label{func_unpack_field_as_long_value.c}

{\stt long unpack\_field\_as\_long ( struct type* type, const gdb\_byte* valaddr, int fieldno )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & extract\_unsigned\_integer() & findvar.c & \cxreffunc{extract_unsigned_integer}{findvar.c}\\
\ & gdbarch\_byte\_order() & gdbarch.c & \cxreffunc{gdbarch_byte_order}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
Called by:\ & cp\_print\_value\_fields() & cp-valprint.c & \cxreffunc{cp_print_value_fields}{cp-valprint.c}\\
\ & java\_print\_value\_fields() & jv-valprint.c & \cxreffunc{java_print_value_fields}{jv-valprint.c}\\
\ & pascal\_object\_print\_value\_fields() & p-valprint.c & \cxreffunc{pascal_object_print_value_fields}{p-valprint.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Global Function unpack\_long()}
\label{func_unpack_long_value.c}

{\stt long unpack\_long ( struct type* type, const gdb\_byte* valaddr )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & extract\_signed\_integer\_with\_byte\_order() & findvar.c & \cxreffunc{extract_signed_integer_with_byte_order}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & extract\_typed\_address() & findvar.c & \cxreffunc{extract_typed_address}{findvar.c}\\
\ & extract\_typed\_floating() & doublest.c & \cxreffunc{extract_typed_floating}{doublest.c}\\
\ & extract\_unsigned\_integer\_with\_byte\_order() & findvar.c & \cxreffunc{extract_unsigned_integer_with_byte_order}{findvar.c}\\
\ & is\_scmvalue\_type() & scm-lang.c & \cxreffunc{is_scmvalue_type}{scm-lang.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & scm\_unpack() & scm-lang.c & \cxreffunc{scm_unpack}{scm-lang.c}\\
\ & unpack\_long() & value.c & \cxreffunc{unpack_long}{value.c}\\
Called by:\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_which\_variant\_applies() & ada-lang.c & \cxreffunc{ada_which_variant_applies}{ada-lang.c}\\
\ & c\_val\_print() & c-valprint.c & \cxreffunc{c_val_print}{c-valprint.c}\\
\ & cp\_print\_class\_member() & cp-valprint.c & \cxreffunc{cp_print_class_member}{cp-valprint.c}\\
\ & f\_val\_print() & f-valprint.c & \cxreffunc{f_val_print}{f-valprint.c}\\
\ & java\_val\_print() & jv-valprint.c & \cxreffunc{java_val_print}{jv-valprint.c}\\
\ & pascal\_object\_print\_class\_member() & p-valprint.c & \cxreffunc{pascal_object_print_class_member}{p-valprint.c}\\
\ & pascal\_val\_print() & p-valprint.c & \cxreffunc{pascal_val_print}{p-valprint.c}\\
\ & print\_ostype() & valprint.c & \cxreffunc{print_ostype}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & print\_scalar\_formatted() & printcmd.c & \cxreffunc{print_scalar_formatted}{printcmd.c}\\
\ & scm\_unpack() & scm-lang.c & \cxreffunc{scm_unpack}{scm-lang.c}\\
\ & unpack\_double() & value.c & \cxreffunc{unpack_double}{value.c}\\
\ & unpack\_long() & value.c & \cxreffunc{unpack_long}{value.c}\\
\ & unpack\_pointer() & value.c & \cxreffunc{unpack_pointer}{value.c}\\
\ & val\_print\_type\_code\_int() & valprint.c & \cxreffunc{val_print_type_code_int}{valprint.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_bit\_index() & valarith.c & \cxreffunc{value_bit_index}{valarith.c}\\
\ & value\_concat() & valarith.c & \cxreffunc{value_concat}{valarith.c}\\
Refs Var:\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function unpack\_pointer()}
\label{func_unpack_pointer_value.c}

{\stt CORE\_ADDR unpack\_pointer ( struct type* type, const gdb\_byte* valaddr )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & unpack\_long() & value.c & \cxreffunc{unpack_long}{value.c}\\
Called by:\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & c\_val\_print() & c-valprint.c & \cxreffunc{c_val_print}{c-valprint.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & cp\_print\_class\_method() & cp-valprint.c & \cxreffunc{cp_print_class_method}{cp-valprint.c}\\
\ & f\_val\_print() & f-valprint.c & \cxreffunc{f_val_print}{f-valprint.c}\\
\ & gnuv2\_baseclass\_offset() & gnu-v2-abi.c & \cxreffunc{gnuv2_baseclass_offset}{gnu-v2-abi.c}\\
\ & java\_val\_print() & jv-valprint.c & \cxreffunc{java_val_print}{jv-valprint.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & pascal\_object\_print\_class\_method() & p-valprint.c & \cxreffunc{pascal_object_print_class_method}{p-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & pascal\_val\_print() & p-valprint.c & \cxreffunc{pascal_val_print}{p-valprint.c}\\
\ & print\_scalar\_formatted() & printcmd.c & \cxreffunc{print_scalar_formatted}{printcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function using\_struct\_return()}
\label{func_using_struct_return_value.c}

{\stt int using\_struct\_return ( struct type* value\_type, int gcc\_p )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & gdbarch\_return\_value() & gdbarch.c & \cxreffunc{gdbarch_return_value}{gdbarch.c}\\
Called by:\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\cxreftabbreak{cxreftabiii}
\ & finish\_command() & infcmd.c & \cxreffunc{finish_command}{infcmd.c}\\
\ & finish\_command\_continuation() & infcmd.c & \cxreffunc{finish_command_continuation}{infcmd.c}\\
\ & finish\_inlined\_subroutine\_command() & infcmd.c & \cxreffunc{finish_inlined_subroutine_command}{infcmd.c}\\
\ & finish\_inlined\_subroutine\_command\_continuation() & infcmd.c & \cxreffunc{finish_inlined_subroutine_command_continuation}{infcmd.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & return\_command() & stack.c & \cxreffunc{return_command}{stack.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_as\_address()}
\label{func_value_as_address_value.c}

{\stt CORE\_ADDR value\_as\_address ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & gdbarch\_integer\_to\_address() & gdbarch.c & \cxreffunc{gdbarch_integer_to_address}{gdbarch.c}\\
\cxreftabbreak{cxreftabiii}
\ & gdbarch\_integer\_to\_address\_p() & gdbarch.c & \cxreffunc{gdbarch_integer_to_address_p}{gdbarch.c}\\
\ & unpack\_long() & value.c & \cxreffunc{unpack_long}{value.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_tag\_name\_1() & ada-lang.c & \cxreffunc{ada_tag_name_1}{ada-lang.c}\\
\ & ada\_value\_slice\_ptr() & ada-lang.c & \cxreffunc{ada_value_slice_ptr}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & debug\_load\_solib() & target/target.c & \cxreffunc{debug_load_solib}{target/target.c}\\
\cxreftabbreak{cxreftabiii}
\ & do\_one\_display() & printcmd.c & \cxreffunc{do_one_display}{printcmd.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & find\_function\_addr() & infcall.c & \cxreffunc{find_function_addr}{infcall.c}\\
\ & get\_class\_address\_from\_object() & objc-lang.c & \cxreffunc{get_class_address_from_object}{objc-lang.c}\\
\ & get\_closure\_implementation\_fn() & gdbtypes.c & \cxreffunc{get_closure_implementation_fn}{gdbtypes.c}\\
\ & gnuv2\_value\_rtti\_type() & gnu-v2-abi.c & \cxreffunc{gnuv2_value_rtti_type}{gnu-v2-abi.c}\\
\ & gnuv3\_baseclass\_offset() & gnu-v3-abi.c & \cxreffunc{gnuv3_baseclass_offset}{gnu-v3-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\ & gnuv3\_virtual\_fn\_field() & gnu-v3-abi.c & \cxreffunc{gnuv3_virtual_fn_field}{gnu-v3-abi.c}\\
\ & java\_class\_from\_object() & jv-lang.c & \cxreffunc{java_class_from_object}{jv-lang.c}\\
\ & java\_class\_is\_primitive() & jv-lang.c & \cxreffunc{java_class_is_primitive}{jv-lang.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & lookup\_objc\_class() & objc-lang.c & \cxreffunc{lookup_objc_class}{objc-lang.c}\\
\ & new\_objc\_runtime\_class\_getClass() & objc-lang.c & \cxreffunc{new_objc_runtime_class_getClass}{objc-lang.c}\\
\ & new\_objc\_runtime\_find\_impl() & objc-lang.c & \cxreffunc{new_objc_runtime_find_impl}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & new\_objc\_runtime\_get\_classname() & objc-lang.c & \cxreffunc{new_objc_runtime_get_classname}{objc-lang.c}\\
\ & parse\_and\_eval\_address() & eval.c & \cxreffunc{parse_and_eval_address}{eval.c}\\
\ & parse\_and\_eval\_address\_1() & eval.c & \cxreffunc{parse_and_eval_address_1}{eval.c}\\
\ & parse\_frame\_specification\_1() & stack.c & \cxreffunc{parse_frame_specification_1}{stack.c}\\
\ & print\_object\_command() & objc-lang.c & \cxreffunc{print_object_command}{objc-lang.c}\\
\ & printf\_command() & printcmd.c & \cxreffunc{printf_command}{printcmd.c}\\
\ & read\_objc\_object() & objc-lang.c & \cxreffunc{read_objc_object}{objc-lang.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_add() & valarith.c & \cxreffunc{value_add}{valarith.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_less() & valarith.c & \cxreffunc{value_less}{valarith.c}\\
\ & value\_objc\_target\_type() & objc-lang.c & \cxreffunc{value_objc_target_type}{objc-lang.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
Refs Var:\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_as\_double()}
\label{func_value_as_double_value.c}

{\stt DOUBLEST value\_as\_double ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\ & unpack\_double() & value.c & \cxreffunc{unpack_double}{value.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\ & printf\_command() & printcmd.c & \cxreffunc{printf_command}{printcmd.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_less() & valarith.c & \cxreffunc{value_less}{valarith.c}\\
\ & value\_logical\_not() & valarith.c & \cxreffunc{value_logical_not}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_neg() & valarith.c & \cxreffunc{value_neg}{valarith.c}\\
\ & value\_pos() & valarith.c & \cxreffunc{value_pos}{valarith.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_as\_long()}
\label{func_value_as_long_value.c}

{\stt long value\_as\_long ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & unpack\_long() & value.c & \cxreffunc{unpack_long}{value.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & ada\_value\_binop() & ada-lang.c & \cxreffunc{ada_value_binop}{ada-lang.c}\\
\ & allocate\_space\_in\_inferior\_malloc() & valops.c & \cxreffunc{allocate_space_in_inferior_malloc}{valops.c}\\
\ & cast\_from\_fixed\_to\_double() & ada-lang.c & \cxreffunc{cast_from_fixed_to_double}{ada-lang.c}\\
\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\ & decode\_dollar() & linespec.c & \cxreffunc{decode_dollar}{linespec.c}\\
\cxreftabbreak{cxreftabiii}
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & do\_captured\_thread\_select() & thread.c & \cxreffunc{do_captured_thread_select}{thread.c}\\
\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & execute\_stack\_op() & dwarf2expr.c & \cxreffunc{execute_stack_op}{dwarf2expr.c}\\
\ & find\_function\_addr() & infcall.c & \cxreffunc{find_function_addr}{infcall.c}\\
\ & find\_rt\_vbase\_offset() & valops.c & \cxreffunc{find_rt_vbase_offset}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & gen\_expr() & ax-gdb.c & \cxreffunc{gen_expr}{ax-gdb.c}\\
\ & gen\_repeat() & ax-gdb.c & \cxreffunc{gen_repeat}{ax-gdb.c}\\
\ & get\_int\_var\_value() & ada-lang.c & \cxreffunc{get_int_var_value}{ada-lang.c}\\
\ & get\_java\_utf8\_name() & jv-lang.c & \cxreffunc{get_java_utf8_name}{jv-lang.c}\\
\ & get\_number\_trailer() & breakpoint.c & \cxreffunc{get_number_trailer}{breakpoint.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & gnuv3\_baseclass\_offset() & gnu-v3-abi.c & \cxreffunc{gnuv3_baseclass_offset}{gnu-v3-abi.c}\\
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & hpacc\_value\_rtti\_type() & hpacc-abi.c & \cxreffunc{hpacc_value_rtti_type}{hpacc-abi.c}\\
\ & ignore\_command() & breakpoint.c & \cxreffunc{ignore_command}{breakpoint.c}\\
\ & init\_array\_element() & eval.c & \cxreffunc{init_array_element}{eval.c}\\
\ & java\_link\_class\_type() & jv-lang.c & \cxreffunc{java_link_class_type}{jv-lang.c}\\
\ & lookup\_child\_selector\_nocache() & objc-lang.c & \cxreffunc{lookup_child_selector_nocache}{objc-lang.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\ & make\_cleanup\_set\_restore\_debugger\_mode() & objc-lang.c & \cxreffunc{make_cleanup_set_restore_debugger_mode}{objc-lang.c}\\
\ & objc\_runtime\_lock\_taken\_p() & objc-lang.c & \cxreffunc{objc_runtime_lock_taken_p}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & parse\_and\_eval\_long() & eval.c & \cxreffunc{parse_and_eval_long}{eval.c}\\
\ & parse\_frame\_specification\_1() & stack.c & \cxreffunc{parse_frame_specification_1}{stack.c}\\
\ & pos\_atr() & ada-lang.c & \cxreffunc{pos_atr}{ada-lang.c}\\
\ & print\_single\_dwarf\_location() & dwarf2loc.c & \cxreffunc{print_single_dwarf_location}{dwarf2loc.c}\\
\ & printf\_command() & printcmd.c & \cxreffunc{printf_command}{printcmd.c}\\
\ & quit\_force() & top.c & \cxreffunc{quit_force}{top.c}\\
\ & scan\_discrim\_bound() & ada-lang.c & \cxreffunc{scan_discrim_bound}{ada-lang.c}\\
\ & scm\_evaluate\_string() & scm-lang.c & \cxreffunc{scm_evaluate_string}{scm-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & scm\_lookup\_name() & scm-lang.c & \cxreffunc{scm_lookup_name}{scm-lang.c}\\
\ & set\_internalvar\_component() & value.c & \cxreffunc{set_internalvar_component}{value.c}\\
\ & type\_from\_class() & jv-lang.c & \cxreffunc{type_from_class}{jv-lang.c}\\
\ & value\_add() & valarith.c & \cxreffunc{value_add}{valarith.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_complement() & valarith.c & \cxreffunc{value_complement}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_concat() & valarith.c & \cxreffunc{value_concat}{valarith.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_in() & valarith.c & \cxreffunc{value_in}{valarith.c}\\
\ & value\_less() & valarith.c & \cxreffunc{value_less}{valarith.c}\\
\ & value\_neg() & valarith.c & \cxreffunc{value_neg}{valarith.c}\\
\ & value\_pos() & valarith.c & \cxreffunc{value_pos}{valarith.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_subscript\_packed() & ada-lang.c & \cxreffunc{value_subscript_packed}{ada-lang.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\ & value\_val\_atr() & ada-lang.c & \cxreffunc{value_val_atr}{ada-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_bitpos()}
\label{func_value_bitpos_value.c}

{\stt int value\_bitpos ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_bitsize()}
\label{func_value_bitsize_value.c}

{\stt int value\_bitsize ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function value\_change\_enclosing\_type()}
\label{func_value_change_enclosing_type_value.c}

{\stt struct value* value\_change\_enclosing\_type ( struct value* val, struct type* new\_encl\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & xrealloc() & utils.c & \cxreffunc{xrealloc}{utils.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
Refs Var:\ & all\_values & value.c & \cxrefvar{all_values}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_contents()}
\label{func_value_contents_value.c}

{\stt const gdb\_byte* value\_contents ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & value\_contents\_writeable() & value.c & \cxreffunc{value_contents_writeable}{value.c}\\
Called by:\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_equal() & ada-lang.c & \cxreffunc{ada_value_equal}{ada-lang.c}\\
\ & ada\_value\_primitive\_field() & ada-lang.c & \cxreffunc{ada_value_primitive_field}{ada-lang.c}\\
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & c\_val\_print() & c-valprint.c & \cxreffunc{c_val_print}{c-valprint.c}\\
\ & cast\_into\_complex() & valops.c & \cxreffunc{cast_into_complex}{valops.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & hpacc\_value\_rtti\_type() & hpacc-abi.c & \cxreffunc{hpacc_value_rtti_type}{hpacc-abi.c}\\
\ & hpacc\_virtual\_fn\_field() & hpacc-abi.c & \cxreffunc{hpacc_virtual_fn_field}{hpacc-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & init\_array\_element() & eval.c & \cxreffunc{init_array_element}{eval.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & pascal\_object\_print\_static\_field() & p-valprint.c & \cxreffunc{pascal_object_print_static_field}{p-valprint.c}\\
\ & print\_field\_values() & ada-valprint.c & \cxreffunc{print_field_values}{ada-valprint.c}\\
\ & print\_formatted() & printcmd.c & \cxreffunc{print_formatted}{printcmd.c}\\
\ & return\_command() & stack.c & \cxreffunc{return_command}{stack.c}\\
\ & scm\_lreadr() & scm-exp.c & \cxreffunc{scm_lreadr}{scm-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\ & set\_internalvar\_component() & value.c & \cxreffunc{set_internalvar_component}{value.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\ & val\_print\_packed\_array\_elements() & ada-valprint.c & \cxreffunc{val_print_packed_array_elements}{ada-valprint.c}\\
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_as\_double() & value.c & \cxreffunc{value_as_double}{value.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_concat() & valarith.c & \cxreffunc{value_concat}{valarith.c}\\
\ & value\_contents\_equal() & value.c & \cxreffunc{value_contents_equal}{value.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_in() & valarith.c & \cxreffunc{value_in}{valarith.c}\\
\ & value\_literal\_complex() & valops.c & \cxreffunc{value_literal_complex}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_logical\_not() & valarith.c & \cxreffunc{value_logical_not}{valarith.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_strcmp() & valarith.c & \cxreffunc{value_strcmp}{valarith.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\ & watchpoint\_equal() & breakpoint.c & \cxreffunc{watchpoint_equal}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_contents\_all()}
\label{func_value_contents_all_value.c}

{\stt const gdb\_byte* value\_contents\_all ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
Called by:\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\ & common\_val\_print() & valprint.c & \cxreffunc{common_val_print}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & cp\_print\_static\_field() & cp-valprint.c & \cxreffunc{cp_print_static_field}{cp-valprint.c}\\
\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & hpacc\_value\_rtti\_type() & hpacc-abi.c & \cxreffunc{hpacc_value_rtti_type}{hpacc-abi.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\ & value\_array() & valops.c & \cxreffunc{value_array}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_contents\_all\_raw()}
\label{func_value_contents_all_raw_value.c}

{\stt gdb\_byte* value\_contents\_all\_raw ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & value\_array() & valops.c & \cxreffunc{value_array}{valops.c}\\
\ & value\_at() & valops.c & \cxreffunc{value_at}{valops.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_repeat() & valops.c & \cxreffunc{value_repeat}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_contents\_equal()}
\label{func_value_contents_equal_value.c}

{\stt int value\_contents\_equal ( struct value* val1, struct value* val2 )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\ & \cxreftabiiispan{ memcmp()} &\\
\end{cxreftabiii}


\subsubsection{Global Function value\_contents\_raw()}
\label{func_value_contents_raw_value.c}

{\stt gdb\_byte* value\_contents\_raw ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_binop() & ada-lang.c & \cxreffunc{ada_value_binop}{ada-lang.c}\\
\ & cast\_into\_complex() & valops.c & \cxreffunc{cast_into_complex}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & dwarf2\_evaluate\_loc\_desc() & dwarf2loc.c & \cxreffunc{dwarf2_evaluate_loc_desc}{dwarf2loc.c}\\
\ & ensure\_lval() & ada-lang.c & \cxreffunc{ensure_lval}{ada-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & init\_array\_element() & eval.c & \cxreffunc{init_array_element}{eval.c}\\
\ & print\_return\_value() & infcmd.c & \cxreffunc{print_return_value}{infcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & set\_traceframe\_context() & tracepoint.c & \cxreffunc{set_traceframe_context}{tracepoint.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_bitstring() & valops.c & \cxreffunc{value_bitstring}{valops.c}\\
\ & value\_contents\_writeable() & value.c & \cxreffunc{value_contents_writeable}{value.c}\\
\ & value\_from\_contents\_and\_address() & ada-lang.c & \cxreffunc{value_from_contents_and_address}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_from\_double() & value.c & \cxreffunc{value_from_double}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_from\_pointer() & value.c & \cxreffunc{value_from_pointer}{value.c}\\
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\ & value\_from\_string() & value.c & \cxreffunc{value_from_string}{value.c}\\
\ & value\_literal\_complex() & valops.c & \cxreffunc{value_literal_complex}{valops.c}\\
\ & value\_of\_builtin\_frame\_fp\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_fp_reg}{std-regs.c}\\
\ & value\_of\_builtin\_frame\_pc\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_pc_reg}{std-regs.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_of\_builtin\_frame\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_reg}{std-regs.c}\\
\ & value\_of\_register() & findvar.c & \cxreffunc{value_of_register}{findvar.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_string() & valops.c & \cxreffunc{value_string}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_contents\_writeable()}
\label{func_value_contents_writeable_value.c}

{\stt gdb\_byte* value\_contents\_writeable ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
Called by:\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & cp\_print\_hpacc\_virtual\_table\_entries() & cp-valprint.c & \cxreffunc{cp_print_hpacc_virtual_table_entries}{cp-valprint.c}\\
\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\ & set\_internalvar\_component() & value.c & \cxreffunc{set_internalvar_component}{value.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function value\_copy()}
\label{func_value_copy_value.c}

{\stt struct value* value\_copy ( struct value* arg )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_frame\_id\_hack() & value.c & \cxreffunc{deprecated_value_frame_id_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & deprecated\_value\_regnum\_hack() & value.c & \cxreffunc{deprecated_value_regnum_hack}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & value\_contents\_all\_raw() & value.c & \cxreffunc{value_contents_all_raw}{value.c}\\
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & access\_value\_history() & value.c & \cxreffunc{access_value_history}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_ptr\_subscript() & ada-lang.c & \cxreffunc{ada_value_ptr_subscript}{ada-lang.c}\\
\ & bpstat\_copy() & breakpoint.c & \cxreffunc{bpstat_copy}{breakpoint.c}\\
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\ & cp\_print\_hpacc\_virtual\_table\_entries() & cp-valprint.c & \cxreffunc{cp_print_hpacc_virtual_table_entries}{cp-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
\ & set\_internalvar() & value.c & \cxreffunc{set_internalvar}{value.c}\\
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_of\_internalvar() & value.c & \cxreffunc{value_of_internalvar}{value.c}\\
\ & varobj\_fixup\_value() & varobj.c & \cxreffunc{varobj_fixup_value}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_embedded\_offset()}
\label{func_value_embedded_offset_value.c}

{\stt int value\_embedded\_offset ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\ & common\_val\_print() & valprint.c & \cxreffunc{common_val_print}{valprint.c}\\
\ & cp\_print\_static\_field() & cp-valprint.c & \cxreffunc{cp_print_static_field}{cp-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\ & hpacc\_value\_rtti\_type() & hpacc-abi.c & \cxreffunc{hpacc_value_rtti_type}{hpacc-abi.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_enclosing\_type()}
\label{func_value_enclosing_type_value.c}

{\stt struct type* value\_enclosing\_type ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\cxreftabbreak{cxreftabiii}
\ & hpacc\_value\_rtti\_type() & hpacc-abi.c & \cxreffunc{hpacc_value_rtti_type}{hpacc-abi.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_array() & valops.c & \cxreffunc{value_array}{valops.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_change\_enclosing\_type() & value.c & \cxreffunc{value_change_enclosing_type}{value.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_repeat() & valops.c & \cxreffunc{value_repeat}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_field()}
\label{func_value_field_value.c}

{\stt struct value* value\_field ( struct value* arg1, int fieldno )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
Called by:\ & gnuv2\_value\_rtti\_type() & gnu-v2-abi.c & \cxreffunc{gnuv2_value_rtti_type}{gnu-v2-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & gnuv3\_baseclass\_offset() & gnu-v3-abi.c & \cxreffunc{gnuv3_baseclass_offset}{gnu-v3-abi.c}\\
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\ & gnuv3\_virtual\_fn\_field() & gnu-v3-abi.c & \cxreffunc{gnuv3_virtual_fn_field}{gnu-v3-abi.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_fn\_field()}
\label{func_value_fn_field_value.c}

{\stt struct value* value\_fn\_field ( struct value** arg1p, struct fn\_field* f, int j, struct type* type, int offset )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & internal\_error() & utils.c & \cxreffunc{internal_error}{utils.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\ & lookup\_pointer\_type() & gdbtypes.c & \cxreffunc{lookup_pointer_type}{gdbtypes.c}\\
\ & lookup\_symbol() & symtab.c & \cxreffunc{lookup_symbol}{symtab.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_cast() & valops.c & \cxreffunc{value_cast}{valops.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_type() & value.c & \cxreffunc{value_type}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_free()}
\label{func_value_free_value.c}

{\stt void value\_free ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & xfree() & utils.c & \cxreffunc{xfree}{utils.c}\\
Called by:\ & bpstat\_clear() & breakpoint.c & \cxreffunc{bpstat_clear}{breakpoint.c}\\
\ & bpstat\_clear\_actions() & breakpoint.c & \cxreffunc{bpstat_clear_actions}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_init\_inferior() & breakpoint.c & \cxreffunc{breakpoint_init_inferior}{breakpoint.c}\\
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
\ & delete\_breakpoint() & breakpoint.c & \cxreffunc{delete_breakpoint}{breakpoint.c}\\
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & do\_examine() & printcmd.c & \cxreffunc{do_examine}{printcmd.c}\\
\ & free\_all\_values() & value.c & \cxreffunc{free_all_values}{value.c}\\
\ & free\_valchain() & breakpoint.c & \cxreffunc{free_valchain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & free\_variable() & varobj.c & \cxreffunc{free_variable}{varobj.c}\\
\ & print\_it\_typical() & breakpoint.c & \cxreffunc{print_it_typical}{breakpoint.c}\\
\ & value\_free\_to\_mark() & value.c & \cxreffunc{value_free_to_mark}{value.c}\\
\ & value\_of\_child() & varobj.c & \cxreffunc{value_of_child}{varobj.c}\\
\ & varobj\_set\_value() & varobj.c & \cxreffunc{varobj_set_value}{varobj.c}\\
\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
Used in:\ & make\_cleanup\_set\_restore\_debugger\_mode() & objc-lang.c & \cxreffunc{make_cleanup_set_restore_debugger_mode}{objc-lang.c}\\
\ & new\_objc\_runtime\_find\_impl() & objc-lang.c & \cxreffunc{new_objc_runtime_find_impl}{objc-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & new\_objc\_runtime\_get\_classname() & objc-lang.c & \cxreffunc{new_objc_runtime_get_classname}{objc-lang.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_free\_to\_mark()}
\label{func_value_free_to_mark_value.c}

{\stt void value\_free\_to\_mark ( struct value* mark )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & value\_free() & value.c & \cxreffunc{value_free}{value.c}\\
Called by:\ & ada\_coerce\_to\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_type}{ada-lang.c}\\
\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & breakpoint\_cond\_eval() & breakpoint.c & \cxreffunc{breakpoint_cond_eval}{breakpoint.c}\\
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\ & val\_print\_packed\_array\_elements() & ada-valprint.c & \cxreffunc{val_print_packed_array_elements}{ada-valprint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & watchpoint\_check() & breakpoint.c & \cxreffunc{watchpoint_check}{breakpoint.c}\\
Refs Var:\ & all\_values & value.c & \cxrefvar{all_values}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_from\_double()}
\label{func_value_from_double_value.c}

{\stt struct value* value\_from\_double ( struct type* type, DOUBLEST num )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & store\_typed\_floating() & doublest.c & \cxreffunc{store_typed_floating}{doublest.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
Called by:\ & cast\_from\_fixed\_to\_double() & ada-lang.c & \cxreffunc{cast_from_fixed_to_double}{ada-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & print\_subexp\_standard() & expprint.c & \cxreffunc{print_subexp_standard}{expprint.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_neg() & valarith.c & \cxreffunc{value_neg}{valarith.c}\\
\ & value\_pos() & valarith.c & \cxreffunc{value_pos}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\end{cxreftabiii}


\subsubsection{Global Function value\_from\_longest()}
\label{func_value_from_longest_value.c}

{\stt struct value* value\_from\_longest ( struct type* type, long num )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & error() & utils.c & \cxreffunc{error}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & store\_signed\_integer() & findvar.c & \cxreffunc{store_signed_integer}{findvar.c}\\
\ & store\_typed\_address() & findvar.c & \cxreffunc{store_typed_address}{findvar.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
Called by:\ & \_initialize\_tracepoint() & tracepoint.c & \cxreffunc{_initialize_tracepoint}{tracepoint.c}\\
\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_ptr\_subscript() & ada-lang.c & \cxreffunc{ada_value_ptr_subscript}{ada-lang.c}\\
\ & allocate\_space\_in\_inferior\_malloc() & valops.c & \cxreffunc{allocate_space_in_inferior_malloc}{valops.c}\\
\ & c\_value\_of\_child() & varobj.c & \cxreffunc{c_value_of_child}{varobj.c}\\
\ & captured\_main() & main.c & \cxreffunc{captured_main}{main.c}\\
\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\ & const\_expr() & ax-gdb.c & \cxreffunc{const_expr}{ax-gdb.c}\\
\cxreftabbreak{cxreftabiii}
\ & const\_var\_ref() & ax-gdb.c & \cxreffunc{const_var_ref}{ax-gdb.c}\\
\ & cp\_print\_value\_fields() & cp-valprint.c & \cxreffunc{cp_print_value_fields}{cp-valprint.c}\\
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & discrete\_type\_high\_bound() & ada-lang.c & \cxreffunc{discrete_type_high_bound}{ada-lang.c}\\
\ & discrete\_type\_low\_bound() & ada-lang.c & \cxreffunc{discrete_type_low_bound}{ada-lang.c}\\
\ & evaluate\_subexp\_for\_sizeof() & eval.c & \cxreffunc{evaluate_subexp_for_sizeof}{eval.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_scm() & scm-lang.c & \cxreffunc{evaluate_subexp_scm}{scm-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & execute\_stack\_op() & dwarf2expr.c & \cxreffunc{execute_stack_op}{dwarf2expr.c}\\
\ & find\_function\_in\_inferior() & valops.c & \cxreffunc{find_function_in_inferior}{valops.c}\\
\ & forward\_search\_command() & source.c & \cxreffunc{forward_search_command}{source.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & gnuv3\_baseclass\_offset() & gnu-v3-abi.c & \cxreffunc{gnuv3_baseclass_offset}{gnu-v3-abi.c}\\
\ & gnuv3\_virtual\_fn\_field() & gnu-v3-abi.c & \cxreffunc{gnuv3_virtual_fn_field}{gnu-v3-abi.c}\\
\ & handle\_inferior\_event() & infrun.c & \cxreffunc{handle_inferior_event}{infrun.c}\\
\cxreftabbreak{cxreftabiii}
\ & java\_print\_value\_fields() & jv-valprint.c & \cxreffunc{java_print_value_fields}{jv-valprint.c}\\
\ & make\_cleanup\_set\_restore\_debugger\_mode() & objc-lang.c & \cxreffunc{make_cleanup_set_restore_debugger_mode}{objc-lang.c}\\
\ & pascal\_object\_print\_value\_fields() & p-valprint.c & \cxreffunc{pascal_object_print_value_fields}{p-valprint.c}\\
\ & print\_scalar\_formatted() & printcmd.c & \cxreffunc{print_scalar_formatted}{printcmd.c}\\
\ & print\_single\_dwarf\_location() & dwarf2loc.c & \cxreffunc{print_single_dwarf_location}{dwarf2loc.c}\\
\ & print\_subexp\_standard() & expprint.c & \cxreffunc{print_subexp_standard}{expprint.c}\\
\ & reverse\_search\_command() & source.c & \cxreffunc{reverse_search_command}{source.c}\\
\ & scm\_lookup\_name() & scm-lang.c & \cxreffunc{scm_lookup_name}{scm-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & set\_breakpoint\_count() & breakpoint.c & \cxreffunc{set_breakpoint_count}{breakpoint.c}\\
\ & set\_input\_radix\_1() & valprint.c & \cxreffunc{set_input_radix_1}{valprint.c}\\
\ & set\_output\_radix\_1() & valprint.c & \cxreffunc{set_output_radix_1}{valprint.c}\\
\ & set\_traceframe\_context() & tracepoint.c & \cxreffunc{set_traceframe_context}{tracepoint.c}\\
\ & set\_traceframe\_num() & tracepoint.c & \cxreffunc{set_traceframe_num}{tracepoint.c}\\
\ & set\_tracepoint\_count() & tracepoint.c & \cxreffunc{set_tracepoint_count}{tracepoint.c}\\
\ & set\_tracepoint\_num() & tracepoint.c & \cxreffunc{set_tracepoint_num}{tracepoint.c}\\
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_allocate\_space\_in\_inferior() & valops.c & \cxreffunc{value_allocate_space_in_inferior}{valops.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_complement() & valarith.c & \cxreffunc{value_complement}{valarith.c}\\
\ & value\_in() & valarith.c & \cxreffunc{value_in}{valarith.c}\\
\ & value\_neg() & valarith.c & \cxreffunc{value_neg}{valarith.c}\\
\ & value\_nsstring() & objc-lang.c & \cxreffunc{value_nsstring}{objc-lang.c}\\
\ & value\_pos() & valarith.c & \cxreffunc{value_pos}{valarith.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_pos\_atr() & ada-lang.c & \cxreffunc{value_pos_atr}{ada-lang.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_struct\_elt\_for\_reference() & valops.c & \cxreffunc{value_struct_elt_for_reference}{valops.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_val\_atr() & ada-lang.c & \cxreffunc{value_val_atr}{ada-lang.c}\\
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_from\_pointer()}
\label{func_value_from_pointer_value.c}

{\stt struct value* value\_from\_pointer ( struct type* type, CORE\_ADDR addr )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & store\_typed\_address() & findvar.c & \cxreffunc{store_typed_address}{findvar.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\cxreftabbreak{cxreftabiii}
Called by:\ & ada\_value\_slice\_ptr() & ada-lang.c & \cxreffunc{ada_value_slice_ptr}{ada-lang.c}\\
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & const\_var\_ref() & ax-gdb.c & \cxreffunc{const_var_ref}{ax-gdb.c}\\
\ & cp\_print\_value\_fields() & cp-valprint.c & \cxreffunc{cp_print_value_fields}{cp-valprint.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & get\_class\_address\_from\_object() & objc-lang.c & \cxreffunc{get_class_address_from_object}{objc-lang.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & locate\_var\_value() & findvar.c & \cxreffunc{locate_var_value}{findvar.c}\\
\cxreftabbreak{cxreftabiii}
\ & new\_objc\_runtime\_find\_impl() & objc-lang.c & \cxreffunc{new_objc_runtime_find_impl}{objc-lang.c}\\
\ & new\_objc\_runtime\_get\_classname() & objc-lang.c & \cxreffunc{new_objc_runtime_get_classname}{objc-lang.c}\\
\ & read\_objc\_object() & objc-lang.c & \cxreffunc{read_objc_object}{objc-lang.c}\\
\ & set\_next\_address() & printcmd.c & \cxreffunc{set_next_address}{printcmd.c}\\
\ & set\_traceframe\_context() & tracepoint.c & \cxreffunc{set_traceframe_context}{tracepoint.c}\\
\ & value\_add() & valarith.c & \cxreffunc{value_add}{valarith.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\ & value\_coerce\_function() & valops.c & \cxreffunc{value_coerce_function}{valops.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_from\_string()}
\label{func_value_from_string_value.c}

{\stt struct value* value\_from\_string ( char* ptr )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & create\_array\_type() & gdbtypes.c & \cxreffunc{create_array_type}{gdbtypes.c}\\
\ & create\_range\_type() & gdbtypes.c & \cxreffunc{create_range_type}{gdbtypes.c}\\
\cxreftabbreak{cxreftabiii}
\ & language\_string\_char\_type() & language.c & \cxreffunc{language_string_char_type}{language.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk(), strlen()} &\\
Refs Var:\ & builtin\_type\_int & gdbtypes.c & \cxrefvar{builtin_type_int}{gdbtypes.c}\\
\ & current\_gdbarch & gdbarch.c & \cxrefvar{current_gdbarch}{gdbarch.c}\\
\ & current\_language & language.c & \cxrefvar{current_language}{language.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_lazy()}
\label{func_value_lazy_value.c}

{\stt int value\_lazy ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & c\_value\_of\_root() & varobj.c & \cxreffunc{c_value_of_root}{varobj.c}\\
\ & c\_value\_of\_variable() & varobj.c & \cxreffunc{c_value_of_variable}{varobj.c}\\
\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & cp\_print\_hpacc\_virtual\_table\_entries() & cp-valprint.c & \cxreffunc{cp_print_hpacc_virtual_table_entries}{cp-valprint.c}\\
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & insert\_breakpoints() & breakpoint.c & \cxreffunc{insert_breakpoints}{breakpoint.c}\\
\ & locate\_var\_value() & findvar.c & \cxreffunc{locate_var_value}{findvar.c}\\
\ & my\_value\_equal() & varobj.c & \cxreffunc{my_value_equal}{varobj.c}\\
\ & record\_latest\_value() & value.c & \cxreffunc{record_latest_value}{value.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & return\_command() & stack.c & \cxreffunc{return_command}{stack.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & set\_internalvar() & value.c & \cxreffunc{set_internalvar}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\ & value\_of\_child() & varobj.c & \cxreffunc{value_of_child}{varobj.c}\\
\ & value\_of\_internalvar() & value.c & \cxreffunc{value_of_internalvar}{value.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\ & varobj\_update() & varobj.c & \cxreffunc{varobj_update}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_mark()}
\label{func_value_mark_value.c}

{\stt struct value* value\_mark ( void )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_coerce\_to\_simple\_array\_type() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_type}{ada-lang.c}\\
\ & ada\_template\_to\_fixed\_record\_type\_1() & ada-lang.c & \cxreffunc{ada_template_to_fixed_record_type_1}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & breakpoint\_cond\_eval() & breakpoint.c & \cxreffunc{breakpoint_cond_eval}{breakpoint.c}\\
\ & breakpoint\_re\_set\_one() & breakpoint.c & \cxreffunc{breakpoint_re_set_one}{breakpoint.c}\\
\ & do\_enable\_breakpoint() & breakpoint.c & \cxreffunc{do_enable_breakpoint}{breakpoint.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & to\_record\_with\_fixed\_variant\_part() & ada-lang.c & \cxreffunc{to_record_with_fixed_variant_part}{ada-lang.c}\\
\ & val\_print\_packed\_array\_elements() & ada-valprint.c & \cxreffunc{val_print_packed_array_elements}{ada-valprint.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & watchpoint\_check() & breakpoint.c & \cxreffunc{watchpoint_check}{breakpoint.c}\\
Refs Var:\ & all\_values & value.c & \cxrefvar{all_values}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_next()}
\label{func_value_next_value.c}

{\stt struct value* value\_next ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\ & free\_valchain() & breakpoint.c & \cxreffunc{free_valchain}{breakpoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_of\_internalvar()}
\label{func_value_of_internalvar_value.c}

{\stt struct value* value\_of\_internalvar ( struct internalvar* var )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & deprecated\_value\_internalvar\_hack() & value.c & \cxreffunc{deprecated_value_internalvar_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & value\_copy() & value.c & \cxreffunc{value_copy}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
Called by:\ & decode\_dollar() & linespec.c & \cxreffunc{decode_dollar}{linespec.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & get\_number\_trailer() & breakpoint.c & \cxreffunc{get_number_trailer}{breakpoint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_offset()}
\label{func_value_offset_value.c}

{\stt int value\_offset ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_to\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_fixed_value}{ada-lang.c}\\
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_primitive\_packed\_val() & ada-lang.c & \cxreffunc{ada_value_primitive_packed_val}{ada-lang.c}\\
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & encode\_actions() & tracepoint.c & \cxreffunc{encode_actions}{tracepoint.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & find\_method\_list() & valops.c & \cxreffunc{find_method_list}{valops.c}\\
\ & get\_java\_utf8\_name() & jv-lang.c & \cxreffunc{get_java_utf8_name}{jv-lang.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\ & hpacc\_value\_rtti\_type() & hpacc-abi.c & \cxreffunc{hpacc_value_rtti_type}{hpacc-abi.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & java\_link\_class\_type() & jv-lang.c & \cxreffunc{java_link_class_type}{jv-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & search\_struct\_method() & valops.c & \cxreffunc{search_struct_method}{valops.c}\\
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\ & type\_from\_class() & jv-lang.c & \cxreffunc{type_from_class}{jv-lang.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\ & value\_coerce\_function() & valops.c & \cxreffunc{value_coerce_function}{valops.c}\\
\ & value\_fetch\_lazy() & valops.c & \cxreffunc{value_fetch_lazy}{valops.c}\\
\ & value\_from\_register() & findvar.c & \cxreffunc{value_from_register}{findvar.c}\\
\ & value\_primitive\_field() & value.c & \cxreffunc{value_primitive_field}{value.c}\\
\ & value\_repeat() & valops.c & \cxreffunc{value_repeat}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_optimized\_out()}
\label{func_value_optimized_out_value.c}

{\stt enum opt\_state value\_optimized\_out ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & value\_check\_printable() & valprint.c & \cxreffunc{value_check_printable}{valprint.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_pointed\_to\_offset()}
\label{func_value_pointed_to_offset_value.c}

{\stt int value\_pointed\_to\_offset ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_primitive\_field()}
\label{func_value_primitive_field_value.c}

{\stt struct value* value\_primitive\_field ( struct value* arg1, int offset, int fieldno, struct type* arg\_type )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & allocate\_value() & value.c & \cxreffunc{allocate_value}{value.c}\\
\ & check\_typedef() & gdbtypes.c & \cxreffunc{check_typedef}{gdbtypes.c}\\
\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & deprecated\_value\_frame\_id\_hack() & value.c & \cxreffunc{deprecated_value_frame_id_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & deprecated\_value\_regnum\_hack() & value.c & \cxreffunc{deprecated_value_regnum_hack}{value.c}\\
\ & objc\_fixup\_class\_length() & objc-lang.c & \cxreffunc{objc_fixup_class_length}{objc-lang.c}\\
\ & objc\_fixup\_ivar\_offset() & objc-lang.c & \cxreffunc{objc_fixup_ivar_offset}{objc-lang.c}\\
\ & set\_value\_lazy() & value.c & \cxreffunc{set_value_lazy}{value.c}\\
\ & unpack\_field\_as\_long() & value.c & \cxreffunc{unpack_field_as_long}{value.c}\\
\ & value\_contents() & value.c & \cxreffunc{value_contents}{value.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_contents\_all\_raw() & value.c & \cxreffunc{value_contents_all_raw}{value.c}\\
\ & value\_contents\_raw() & value.c & \cxreffunc{value_contents_raw}{value.c}\\
\ & value\_embedded\_offset() & value.c & \cxreffunc{value_embedded_offset}{value.c}\\
\ & value\_enclosing\_type() & value.c & \cxreffunc{value_enclosing_type}{value.c}\\
\ & value\_from\_longest() & value.c & \cxreffunc{value_from_longest}{value.c}\\
\ & value\_lazy() & value.c & \cxreffunc{value_lazy}{value.c}\\
\ & value\_offset() & value.c & \cxreffunc{value_offset}{value.c}\\
\ & \cxreftabiiispan{ \_\_builtin\_\_\_memcpy\_chk(), \_\_builtin\_object\_size(), \_\_inline\_memcpy\_chk()} &\\
Called by:\ & ada\_value\_primitive\_field() & ada-lang.c & \cxreffunc{ada_value_primitive_field}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\ & value\_field() & value.c & \cxreffunc{value_field}{value.c}\\
\ & varobj\_value\_struct\_elt\_by\_index() & varobj.c & \cxreffunc{varobj_value_struct_elt_by_index}{varobj.c}\\
Refs Var:\ & cplus\_struct\_default & gdbtypes.c & \cxrefvar{cplus_struct_default}{gdbtypes.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_release\_to\_mark()}
\label{func_value_release_to_mark_value.c}

{\stt struct value* value\_release\_to\_mark ( struct value* mark )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
Refs Var:\ & all\_values & value.c & \cxrefvar{all_values}{value.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_static\_field()}
\label{func_value_static_field_value.c}

{\stt struct value* value\_static\_field ( struct type* type, int fieldno )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Calls:\ & deprecated\_value\_address\_hack() & value.c & \cxreffunc{deprecated_value_address_hack}{value.c}\\
\ & deprecated\_value\_lval\_hack() & value.c & \cxreffunc{deprecated_value_lval_hack}{value.c}\\
\ & lookup\_minimal\_symbol() & minsyms.c & \cxreffunc{lookup_minimal_symbol}{minsyms.c}\\
\cxreftabbreak{cxreftabiii}
\ & lookup\_symbol() & symtab.c & \cxreffunc{lookup_symbol}{symtab.c}\\
\ & read\_var\_value() & findvar.c & \cxreffunc{read_var_value}{findvar.c}\\
\ & symbol\_read\_needs\_frame() & findvar.c & \cxreffunc{symbol_read_needs_frame}{findvar.c}\\
\ & value\_at() & valops.c & \cxreffunc{value_at}{valops.c}\\
\ & warning() & utils.c & \cxreffunc{warning}{utils.c}\\
Called by:\ & cp\_print\_value\_fields() & cp-valprint.c & \cxreffunc{cp_print_value_fields}{cp-valprint.c}\\
\ & java\_print\_value\_fields() & jv-valprint.c & \cxreffunc{java_print_value_fields}{jv-valprint.c}\\
\ & search\_struct\_field() & valops.c & \cxreffunc{search_struct_field}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_struct\_elt\_for\_reference() & valops.c & \cxreffunc{value_struct_elt_for_reference}{valops.c}\\
\ & varobj\_value\_struct\_elt\_by\_index() & varobj.c & \cxreffunc{varobj_value_struct_elt_by_index}{varobj.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_type()}
\label{func_value_type_value.c}

{\stt struct type* value\_type ( struct value* value )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & ada\_args\_match() & ada-lang.c & \cxreffunc{ada_args_match}{ada-lang.c}\\
\ & ada\_array\_bound() & ada-lang.c & \cxreffunc{ada_array_bound}{ada-lang.c}\\
\ & ada\_array\_length() & ada-lang.c & \cxreffunc{ada_array_length}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_coerce\_ref() & ada-lang.c & \cxreffunc{ada_coerce_ref}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array}{ada-lang.c}\\
\ & ada\_coerce\_to\_simple\_array\_ptr() & ada-lang.c & \cxreffunc{ada_coerce_to_simple_array_ptr}{ada-lang.c}\\
\ & ada\_convert\_actuals() & ada-lang.c & \cxreffunc{ada_convert_actuals}{ada-lang.c}\\
\ & ada\_evaluate\_subexp() & ada-lang.c & \cxreffunc{ada_evaluate_subexp}{ada-lang.c}\\
\ & ada\_tag\_name() & ada-lang.c & \cxreffunc{ada_tag_name}{ada-lang.c}\\
\ & ada\_tag\_type() & ada-lang.c & \cxreffunc{ada_tag_type}{ada-lang.c}\\
\ & ada\_to\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_fixed_value}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_to\_static\_fixed\_value() & ada-lang.c & \cxreffunc{ada_to_static_fixed_value}{ada-lang.c}\\
\ & ada\_type\_of\_array() & ada-lang.c & \cxreffunc{ada_type_of_array}{ada-lang.c}\\
\ & ada\_val\_print\_1() & ada-valprint.c & \cxreffunc{ada_val_print_1}{ada-valprint.c}\\
\ & ada\_value\_assign() & ada-lang.c & \cxreffunc{ada_value_assign}{ada-lang.c}\\
\ & ada\_value\_binop() & ada-lang.c & \cxreffunc{ada_value_binop}{ada-lang.c}\\
\ & ada\_value\_equal() & ada-lang.c & \cxreffunc{ada_value_equal}{ada-lang.c}\\
\ & ada\_value\_print() & ada-valprint.c & \cxreffunc{ada_value_print}{ada-valprint.c}\\
\ & ada\_value\_slice() & ada-lang.c & \cxreffunc{ada_value_slice}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & ada\_value\_struct\_elt() & ada-lang.c & \cxreffunc{ada_value_struct_elt}{ada-lang.c}\\
\ & ada\_value\_subscript() & ada-lang.c & \cxreffunc{ada_value_subscript}{ada-lang.c}\\
\ & binop\_user\_defined\_p() & valarith.c & \cxreffunc{binop_user_defined_p}{valarith.c}\\
\ & bpstat\_stop\_status() & breakpoint.c & \cxreffunc{bpstat_stop_status}{breakpoint.c}\\
\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\ & can\_use\_hardware\_watchpoint() & breakpoint.c & \cxreffunc{can_use_hardware_watchpoint}{breakpoint.c}\\
\ & cast\_from\_fixed\_to\_double() & ada-lang.c & \cxreffunc{cast_from_fixed_to_double}{ada-lang.c}\\
\ & cast\_into\_complex() & valops.c & \cxreffunc{cast_into_complex}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & cast\_to\_fixed() & ada-lang.c & \cxreffunc{cast_to_fixed}{ada-lang.c}\\
\ & check\_field() & valops.c & \cxreffunc{check_field}{valops.c}\\
\ & coerce\_array() & value.c & \cxreffunc{coerce_array}{value.c}\\
\ & coerce\_enum() & value.c & \cxreffunc{coerce_enum}{value.c}\\
\ & coerce\_for\_assign() & ada-lang.c & \cxreffunc{coerce_for_assign}{ada-lang.c}\\
\ & coerce\_ref() & value.c & \cxreffunc{coerce_ref}{value.c}\\
\ & coerce\_unspec\_val\_to\_type() & ada-lang.c & \cxreffunc{coerce_unspec_val_to_type}{ada-lang.c}\\
\ & common\_val\_print() & valprint.c & \cxreffunc{common_val_print}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
\ & convert\_actual() & ada-lang.c & \cxreffunc{convert_actual}{ada-lang.c}\\
\ & cp\_print\_hpacc\_virtual\_table\_entries() & cp-valprint.c & \cxreffunc{cp_print_hpacc_virtual_table_entries}{cp-valprint.c}\\
\ & cplus\_value\_of\_child() & varobj.c & \cxreffunc{cplus_value_of_child}{varobj.c}\\
\ & decode\_dollar() & linespec.c & \cxreffunc{decode_dollar}{linespec.c}\\
\ & decode\_packed\_array() & ada-lang.c & \cxreffunc{decode_packed_array}{ada-lang.c}\\
\ & desc\_bounds() & ada-lang.c & \cxreffunc{desc_bounds}{ada-lang.c}\\
\ & desc\_data() & ada-lang.c & \cxreffunc{desc_data}{ada-lang.c}\\
\ & ensure\_lval() & ada-lang.c & \cxreffunc{ensure_lval}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & evaluate\_struct\_tuple() & eval.c & \cxreffunc{evaluate_struct_tuple}{eval.c}\\
\ & evaluate\_subexp\_for\_address() & eval.c & \cxreffunc{evaluate_subexp_for_address}{eval.c}\\
\ & evaluate\_subexp\_for\_sizeof() & eval.c & \cxreffunc{evaluate_subexp_for_sizeof}{eval.c}\\
\ & evaluate\_subexp\_java() & jv-lang.c & \cxreffunc{evaluate_subexp_java}{jv-lang.c}\\
\ & evaluate\_subexp\_standard() & eval.c & \cxreffunc{evaluate_subexp_standard}{eval.c}\\
\ & find\_function\_addr() & infcall.c & \cxreffunc{find_function_addr}{infcall.c}\\
\ & find\_overload\_match() & valops.c & \cxreffunc{find_overload_match}{valops.c}\\
\ & gen\_expr() & ax-gdb.c & \cxreffunc{gen_expr}{ax-gdb.c}\\
\cxreftabbreak{cxreftabiii}
\ & gen\_repeat() & ax-gdb.c & \cxreffunc{gen_repeat}{ax-gdb.c}\\
\ & get\_closure\_dynamic\_type() & gdbtypes.c & \cxreffunc{get_closure_dynamic_type}{gdbtypes.c}\\
\ & get\_closure\_implementation\_fn() & gdbtypes.c & \cxreffunc{get_closure_implementation_fn}{gdbtypes.c}\\
\ & get\_java\_utf8\_name() & jv-lang.c & \cxreffunc{get_java_utf8_name}{jv-lang.c}\\
\ & get\_number\_trailer() & breakpoint.c & \cxreffunc{get_number_trailer}{breakpoint.c}\\
\ & gnuv2\_value\_rtti\_type() & gnu-v2-abi.c & \cxreffunc{gnuv2_value_rtti_type}{gnu-v2-abi.c}\\
\ & gnuv2\_virtual\_fn\_field() & gnu-v2-abi.c & \cxreffunc{gnuv2_virtual_fn_field}{gnu-v2-abi.c}\\
\ & gnuv3\_rtti\_type() & gnu-v3-abi.c & \cxreffunc{gnuv3_rtti_type}{gnu-v3-abi.c}\\
\cxreftabbreak{cxreftabiii}
\ & gnuv3\_virtual\_fn\_field() & gnu-v3-abi.c & \cxreffunc{gnuv3_virtual_fn_field}{gnu-v3-abi.c}\\
\ & hand\_function\_call() & infcall.c & \cxreffunc{hand_function_call}{infcall.c}\\
\ & hpacc\_value\_rtti\_type() & hpacc-abi.c & \cxreffunc{hpacc_value_rtti_type}{hpacc-abi.c}\\
\ & init\_array\_element() & eval.c & \cxreffunc{init_array_element}{eval.c}\\
\ & insert\_bp\_location() & breakpoint.c & \cxreffunc{insert_bp_location}{breakpoint.c}\\
\ & invoke\_block\_command() & printcmd.c & \cxreffunc{invoke_block_command}{printcmd.c}\\
\ & java\_class\_from\_object() & jv-lang.c & \cxreffunc{java_class_from_object}{jv-lang.c}\\
\ & java\_link\_class\_type() & jv-lang.c & \cxreffunc{java_link_class_type}{jv-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & java\_print\_value\_fields() & jv-valprint.c & \cxreffunc{java_print_value_fields}{jv-valprint.c}\\
\ & java\_value\_print() & jv-valprint.c & \cxreffunc{java_value_print}{jv-valprint.c}\\
\ & lookup\_symbol\_aux() & symtab.c & \cxreffunc{lookup_symbol_aux}{symtab.c}\\
\ & maintenance\_print\_type() & typeprint.c & \cxreffunc{maintenance_print_type}{typeprint.c}\\
\ & make\_array\_descriptor() & ada-lang.c & \cxreffunc{make_array_descriptor}{ada-lang.c}\\
\ & output\_command() & printcmd.c & \cxreffunc{output_command}{printcmd.c}\\
\ & pascal\_object\_print\_static\_field() & p-valprint.c & \cxreffunc{pascal_object_print_static_field}{p-valprint.c}\\
\ & pascal\_parse() & p-exp.c & \cxreffunc{pascal_parse}{p-exp.c}\\
\cxreftabbreak{cxreftabiii}
\ & pascal\_value\_print() & p-valprint.c & \cxreffunc{pascal_value_print}{p-valprint.c}\\
\ & pos\_atr() & ada-lang.c & \cxreffunc{pos_atr}{ada-lang.c}\\
\ & possible\_user\_operator\_p() & ada-lang.c & \cxreffunc{possible_user_operator_p}{ada-lang.c}\\
\ & print\_command\_1() & printcmd.c & \cxreffunc{print_command_1}{printcmd.c}\\
\ & print\_formatted() & printcmd.c & \cxreffunc{print_formatted}{printcmd.c}\\
\ & print\_frame\_args() & stack.c & \cxreffunc{print_frame_args}{stack.c}\\
\ & print\_object\_command() & objc-lang.c & \cxreffunc{print_object_command}{objc-lang.c}\\
\ & printf\_command() & printcmd.c & \cxreffunc{printf_command}{printcmd.c}\\
\cxreftabbreak{cxreftabiii}
\ & remove\_breakpoint() & breakpoint.c & \cxreffunc{remove_breakpoint}{breakpoint.c}\\
\ & resolve\_subexp() & ada-lang.c & \cxreffunc{resolve_subexp}{ada-lang.c}\\
\ & return\_command() & stack.c & \cxreffunc{return_command}{stack.c}\\
\ & scan\_discrim\_bound() & ada-lang.c & \cxreffunc{scan_discrim_bound}{ada-lang.c}\\
\ & scm\_lreadr() & scm-exp.c & \cxreffunc{scm_lreadr}{scm-exp.c}\\
\ & set\_internalvar\_component() & value.c & \cxreffunc{set_internalvar_component}{value.c}\\
\ & thin\_data\_pntr() & ada-lang.c & \cxreffunc{thin_data_pntr}{ada-lang.c}\\
\ & to\_fixed\_variant\_branch\_type() & ada-lang.c & \cxreffunc{to_fixed_variant_branch_type}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & type\_from\_class() & jv-lang.c & \cxreffunc{type_from_class}{jv-lang.c}\\
\ & type\_of\_child() & varobj.c & \cxreffunc{type_of_child}{varobj.c}\\
\ & typecmp() & valops.c & \cxreffunc{typecmp}{valops.c}\\
\ & unop\_user\_defined\_p() & valarith.c & \cxreffunc{unop_user_defined_p}{valarith.c}\\
\ & unwrap\_value() & ada-lang.c & \cxreffunc{unwrap_value}{ada-lang.c}\\
\ & value\_add() & valarith.c & \cxreffunc{value_add}{valarith.c}\\
\ & value\_addr() & valops.c & \cxreffunc{value_addr}{valops.c}\\
\ & value\_arg\_coerce() & infcall.c & \cxreffunc{value_arg_coerce}{infcall.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_as\_address() & value.c & \cxreffunc{value_as_address}{value.c}\\
\ & value\_as\_double() & value.c & \cxreffunc{value_as_double}{value.c}\\
\ & value\_as\_long() & value.c & \cxreffunc{value_as_long}{value.c}\\
\ & value\_assign() & valops.c & \cxreffunc{value_assign}{valops.c}\\
\ & value\_binop() & valarith.c & \cxreffunc{value_binop}{valarith.c}\\
\ & value\_cast\_1() & valops.c & \cxreffunc{value_cast_1}{valops.c}\\
\ & value\_coerce\_array() & valops.c & \cxreffunc{value_coerce_array}{valops.c}\\
\ & value\_coerce\_function() & valops.c & \cxreffunc{value_coerce_function}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_complement() & valarith.c & \cxreffunc{value_complement}{valarith.c}\\
\ & value\_concat() & valarith.c & \cxreffunc{value_concat}{valarith.c}\\
\ & value\_contents\_equal() & value.c & \cxreffunc{value_contents_equal}{value.c}\\
\ & value\_equal() & valarith.c & \cxreffunc{value_equal}{valarith.c}\\
\ & value\_field() & value.c & \cxreffunc{value_field}{value.c}\\
\ & value\_find\_oload\_method\_list() & valops.c & \cxreffunc{value_find_oload_method_list}{valops.c}\\
\ & value\_fn\_field() & value.c & \cxreffunc{value_fn_field}{value.c}\\
\ & value\_full\_object() & valops.c & \cxreffunc{value_full_object}{valops.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_in() & valarith.c & \cxreffunc{value_in}{valarith.c}\\
\ & value\_ind() & valops.c & \cxreffunc{value_ind}{valops.c}\\
\ & value\_less() & valarith.c & \cxreffunc{value_less}{valarith.c}\\
\ & value\_logical\_not() & valarith.c & \cxreffunc{value_logical_not}{valarith.c}\\
\ & value\_neg() & valarith.c & \cxreffunc{value_neg}{valarith.c}\\
\ & value\_objc\_target\_type() & objc-lang.c & \cxreffunc{value_objc_target_type}{objc-lang.c}\\
\ & value\_of\_builtin\_frame\_fp\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_fp_reg}{std-regs.c}\\
\ & value\_of\_builtin\_frame\_pc\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_pc_reg}{std-regs.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_of\_builtin\_frame\_reg() & std-regs.c & \cxreffunc{value_of_builtin_frame_reg}{std-regs.c}\\
\ & value\_pos() & valarith.c & \cxreffunc{value_pos}{valarith.c}\\
\ & value\_slice() & valops.c & \cxreffunc{value_slice}{valops.c}\\
\ & value\_strcmp() & valarith.c & \cxreffunc{value_strcmp}{valarith.c}\\
\ & value\_struct\_elt() & valops.c & \cxreffunc{value_struct_elt}{valops.c}\\
\ & value\_sub() & valarith.c & \cxreffunc{value_sub}{valarith.c}\\
\ & value\_subscript() & valarith.c & \cxreffunc{value_subscript}{valarith.c}\\
\ & value\_subscript\_packed() & ada-lang.c & \cxreffunc{value_subscript_packed}{ada-lang.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_subscripted\_rvalue() & valarith.c & \cxreffunc{value_subscripted_rvalue}{valarith.c}\\
\ & value\_val\_atr() & ada-lang.c & \cxreffunc{value_val_atr}{ada-lang.c}\\
\ & value\_x\_binop() & valarith.c & \cxreffunc{value_x_binop}{valarith.c}\\
\ & value\_x\_unop() & valarith.c & \cxreffunc{value_x_unop}{valarith.c}\\
\ & varobj\_create() & varobj.c & \cxreffunc{varobj_create}{varobj.c}\\
\ & varobj\_fixup\_value() & varobj.c & \cxreffunc{varobj_fixup_value}{varobj.c}\\
\ & varobj\_get\_dynamic\_type() & varobj.c & \cxreffunc{varobj_get_dynamic_type}{varobj.c}\\
\ & varobj\_get\_type\_internal() & varobj.c & \cxreffunc{varobj_get_type_internal}{varobj.c}\\
\cxreftabbreak{cxreftabiii}
\ & varobj\_value\_struct\_elt\_by\_index() & varobj.c & \cxreffunc{varobj_value_struct_elt_by_index}{varobj.c}\\
\ & watch\_command\_1() & breakpoint.c & \cxreffunc{watch_command_1}{breakpoint.c}\\
\ & watchpoint\_equal() & breakpoint.c & \cxreffunc{watchpoint_equal}{breakpoint.c}\\
\ & whatis\_exp() & typeprint.c & \cxreffunc{whatis_exp}{typeprint.c}\\
\ & x\_command() & printcmd.c & \cxreffunc{x_command}{printcmd.c}\\
\end{cxreftabiii}


\subsubsection{Global Function value\_var\_status()}
\label{func_value_var_status_value.c}

{\stt int value\_var\_status ( struct value* val )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.h & \ & \cxreffile{value.h}\\
Called by:\ & c\_value\_print() & c-valprint.c & \cxreffunc{c_value_print}{c-valprint.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_convenience()}
\label{func_show_convenience_value.c}

{\stt static void show\_convenience ( const char* ignore, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.c & \ & \cxreffile{value.c}\\
Calls:\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\ & printf\_unfiltered() & utils.c & \cxreffunc{printf_unfiltered}{utils.c}\\
\ & value\_print() & valprint.c & \cxreffunc{value_print}{valprint.c}\\
\cxreftabbreak{cxreftabiii}
Used in:\ & \_initialize\_values() & value.c & \cxreffunc{_initialize_values}{value.c}\\
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & internalvars & value.c & \cxrefvar{internalvars}{value.c}\\
\end{cxreftabiii}


\subsubsection{Local Function show\_values()}
\label{func_show_values_value.c}

{\stt static void show\_values ( const char* num\_exp, int from\_tty )}

\smallskip
\begin{cxreftabiii}
Prototype:& value.c & \ & \cxreffile{value.c}\\
Calls:\ & access\_value\_history() & value.c & \cxreffunc{access_value_history}{value.c}\\
\ & parse\_and\_eval\_long() & eval.c & \cxreffunc{parse_and_eval_long}{eval.c}\\
\ & printf\_filtered() & utils.c & \cxreffunc{printf_filtered}{utils.c}\\
\cxreftabbreak{cxreftabiii}
\ & value\_print() & valprint.c & \cxreffunc{value_print}{valprint.c}\\
Used in:\ & \_initialize\_values() & value.c & \cxreffunc{_initialize_values}{value.c}\\
Refs Var:\ & gdb\_stdout & main.c & \cxrefvar{gdb_stdout}{main.c}\\
\ & value\_history\_count & value.c & \cxrefvar{value_history_count}{value.c}\\
\end{cxreftabiii}

